// This file is generated by rust-protobuf 2.8.0. Do not edit
// @generated

// https://github.com/Manishearth/rust-clippy/issues/702
#![allow(unknown_lints)]
#![allow(clippy::all)]

#![cfg_attr(rustfmt, rustfmt_skip)]

#![allow(box_pointers)]
#![allow(dead_code)]
#![allow(missing_docs)]
#![allow(non_camel_case_types)]
#![allow(non_snake_case)]
#![allow(non_upper_case_globals)]
#![allow(trivial_casts)]
#![allow(unsafe_code)]
#![allow(unused_imports)]
#![allow(unused_results)]
//! Generated file from `core/Tron.proto`

use protobuf::Message as Message_imported_for_functions;
use protobuf::ProtobufEnum as ProtobufEnum_imported_for_functions;

/// Generated files are compatible only with the same version
/// of protobuf runtime.
const _PROTOBUF_VERSION_CHECK: () = ::protobuf::VERSION_2_8_0;

#[derive(PartialEq,Clone,Default)]
pub struct AccountId {
    // message fields
    pub name: ::std::vec::Vec<u8>,
    pub address: ::std::vec::Vec<u8>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a AccountId {
    fn default() -> &'a AccountId {
        <AccountId as ::protobuf::Message>::default_instance()
    }
}

impl AccountId {
    pub fn new() -> AccountId {
        ::std::default::Default::default()
    }

    // bytes name = 1;


    pub fn get_name(&self) -> &[u8] {
        &self.name
    }
    pub fn clear_name(&mut self) {
        self.name.clear();
    }

    // Param is passed by value, moved
    pub fn set_name(&mut self, v: ::std::vec::Vec<u8>) {
        self.name = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_name(&mut self) -> &mut ::std::vec::Vec<u8> {
        &mut self.name
    }

    // Take field
    pub fn take_name(&mut self) -> ::std::vec::Vec<u8> {
        ::std::mem::replace(&mut self.name, ::std::vec::Vec::new())
    }

    // bytes address = 2;


    pub fn get_address(&self) -> &[u8] {
        &self.address
    }
    pub fn clear_address(&mut self) {
        self.address.clear();
    }

    // Param is passed by value, moved
    pub fn set_address(&mut self, v: ::std::vec::Vec<u8>) {
        self.address = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_address(&mut self) -> &mut ::std::vec::Vec<u8> {
        &mut self.address
    }

    // Take field
    pub fn take_address(&mut self) -> ::std::vec::Vec<u8> {
        ::std::mem::replace(&mut self.address, ::std::vec::Vec::new())
    }
}

impl ::protobuf::Message for AccountId {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_bytes_into(wire_type, is, &mut self.name)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_bytes_into(wire_type, is, &mut self.address)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.name.is_empty() {
            my_size += ::protobuf::rt::bytes_size(1, &self.name);
        }
        if !self.address.is_empty() {
            my_size += ::protobuf::rt::bytes_size(2, &self.address);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if !self.name.is_empty() {
            os.write_bytes(1, &self.name)?;
        }
        if !self.address.is_empty() {
            os.write_bytes(2, &self.address)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> AccountId {
        AccountId::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                    "name",
                    |m: &AccountId| { &m.name },
                    |m: &mut AccountId| { &mut m.name },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                    "address",
                    |m: &AccountId| { &m.address },
                    |m: &mut AccountId| { &mut m.address },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<AccountId>(
                    "AccountId",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static AccountId {
        static mut instance: ::protobuf::lazy::Lazy<AccountId> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const AccountId,
        };
        unsafe {
            instance.get(AccountId::new)
        }
    }
}

impl ::protobuf::Clear for AccountId {
    fn clear(&mut self) {
        self.name.clear();
        self.address.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for AccountId {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for AccountId {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct Vote {
    // message fields
    pub vote_address: ::std::vec::Vec<u8>,
    pub vote_count: i64,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a Vote {
    fn default() -> &'a Vote {
        <Vote as ::protobuf::Message>::default_instance()
    }
}

impl Vote {
    pub fn new() -> Vote {
        ::std::default::Default::default()
    }

    // bytes vote_address = 1;


    pub fn get_vote_address(&self) -> &[u8] {
        &self.vote_address
    }
    pub fn clear_vote_address(&mut self) {
        self.vote_address.clear();
    }

    // Param is passed by value, moved
    pub fn set_vote_address(&mut self, v: ::std::vec::Vec<u8>) {
        self.vote_address = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_vote_address(&mut self) -> &mut ::std::vec::Vec<u8> {
        &mut self.vote_address
    }

    // Take field
    pub fn take_vote_address(&mut self) -> ::std::vec::Vec<u8> {
        ::std::mem::replace(&mut self.vote_address, ::std::vec::Vec::new())
    }

    // int64 vote_count = 2;


    pub fn get_vote_count(&self) -> i64 {
        self.vote_count
    }
    pub fn clear_vote_count(&mut self) {
        self.vote_count = 0;
    }

    // Param is passed by value, moved
    pub fn set_vote_count(&mut self, v: i64) {
        self.vote_count = v;
    }
}

impl ::protobuf::Message for Vote {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_bytes_into(wire_type, is, &mut self.vote_address)?;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.vote_count = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.vote_address.is_empty() {
            my_size += ::protobuf::rt::bytes_size(1, &self.vote_address);
        }
        if self.vote_count != 0 {
            my_size += ::protobuf::rt::value_size(2, self.vote_count, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if !self.vote_address.is_empty() {
            os.write_bytes(1, &self.vote_address)?;
        }
        if self.vote_count != 0 {
            os.write_int64(2, self.vote_count)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> Vote {
        Vote::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                    "vote_address",
                    |m: &Vote| { &m.vote_address },
                    |m: &mut Vote| { &mut m.vote_address },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                    "vote_count",
                    |m: &Vote| { &m.vote_count },
                    |m: &mut Vote| { &mut m.vote_count },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<Vote>(
                    "Vote",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static Vote {
        static mut instance: ::protobuf::lazy::Lazy<Vote> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const Vote,
        };
        unsafe {
            instance.get(Vote::new)
        }
    }
}

impl ::protobuf::Clear for Vote {
    fn clear(&mut self) {
        self.vote_address.clear();
        self.vote_count = 0;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for Vote {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Vote {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct Proposal {
    // message fields
    pub proposal_id: i64,
    pub proposer_address: ::std::vec::Vec<u8>,
    pub parameters: ::std::collections::HashMap<i64, i64>,
    pub expiration_time: i64,
    pub create_time: i64,
    pub approvals: ::protobuf::RepeatedField<::std::vec::Vec<u8>>,
    pub state: Proposal_State,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a Proposal {
    fn default() -> &'a Proposal {
        <Proposal as ::protobuf::Message>::default_instance()
    }
}

impl Proposal {
    pub fn new() -> Proposal {
        ::std::default::Default::default()
    }

    // int64 proposal_id = 1;


    pub fn get_proposal_id(&self) -> i64 {
        self.proposal_id
    }
    pub fn clear_proposal_id(&mut self) {
        self.proposal_id = 0;
    }

    // Param is passed by value, moved
    pub fn set_proposal_id(&mut self, v: i64) {
        self.proposal_id = v;
    }

    // bytes proposer_address = 2;


    pub fn get_proposer_address(&self) -> &[u8] {
        &self.proposer_address
    }
    pub fn clear_proposer_address(&mut self) {
        self.proposer_address.clear();
    }

    // Param is passed by value, moved
    pub fn set_proposer_address(&mut self, v: ::std::vec::Vec<u8>) {
        self.proposer_address = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_proposer_address(&mut self) -> &mut ::std::vec::Vec<u8> {
        &mut self.proposer_address
    }

    // Take field
    pub fn take_proposer_address(&mut self) -> ::std::vec::Vec<u8> {
        ::std::mem::replace(&mut self.proposer_address, ::std::vec::Vec::new())
    }

    // repeated .protocol.Proposal.ParametersEntry parameters = 3;


    pub fn get_parameters(&self) -> &::std::collections::HashMap<i64, i64> {
        &self.parameters
    }
    pub fn clear_parameters(&mut self) {
        self.parameters.clear();
    }

    // Param is passed by value, moved
    pub fn set_parameters(&mut self, v: ::std::collections::HashMap<i64, i64>) {
        self.parameters = v;
    }

    // Mutable pointer to the field.
    pub fn mut_parameters(&mut self) -> &mut ::std::collections::HashMap<i64, i64> {
        &mut self.parameters
    }

    // Take field
    pub fn take_parameters(&mut self) -> ::std::collections::HashMap<i64, i64> {
        ::std::mem::replace(&mut self.parameters, ::std::collections::HashMap::new())
    }

    // int64 expiration_time = 4;


    pub fn get_expiration_time(&self) -> i64 {
        self.expiration_time
    }
    pub fn clear_expiration_time(&mut self) {
        self.expiration_time = 0;
    }

    // Param is passed by value, moved
    pub fn set_expiration_time(&mut self, v: i64) {
        self.expiration_time = v;
    }

    // int64 create_time = 5;


    pub fn get_create_time(&self) -> i64 {
        self.create_time
    }
    pub fn clear_create_time(&mut self) {
        self.create_time = 0;
    }

    // Param is passed by value, moved
    pub fn set_create_time(&mut self, v: i64) {
        self.create_time = v;
    }

    // repeated bytes approvals = 6;


    pub fn get_approvals(&self) -> &[::std::vec::Vec<u8>] {
        &self.approvals
    }
    pub fn clear_approvals(&mut self) {
        self.approvals.clear();
    }

    // Param is passed by value, moved
    pub fn set_approvals(&mut self, v: ::protobuf::RepeatedField<::std::vec::Vec<u8>>) {
        self.approvals = v;
    }

    // Mutable pointer to the field.
    pub fn mut_approvals(&mut self) -> &mut ::protobuf::RepeatedField<::std::vec::Vec<u8>> {
        &mut self.approvals
    }

    // Take field
    pub fn take_approvals(&mut self) -> ::protobuf::RepeatedField<::std::vec::Vec<u8>> {
        ::std::mem::replace(&mut self.approvals, ::protobuf::RepeatedField::new())
    }

    // .protocol.Proposal.State state = 7;


    pub fn get_state(&self) -> Proposal_State {
        self.state
    }
    pub fn clear_state(&mut self) {
        self.state = Proposal_State::PENDING;
    }

    // Param is passed by value, moved
    pub fn set_state(&mut self, v: Proposal_State) {
        self.state = v;
    }
}

impl ::protobuf::Message for Proposal {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.proposal_id = tmp;
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_bytes_into(wire_type, is, &mut self.proposer_address)?;
                },
                3 => {
                    ::protobuf::rt::read_map_into::<::protobuf::types::ProtobufTypeInt64, ::protobuf::types::ProtobufTypeInt64>(wire_type, is, &mut self.parameters)?;
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.expiration_time = tmp;
                },
                5 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.create_time = tmp;
                },
                6 => {
                    ::protobuf::rt::read_repeated_bytes_into(wire_type, is, &mut self.approvals)?;
                },
                7 => {
                    ::protobuf::rt::read_proto3_enum_with_unknown_fields_into(wire_type, is, &mut self.state, 7, &mut self.unknown_fields)?
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.proposal_id != 0 {
            my_size += ::protobuf::rt::value_size(1, self.proposal_id, ::protobuf::wire_format::WireTypeVarint);
        }
        if !self.proposer_address.is_empty() {
            my_size += ::protobuf::rt::bytes_size(2, &self.proposer_address);
        }
        my_size += ::protobuf::rt::compute_map_size::<::protobuf::types::ProtobufTypeInt64, ::protobuf::types::ProtobufTypeInt64>(3, &self.parameters);
        if self.expiration_time != 0 {
            my_size += ::protobuf::rt::value_size(4, self.expiration_time, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.create_time != 0 {
            my_size += ::protobuf::rt::value_size(5, self.create_time, ::protobuf::wire_format::WireTypeVarint);
        }
        for value in &self.approvals {
            my_size += ::protobuf::rt::bytes_size(6, &value);
        };
        if self.state != Proposal_State::PENDING {
            my_size += ::protobuf::rt::enum_size(7, self.state);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if self.proposal_id != 0 {
            os.write_int64(1, self.proposal_id)?;
        }
        if !self.proposer_address.is_empty() {
            os.write_bytes(2, &self.proposer_address)?;
        }
        ::protobuf::rt::write_map_with_cached_sizes::<::protobuf::types::ProtobufTypeInt64, ::protobuf::types::ProtobufTypeInt64>(3, &self.parameters, os)?;
        if self.expiration_time != 0 {
            os.write_int64(4, self.expiration_time)?;
        }
        if self.create_time != 0 {
            os.write_int64(5, self.create_time)?;
        }
        for v in &self.approvals {
            os.write_bytes(6, &v)?;
        };
        if self.state != Proposal_State::PENDING {
            os.write_enum(7, self.state.value())?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> Proposal {
        Proposal::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                    "proposal_id",
                    |m: &Proposal| { &m.proposal_id },
                    |m: &mut Proposal| { &mut m.proposal_id },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                    "proposer_address",
                    |m: &Proposal| { &m.proposer_address },
                    |m: &mut Proposal| { &mut m.proposer_address },
                ));
                fields.push(::protobuf::reflect::accessor::make_map_accessor::<_, ::protobuf::types::ProtobufTypeInt64, ::protobuf::types::ProtobufTypeInt64>(
                    "parameters",
                    |m: &Proposal| { &m.parameters },
                    |m: &mut Proposal| { &mut m.parameters },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                    "expiration_time",
                    |m: &Proposal| { &m.expiration_time },
                    |m: &mut Proposal| { &mut m.expiration_time },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                    "create_time",
                    |m: &Proposal| { &m.create_time },
                    |m: &mut Proposal| { &mut m.create_time },
                ));
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                    "approvals",
                    |m: &Proposal| { &m.approvals },
                    |m: &mut Proposal| { &mut m.approvals },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeEnum<Proposal_State>>(
                    "state",
                    |m: &Proposal| { &m.state },
                    |m: &mut Proposal| { &mut m.state },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<Proposal>(
                    "Proposal",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static Proposal {
        static mut instance: ::protobuf::lazy::Lazy<Proposal> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const Proposal,
        };
        unsafe {
            instance.get(Proposal::new)
        }
    }
}

impl ::protobuf::Clear for Proposal {
    fn clear(&mut self) {
        self.proposal_id = 0;
        self.proposer_address.clear();
        self.parameters.clear();
        self.expiration_time = 0;
        self.create_time = 0;
        self.approvals.clear();
        self.state = Proposal_State::PENDING;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for Proposal {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Proposal {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(Clone,PartialEq,Eq,Debug,Hash)]
pub enum Proposal_State {
    PENDING = 0,
    DISAPPROVED = 1,
    APPROVED = 2,
    CANCELED = 3,
}

impl ::protobuf::ProtobufEnum for Proposal_State {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<Proposal_State> {
        match value {
            0 => ::std::option::Option::Some(Proposal_State::PENDING),
            1 => ::std::option::Option::Some(Proposal_State::DISAPPROVED),
            2 => ::std::option::Option::Some(Proposal_State::APPROVED),
            3 => ::std::option::Option::Some(Proposal_State::CANCELED),
            _ => ::std::option::Option::None
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [Proposal_State] = &[
            Proposal_State::PENDING,
            Proposal_State::DISAPPROVED,
            Proposal_State::APPROVED,
            Proposal_State::CANCELED,
        ];
        values
    }

    fn enum_descriptor_static() -> &'static ::protobuf::reflect::EnumDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::EnumDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                ::protobuf::reflect::EnumDescriptor::new("Proposal_State", file_descriptor_proto())
            })
        }
    }
}

impl ::std::marker::Copy for Proposal_State {
}

impl ::std::default::Default for Proposal_State {
    fn default() -> Self {
        Proposal_State::PENDING
    }
}

impl ::protobuf::reflect::ProtobufValue for Proposal_State {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Enum(self.descriptor())
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct Exchange {
    // message fields
    pub exchange_id: i64,
    pub creator_address: ::std::vec::Vec<u8>,
    pub create_time: i64,
    pub first_token_id: ::std::vec::Vec<u8>,
    pub first_token_balance: i64,
    pub second_token_id: ::std::vec::Vec<u8>,
    pub second_token_balance: i64,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a Exchange {
    fn default() -> &'a Exchange {
        <Exchange as ::protobuf::Message>::default_instance()
    }
}

impl Exchange {
    pub fn new() -> Exchange {
        ::std::default::Default::default()
    }

    // int64 exchange_id = 1;


    pub fn get_exchange_id(&self) -> i64 {
        self.exchange_id
    }
    pub fn clear_exchange_id(&mut self) {
        self.exchange_id = 0;
    }

    // Param is passed by value, moved
    pub fn set_exchange_id(&mut self, v: i64) {
        self.exchange_id = v;
    }

    // bytes creator_address = 2;


    pub fn get_creator_address(&self) -> &[u8] {
        &self.creator_address
    }
    pub fn clear_creator_address(&mut self) {
        self.creator_address.clear();
    }

    // Param is passed by value, moved
    pub fn set_creator_address(&mut self, v: ::std::vec::Vec<u8>) {
        self.creator_address = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_creator_address(&mut self) -> &mut ::std::vec::Vec<u8> {
        &mut self.creator_address
    }

    // Take field
    pub fn take_creator_address(&mut self) -> ::std::vec::Vec<u8> {
        ::std::mem::replace(&mut self.creator_address, ::std::vec::Vec::new())
    }

    // int64 create_time = 3;


    pub fn get_create_time(&self) -> i64 {
        self.create_time
    }
    pub fn clear_create_time(&mut self) {
        self.create_time = 0;
    }

    // Param is passed by value, moved
    pub fn set_create_time(&mut self, v: i64) {
        self.create_time = v;
    }

    // bytes first_token_id = 6;


    pub fn get_first_token_id(&self) -> &[u8] {
        &self.first_token_id
    }
    pub fn clear_first_token_id(&mut self) {
        self.first_token_id.clear();
    }

    // Param is passed by value, moved
    pub fn set_first_token_id(&mut self, v: ::std::vec::Vec<u8>) {
        self.first_token_id = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_first_token_id(&mut self) -> &mut ::std::vec::Vec<u8> {
        &mut self.first_token_id
    }

    // Take field
    pub fn take_first_token_id(&mut self) -> ::std::vec::Vec<u8> {
        ::std::mem::replace(&mut self.first_token_id, ::std::vec::Vec::new())
    }

    // int64 first_token_balance = 7;


    pub fn get_first_token_balance(&self) -> i64 {
        self.first_token_balance
    }
    pub fn clear_first_token_balance(&mut self) {
        self.first_token_balance = 0;
    }

    // Param is passed by value, moved
    pub fn set_first_token_balance(&mut self, v: i64) {
        self.first_token_balance = v;
    }

    // bytes second_token_id = 8;


    pub fn get_second_token_id(&self) -> &[u8] {
        &self.second_token_id
    }
    pub fn clear_second_token_id(&mut self) {
        self.second_token_id.clear();
    }

    // Param is passed by value, moved
    pub fn set_second_token_id(&mut self, v: ::std::vec::Vec<u8>) {
        self.second_token_id = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_second_token_id(&mut self) -> &mut ::std::vec::Vec<u8> {
        &mut self.second_token_id
    }

    // Take field
    pub fn take_second_token_id(&mut self) -> ::std::vec::Vec<u8> {
        ::std::mem::replace(&mut self.second_token_id, ::std::vec::Vec::new())
    }

    // int64 second_token_balance = 9;


    pub fn get_second_token_balance(&self) -> i64 {
        self.second_token_balance
    }
    pub fn clear_second_token_balance(&mut self) {
        self.second_token_balance = 0;
    }

    // Param is passed by value, moved
    pub fn set_second_token_balance(&mut self, v: i64) {
        self.second_token_balance = v;
    }
}

impl ::protobuf::Message for Exchange {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.exchange_id = tmp;
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_bytes_into(wire_type, is, &mut self.creator_address)?;
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.create_time = tmp;
                },
                6 => {
                    ::protobuf::rt::read_singular_proto3_bytes_into(wire_type, is, &mut self.first_token_id)?;
                },
                7 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.first_token_balance = tmp;
                },
                8 => {
                    ::protobuf::rt::read_singular_proto3_bytes_into(wire_type, is, &mut self.second_token_id)?;
                },
                9 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.second_token_balance = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.exchange_id != 0 {
            my_size += ::protobuf::rt::value_size(1, self.exchange_id, ::protobuf::wire_format::WireTypeVarint);
        }
        if !self.creator_address.is_empty() {
            my_size += ::protobuf::rt::bytes_size(2, &self.creator_address);
        }
        if self.create_time != 0 {
            my_size += ::protobuf::rt::value_size(3, self.create_time, ::protobuf::wire_format::WireTypeVarint);
        }
        if !self.first_token_id.is_empty() {
            my_size += ::protobuf::rt::bytes_size(6, &self.first_token_id);
        }
        if self.first_token_balance != 0 {
            my_size += ::protobuf::rt::value_size(7, self.first_token_balance, ::protobuf::wire_format::WireTypeVarint);
        }
        if !self.second_token_id.is_empty() {
            my_size += ::protobuf::rt::bytes_size(8, &self.second_token_id);
        }
        if self.second_token_balance != 0 {
            my_size += ::protobuf::rt::value_size(9, self.second_token_balance, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if self.exchange_id != 0 {
            os.write_int64(1, self.exchange_id)?;
        }
        if !self.creator_address.is_empty() {
            os.write_bytes(2, &self.creator_address)?;
        }
        if self.create_time != 0 {
            os.write_int64(3, self.create_time)?;
        }
        if !self.first_token_id.is_empty() {
            os.write_bytes(6, &self.first_token_id)?;
        }
        if self.first_token_balance != 0 {
            os.write_int64(7, self.first_token_balance)?;
        }
        if !self.second_token_id.is_empty() {
            os.write_bytes(8, &self.second_token_id)?;
        }
        if self.second_token_balance != 0 {
            os.write_int64(9, self.second_token_balance)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> Exchange {
        Exchange::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                    "exchange_id",
                    |m: &Exchange| { &m.exchange_id },
                    |m: &mut Exchange| { &mut m.exchange_id },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                    "creator_address",
                    |m: &Exchange| { &m.creator_address },
                    |m: &mut Exchange| { &mut m.creator_address },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                    "create_time",
                    |m: &Exchange| { &m.create_time },
                    |m: &mut Exchange| { &mut m.create_time },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                    "first_token_id",
                    |m: &Exchange| { &m.first_token_id },
                    |m: &mut Exchange| { &mut m.first_token_id },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                    "first_token_balance",
                    |m: &Exchange| { &m.first_token_balance },
                    |m: &mut Exchange| { &mut m.first_token_balance },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                    "second_token_id",
                    |m: &Exchange| { &m.second_token_id },
                    |m: &mut Exchange| { &mut m.second_token_id },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                    "second_token_balance",
                    |m: &Exchange| { &m.second_token_balance },
                    |m: &mut Exchange| { &mut m.second_token_balance },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<Exchange>(
                    "Exchange",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static Exchange {
        static mut instance: ::protobuf::lazy::Lazy<Exchange> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const Exchange,
        };
        unsafe {
            instance.get(Exchange::new)
        }
    }
}

impl ::protobuf::Clear for Exchange {
    fn clear(&mut self) {
        self.exchange_id = 0;
        self.creator_address.clear();
        self.create_time = 0;
        self.first_token_id.clear();
        self.first_token_balance = 0;
        self.second_token_id.clear();
        self.second_token_balance = 0;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for Exchange {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Exchange {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct ChainParameters {
    // message fields
    pub chainParameter: ::protobuf::RepeatedField<ChainParameters_ChainParameter>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a ChainParameters {
    fn default() -> &'a ChainParameters {
        <ChainParameters as ::protobuf::Message>::default_instance()
    }
}

impl ChainParameters {
    pub fn new() -> ChainParameters {
        ::std::default::Default::default()
    }

    // repeated .protocol.ChainParameters.ChainParameter chainParameter = 1;


    pub fn get_chainParameter(&self) -> &[ChainParameters_ChainParameter] {
        &self.chainParameter
    }
    pub fn clear_chainParameter(&mut self) {
        self.chainParameter.clear();
    }

    // Param is passed by value, moved
    pub fn set_chainParameter(&mut self, v: ::protobuf::RepeatedField<ChainParameters_ChainParameter>) {
        self.chainParameter = v;
    }

    // Mutable pointer to the field.
    pub fn mut_chainParameter(&mut self) -> &mut ::protobuf::RepeatedField<ChainParameters_ChainParameter> {
        &mut self.chainParameter
    }

    // Take field
    pub fn take_chainParameter(&mut self) -> ::protobuf::RepeatedField<ChainParameters_ChainParameter> {
        ::std::mem::replace(&mut self.chainParameter, ::protobuf::RepeatedField::new())
    }
}

impl ::protobuf::Message for ChainParameters {
    fn is_initialized(&self) -> bool {
        for v in &self.chainParameter {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.chainParameter)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in &self.chainParameter {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        for v in &self.chainParameter {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> ChainParameters {
        ChainParameters::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<ChainParameters_ChainParameter>>(
                    "chainParameter",
                    |m: &ChainParameters| { &m.chainParameter },
                    |m: &mut ChainParameters| { &mut m.chainParameter },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<ChainParameters>(
                    "ChainParameters",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static ChainParameters {
        static mut instance: ::protobuf::lazy::Lazy<ChainParameters> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ChainParameters,
        };
        unsafe {
            instance.get(ChainParameters::new)
        }
    }
}

impl ::protobuf::Clear for ChainParameters {
    fn clear(&mut self) {
        self.chainParameter.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ChainParameters {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ChainParameters {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct ChainParameters_ChainParameter {
    // message fields
    pub key: ::std::string::String,
    pub value: i64,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a ChainParameters_ChainParameter {
    fn default() -> &'a ChainParameters_ChainParameter {
        <ChainParameters_ChainParameter as ::protobuf::Message>::default_instance()
    }
}

impl ChainParameters_ChainParameter {
    pub fn new() -> ChainParameters_ChainParameter {
        ::std::default::Default::default()
    }

    // string key = 1;


    pub fn get_key(&self) -> &str {
        &self.key
    }
    pub fn clear_key(&mut self) {
        self.key.clear();
    }

    // Param is passed by value, moved
    pub fn set_key(&mut self, v: ::std::string::String) {
        self.key = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_key(&mut self) -> &mut ::std::string::String {
        &mut self.key
    }

    // Take field
    pub fn take_key(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.key, ::std::string::String::new())
    }

    // int64 value = 2;


    pub fn get_value(&self) -> i64 {
        self.value
    }
    pub fn clear_value(&mut self) {
        self.value = 0;
    }

    // Param is passed by value, moved
    pub fn set_value(&mut self, v: i64) {
        self.value = v;
    }
}

impl ::protobuf::Message for ChainParameters_ChainParameter {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.key)?;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.value = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.key.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.key);
        }
        if self.value != 0 {
            my_size += ::protobuf::rt::value_size(2, self.value, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if !self.key.is_empty() {
            os.write_string(1, &self.key)?;
        }
        if self.value != 0 {
            os.write_int64(2, self.value)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> ChainParameters_ChainParameter {
        ChainParameters_ChainParameter::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "key",
                    |m: &ChainParameters_ChainParameter| { &m.key },
                    |m: &mut ChainParameters_ChainParameter| { &mut m.key },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                    "value",
                    |m: &ChainParameters_ChainParameter| { &m.value },
                    |m: &mut ChainParameters_ChainParameter| { &mut m.value },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<ChainParameters_ChainParameter>(
                    "ChainParameters_ChainParameter",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static ChainParameters_ChainParameter {
        static mut instance: ::protobuf::lazy::Lazy<ChainParameters_ChainParameter> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ChainParameters_ChainParameter,
        };
        unsafe {
            instance.get(ChainParameters_ChainParameter::new)
        }
    }
}

impl ::protobuf::Clear for ChainParameters_ChainParameter {
    fn clear(&mut self) {
        self.key.clear();
        self.value = 0;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ChainParameters_ChainParameter {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ChainParameters_ChainParameter {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct Account {
    // message fields
    pub account_name: ::std::vec::Vec<u8>,
    pub field_type: AccountType,
    pub address: ::std::vec::Vec<u8>,
    pub balance: i64,
    pub votes: ::protobuf::RepeatedField<Vote>,
    pub asset: ::std::collections::HashMap<::std::string::String, i64>,
    pub assetV2: ::std::collections::HashMap<::std::string::String, i64>,
    pub frozen: ::protobuf::RepeatedField<Account_Frozen>,
    pub net_usage: i64,
    pub acquired_delegated_frozen_balance_for_bandwidth: i64,
    pub delegated_frozen_balance_for_bandwidth: i64,
    pub create_time: i64,
    pub latest_opration_time: i64,
    pub allowance: i64,
    pub latest_withdraw_time: i64,
    pub code: ::std::vec::Vec<u8>,
    pub is_witness: bool,
    pub is_committee: bool,
    pub frozen_supply: ::protobuf::RepeatedField<Account_Frozen>,
    pub asset_issued_name: ::std::vec::Vec<u8>,
    pub asset_issued_ID: ::std::vec::Vec<u8>,
    pub latest_asset_operation_time: ::std::collections::HashMap<::std::string::String, i64>,
    pub latest_asset_operation_timeV2: ::std::collections::HashMap<::std::string::String, i64>,
    pub free_net_usage: i64,
    pub free_asset_net_usage: ::std::collections::HashMap<::std::string::String, i64>,
    pub free_asset_net_usageV2: ::std::collections::HashMap<::std::string::String, i64>,
    pub latest_consume_time: i64,
    pub latest_consume_free_time: i64,
    pub account_id: ::std::vec::Vec<u8>,
    pub account_resource: ::protobuf::SingularPtrField<Account_AccountResource>,
    pub codeHash: ::std::vec::Vec<u8>,
    pub owner_permission: ::protobuf::SingularPtrField<Permission>,
    pub witness_permission: ::protobuf::SingularPtrField<Permission>,
    pub active_permission: ::protobuf::RepeatedField<Permission>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a Account {
    fn default() -> &'a Account {
        <Account as ::protobuf::Message>::default_instance()
    }
}

impl Account {
    pub fn new() -> Account {
        ::std::default::Default::default()
    }

    // bytes account_name = 1;


    pub fn get_account_name(&self) -> &[u8] {
        &self.account_name
    }
    pub fn clear_account_name(&mut self) {
        self.account_name.clear();
    }

    // Param is passed by value, moved
    pub fn set_account_name(&mut self, v: ::std::vec::Vec<u8>) {
        self.account_name = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_account_name(&mut self) -> &mut ::std::vec::Vec<u8> {
        &mut self.account_name
    }

    // Take field
    pub fn take_account_name(&mut self) -> ::std::vec::Vec<u8> {
        ::std::mem::replace(&mut self.account_name, ::std::vec::Vec::new())
    }

    // .protocol.AccountType type = 2;


    pub fn get_field_type(&self) -> AccountType {
        self.field_type
    }
    pub fn clear_field_type(&mut self) {
        self.field_type = AccountType::Normal;
    }

    // Param is passed by value, moved
    pub fn set_field_type(&mut self, v: AccountType) {
        self.field_type = v;
    }

    // bytes address = 3;


    pub fn get_address(&self) -> &[u8] {
        &self.address
    }
    pub fn clear_address(&mut self) {
        self.address.clear();
    }

    // Param is passed by value, moved
    pub fn set_address(&mut self, v: ::std::vec::Vec<u8>) {
        self.address = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_address(&mut self) -> &mut ::std::vec::Vec<u8> {
        &mut self.address
    }

    // Take field
    pub fn take_address(&mut self) -> ::std::vec::Vec<u8> {
        ::std::mem::replace(&mut self.address, ::std::vec::Vec::new())
    }

    // int64 balance = 4;


    pub fn get_balance(&self) -> i64 {
        self.balance
    }
    pub fn clear_balance(&mut self) {
        self.balance = 0;
    }

    // Param is passed by value, moved
    pub fn set_balance(&mut self, v: i64) {
        self.balance = v;
    }

    // repeated .protocol.Vote votes = 5;


    pub fn get_votes(&self) -> &[Vote] {
        &self.votes
    }
    pub fn clear_votes(&mut self) {
        self.votes.clear();
    }

    // Param is passed by value, moved
    pub fn set_votes(&mut self, v: ::protobuf::RepeatedField<Vote>) {
        self.votes = v;
    }

    // Mutable pointer to the field.
    pub fn mut_votes(&mut self) -> &mut ::protobuf::RepeatedField<Vote> {
        &mut self.votes
    }

    // Take field
    pub fn take_votes(&mut self) -> ::protobuf::RepeatedField<Vote> {
        ::std::mem::replace(&mut self.votes, ::protobuf::RepeatedField::new())
    }

    // repeated .protocol.Account.AssetEntry asset = 6;


    pub fn get_asset(&self) -> &::std::collections::HashMap<::std::string::String, i64> {
        &self.asset
    }
    pub fn clear_asset(&mut self) {
        self.asset.clear();
    }

    // Param is passed by value, moved
    pub fn set_asset(&mut self, v: ::std::collections::HashMap<::std::string::String, i64>) {
        self.asset = v;
    }

    // Mutable pointer to the field.
    pub fn mut_asset(&mut self) -> &mut ::std::collections::HashMap<::std::string::String, i64> {
        &mut self.asset
    }

    // Take field
    pub fn take_asset(&mut self) -> ::std::collections::HashMap<::std::string::String, i64> {
        ::std::mem::replace(&mut self.asset, ::std::collections::HashMap::new())
    }

    // repeated .protocol.Account.AssetV2Entry assetV2 = 56;


    pub fn get_assetV2(&self) -> &::std::collections::HashMap<::std::string::String, i64> {
        &self.assetV2
    }
    pub fn clear_assetV2(&mut self) {
        self.assetV2.clear();
    }

    // Param is passed by value, moved
    pub fn set_assetV2(&mut self, v: ::std::collections::HashMap<::std::string::String, i64>) {
        self.assetV2 = v;
    }

    // Mutable pointer to the field.
    pub fn mut_assetV2(&mut self) -> &mut ::std::collections::HashMap<::std::string::String, i64> {
        &mut self.assetV2
    }

    // Take field
    pub fn take_assetV2(&mut self) -> ::std::collections::HashMap<::std::string::String, i64> {
        ::std::mem::replace(&mut self.assetV2, ::std::collections::HashMap::new())
    }

    // repeated .protocol.Account.Frozen frozen = 7;


    pub fn get_frozen(&self) -> &[Account_Frozen] {
        &self.frozen
    }
    pub fn clear_frozen(&mut self) {
        self.frozen.clear();
    }

    // Param is passed by value, moved
    pub fn set_frozen(&mut self, v: ::protobuf::RepeatedField<Account_Frozen>) {
        self.frozen = v;
    }

    // Mutable pointer to the field.
    pub fn mut_frozen(&mut self) -> &mut ::protobuf::RepeatedField<Account_Frozen> {
        &mut self.frozen
    }

    // Take field
    pub fn take_frozen(&mut self) -> ::protobuf::RepeatedField<Account_Frozen> {
        ::std::mem::replace(&mut self.frozen, ::protobuf::RepeatedField::new())
    }

    // int64 net_usage = 8;


    pub fn get_net_usage(&self) -> i64 {
        self.net_usage
    }
    pub fn clear_net_usage(&mut self) {
        self.net_usage = 0;
    }

    // Param is passed by value, moved
    pub fn set_net_usage(&mut self, v: i64) {
        self.net_usage = v;
    }

    // int64 acquired_delegated_frozen_balance_for_bandwidth = 41;


    pub fn get_acquired_delegated_frozen_balance_for_bandwidth(&self) -> i64 {
        self.acquired_delegated_frozen_balance_for_bandwidth
    }
    pub fn clear_acquired_delegated_frozen_balance_for_bandwidth(&mut self) {
        self.acquired_delegated_frozen_balance_for_bandwidth = 0;
    }

    // Param is passed by value, moved
    pub fn set_acquired_delegated_frozen_balance_for_bandwidth(&mut self, v: i64) {
        self.acquired_delegated_frozen_balance_for_bandwidth = v;
    }

    // int64 delegated_frozen_balance_for_bandwidth = 42;


    pub fn get_delegated_frozen_balance_for_bandwidth(&self) -> i64 {
        self.delegated_frozen_balance_for_bandwidth
    }
    pub fn clear_delegated_frozen_balance_for_bandwidth(&mut self) {
        self.delegated_frozen_balance_for_bandwidth = 0;
    }

    // Param is passed by value, moved
    pub fn set_delegated_frozen_balance_for_bandwidth(&mut self, v: i64) {
        self.delegated_frozen_balance_for_bandwidth = v;
    }

    // int64 create_time = 9;


    pub fn get_create_time(&self) -> i64 {
        self.create_time
    }
    pub fn clear_create_time(&mut self) {
        self.create_time = 0;
    }

    // Param is passed by value, moved
    pub fn set_create_time(&mut self, v: i64) {
        self.create_time = v;
    }

    // int64 latest_opration_time = 10;


    pub fn get_latest_opration_time(&self) -> i64 {
        self.latest_opration_time
    }
    pub fn clear_latest_opration_time(&mut self) {
        self.latest_opration_time = 0;
    }

    // Param is passed by value, moved
    pub fn set_latest_opration_time(&mut self, v: i64) {
        self.latest_opration_time = v;
    }

    // int64 allowance = 11;


    pub fn get_allowance(&self) -> i64 {
        self.allowance
    }
    pub fn clear_allowance(&mut self) {
        self.allowance = 0;
    }

    // Param is passed by value, moved
    pub fn set_allowance(&mut self, v: i64) {
        self.allowance = v;
    }

    // int64 latest_withdraw_time = 12;


    pub fn get_latest_withdraw_time(&self) -> i64 {
        self.latest_withdraw_time
    }
    pub fn clear_latest_withdraw_time(&mut self) {
        self.latest_withdraw_time = 0;
    }

    // Param is passed by value, moved
    pub fn set_latest_withdraw_time(&mut self, v: i64) {
        self.latest_withdraw_time = v;
    }

    // bytes code = 13;


    pub fn get_code(&self) -> &[u8] {
        &self.code
    }
    pub fn clear_code(&mut self) {
        self.code.clear();
    }

    // Param is passed by value, moved
    pub fn set_code(&mut self, v: ::std::vec::Vec<u8>) {
        self.code = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_code(&mut self) -> &mut ::std::vec::Vec<u8> {
        &mut self.code
    }

    // Take field
    pub fn take_code(&mut self) -> ::std::vec::Vec<u8> {
        ::std::mem::replace(&mut self.code, ::std::vec::Vec::new())
    }

    // bool is_witness = 14;


    pub fn get_is_witness(&self) -> bool {
        self.is_witness
    }
    pub fn clear_is_witness(&mut self) {
        self.is_witness = false;
    }

    // Param is passed by value, moved
    pub fn set_is_witness(&mut self, v: bool) {
        self.is_witness = v;
    }

    // bool is_committee = 15;


    pub fn get_is_committee(&self) -> bool {
        self.is_committee
    }
    pub fn clear_is_committee(&mut self) {
        self.is_committee = false;
    }

    // Param is passed by value, moved
    pub fn set_is_committee(&mut self, v: bool) {
        self.is_committee = v;
    }

    // repeated .protocol.Account.Frozen frozen_supply = 16;


    pub fn get_frozen_supply(&self) -> &[Account_Frozen] {
        &self.frozen_supply
    }
    pub fn clear_frozen_supply(&mut self) {
        self.frozen_supply.clear();
    }

    // Param is passed by value, moved
    pub fn set_frozen_supply(&mut self, v: ::protobuf::RepeatedField<Account_Frozen>) {
        self.frozen_supply = v;
    }

    // Mutable pointer to the field.
    pub fn mut_frozen_supply(&mut self) -> &mut ::protobuf::RepeatedField<Account_Frozen> {
        &mut self.frozen_supply
    }

    // Take field
    pub fn take_frozen_supply(&mut self) -> ::protobuf::RepeatedField<Account_Frozen> {
        ::std::mem::replace(&mut self.frozen_supply, ::protobuf::RepeatedField::new())
    }

    // bytes asset_issued_name = 17;


    pub fn get_asset_issued_name(&self) -> &[u8] {
        &self.asset_issued_name
    }
    pub fn clear_asset_issued_name(&mut self) {
        self.asset_issued_name.clear();
    }

    // Param is passed by value, moved
    pub fn set_asset_issued_name(&mut self, v: ::std::vec::Vec<u8>) {
        self.asset_issued_name = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_asset_issued_name(&mut self) -> &mut ::std::vec::Vec<u8> {
        &mut self.asset_issued_name
    }

    // Take field
    pub fn take_asset_issued_name(&mut self) -> ::std::vec::Vec<u8> {
        ::std::mem::replace(&mut self.asset_issued_name, ::std::vec::Vec::new())
    }

    // bytes asset_issued_ID = 57;


    pub fn get_asset_issued_ID(&self) -> &[u8] {
        &self.asset_issued_ID
    }
    pub fn clear_asset_issued_ID(&mut self) {
        self.asset_issued_ID.clear();
    }

    // Param is passed by value, moved
    pub fn set_asset_issued_ID(&mut self, v: ::std::vec::Vec<u8>) {
        self.asset_issued_ID = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_asset_issued_ID(&mut self) -> &mut ::std::vec::Vec<u8> {
        &mut self.asset_issued_ID
    }

    // Take field
    pub fn take_asset_issued_ID(&mut self) -> ::std::vec::Vec<u8> {
        ::std::mem::replace(&mut self.asset_issued_ID, ::std::vec::Vec::new())
    }

    // repeated .protocol.Account.LatestAssetOperationTimeEntry latest_asset_operation_time = 18;


    pub fn get_latest_asset_operation_time(&self) -> &::std::collections::HashMap<::std::string::String, i64> {
        &self.latest_asset_operation_time
    }
    pub fn clear_latest_asset_operation_time(&mut self) {
        self.latest_asset_operation_time.clear();
    }

    // Param is passed by value, moved
    pub fn set_latest_asset_operation_time(&mut self, v: ::std::collections::HashMap<::std::string::String, i64>) {
        self.latest_asset_operation_time = v;
    }

    // Mutable pointer to the field.
    pub fn mut_latest_asset_operation_time(&mut self) -> &mut ::std::collections::HashMap<::std::string::String, i64> {
        &mut self.latest_asset_operation_time
    }

    // Take field
    pub fn take_latest_asset_operation_time(&mut self) -> ::std::collections::HashMap<::std::string::String, i64> {
        ::std::mem::replace(&mut self.latest_asset_operation_time, ::std::collections::HashMap::new())
    }

    // repeated .protocol.Account.LatestAssetOperationTimeV2Entry latest_asset_operation_timeV2 = 58;


    pub fn get_latest_asset_operation_timeV2(&self) -> &::std::collections::HashMap<::std::string::String, i64> {
        &self.latest_asset_operation_timeV2
    }
    pub fn clear_latest_asset_operation_timeV2(&mut self) {
        self.latest_asset_operation_timeV2.clear();
    }

    // Param is passed by value, moved
    pub fn set_latest_asset_operation_timeV2(&mut self, v: ::std::collections::HashMap<::std::string::String, i64>) {
        self.latest_asset_operation_timeV2 = v;
    }

    // Mutable pointer to the field.
    pub fn mut_latest_asset_operation_timeV2(&mut self) -> &mut ::std::collections::HashMap<::std::string::String, i64> {
        &mut self.latest_asset_operation_timeV2
    }

    // Take field
    pub fn take_latest_asset_operation_timeV2(&mut self) -> ::std::collections::HashMap<::std::string::String, i64> {
        ::std::mem::replace(&mut self.latest_asset_operation_timeV2, ::std::collections::HashMap::new())
    }

    // int64 free_net_usage = 19;


    pub fn get_free_net_usage(&self) -> i64 {
        self.free_net_usage
    }
    pub fn clear_free_net_usage(&mut self) {
        self.free_net_usage = 0;
    }

    // Param is passed by value, moved
    pub fn set_free_net_usage(&mut self, v: i64) {
        self.free_net_usage = v;
    }

    // repeated .protocol.Account.FreeAssetNetUsageEntry free_asset_net_usage = 20;


    pub fn get_free_asset_net_usage(&self) -> &::std::collections::HashMap<::std::string::String, i64> {
        &self.free_asset_net_usage
    }
    pub fn clear_free_asset_net_usage(&mut self) {
        self.free_asset_net_usage.clear();
    }

    // Param is passed by value, moved
    pub fn set_free_asset_net_usage(&mut self, v: ::std::collections::HashMap<::std::string::String, i64>) {
        self.free_asset_net_usage = v;
    }

    // Mutable pointer to the field.
    pub fn mut_free_asset_net_usage(&mut self) -> &mut ::std::collections::HashMap<::std::string::String, i64> {
        &mut self.free_asset_net_usage
    }

    // Take field
    pub fn take_free_asset_net_usage(&mut self) -> ::std::collections::HashMap<::std::string::String, i64> {
        ::std::mem::replace(&mut self.free_asset_net_usage, ::std::collections::HashMap::new())
    }

    // repeated .protocol.Account.FreeAssetNetUsageV2Entry free_asset_net_usageV2 = 59;


    pub fn get_free_asset_net_usageV2(&self) -> &::std::collections::HashMap<::std::string::String, i64> {
        &self.free_asset_net_usageV2
    }
    pub fn clear_free_asset_net_usageV2(&mut self) {
        self.free_asset_net_usageV2.clear();
    }

    // Param is passed by value, moved
    pub fn set_free_asset_net_usageV2(&mut self, v: ::std::collections::HashMap<::std::string::String, i64>) {
        self.free_asset_net_usageV2 = v;
    }

    // Mutable pointer to the field.
    pub fn mut_free_asset_net_usageV2(&mut self) -> &mut ::std::collections::HashMap<::std::string::String, i64> {
        &mut self.free_asset_net_usageV2
    }

    // Take field
    pub fn take_free_asset_net_usageV2(&mut self) -> ::std::collections::HashMap<::std::string::String, i64> {
        ::std::mem::replace(&mut self.free_asset_net_usageV2, ::std::collections::HashMap::new())
    }

    // int64 latest_consume_time = 21;


    pub fn get_latest_consume_time(&self) -> i64 {
        self.latest_consume_time
    }
    pub fn clear_latest_consume_time(&mut self) {
        self.latest_consume_time = 0;
    }

    // Param is passed by value, moved
    pub fn set_latest_consume_time(&mut self, v: i64) {
        self.latest_consume_time = v;
    }

    // int64 latest_consume_free_time = 22;


    pub fn get_latest_consume_free_time(&self) -> i64 {
        self.latest_consume_free_time
    }
    pub fn clear_latest_consume_free_time(&mut self) {
        self.latest_consume_free_time = 0;
    }

    // Param is passed by value, moved
    pub fn set_latest_consume_free_time(&mut self, v: i64) {
        self.latest_consume_free_time = v;
    }

    // bytes account_id = 23;


    pub fn get_account_id(&self) -> &[u8] {
        &self.account_id
    }
    pub fn clear_account_id(&mut self) {
        self.account_id.clear();
    }

    // Param is passed by value, moved
    pub fn set_account_id(&mut self, v: ::std::vec::Vec<u8>) {
        self.account_id = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_account_id(&mut self) -> &mut ::std::vec::Vec<u8> {
        &mut self.account_id
    }

    // Take field
    pub fn take_account_id(&mut self) -> ::std::vec::Vec<u8> {
        ::std::mem::replace(&mut self.account_id, ::std::vec::Vec::new())
    }

    // .protocol.Account.AccountResource account_resource = 26;


    pub fn get_account_resource(&self) -> &Account_AccountResource {
        self.account_resource.as_ref().unwrap_or_else(|| Account_AccountResource::default_instance())
    }
    pub fn clear_account_resource(&mut self) {
        self.account_resource.clear();
    }

    pub fn has_account_resource(&self) -> bool {
        self.account_resource.is_some()
    }

    // Param is passed by value, moved
    pub fn set_account_resource(&mut self, v: Account_AccountResource) {
        self.account_resource = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_account_resource(&mut self) -> &mut Account_AccountResource {
        if self.account_resource.is_none() {
            self.account_resource.set_default();
        }
        self.account_resource.as_mut().unwrap()
    }

    // Take field
    pub fn take_account_resource(&mut self) -> Account_AccountResource {
        self.account_resource.take().unwrap_or_else(|| Account_AccountResource::new())
    }

    // bytes codeHash = 30;


    pub fn get_codeHash(&self) -> &[u8] {
        &self.codeHash
    }
    pub fn clear_codeHash(&mut self) {
        self.codeHash.clear();
    }

    // Param is passed by value, moved
    pub fn set_codeHash(&mut self, v: ::std::vec::Vec<u8>) {
        self.codeHash = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_codeHash(&mut self) -> &mut ::std::vec::Vec<u8> {
        &mut self.codeHash
    }

    // Take field
    pub fn take_codeHash(&mut self) -> ::std::vec::Vec<u8> {
        ::std::mem::replace(&mut self.codeHash, ::std::vec::Vec::new())
    }

    // .protocol.Permission owner_permission = 31;


    pub fn get_owner_permission(&self) -> &Permission {
        self.owner_permission.as_ref().unwrap_or_else(|| Permission::default_instance())
    }
    pub fn clear_owner_permission(&mut self) {
        self.owner_permission.clear();
    }

    pub fn has_owner_permission(&self) -> bool {
        self.owner_permission.is_some()
    }

    // Param is passed by value, moved
    pub fn set_owner_permission(&mut self, v: Permission) {
        self.owner_permission = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_owner_permission(&mut self) -> &mut Permission {
        if self.owner_permission.is_none() {
            self.owner_permission.set_default();
        }
        self.owner_permission.as_mut().unwrap()
    }

    // Take field
    pub fn take_owner_permission(&mut self) -> Permission {
        self.owner_permission.take().unwrap_or_else(|| Permission::new())
    }

    // .protocol.Permission witness_permission = 32;


    pub fn get_witness_permission(&self) -> &Permission {
        self.witness_permission.as_ref().unwrap_or_else(|| Permission::default_instance())
    }
    pub fn clear_witness_permission(&mut self) {
        self.witness_permission.clear();
    }

    pub fn has_witness_permission(&self) -> bool {
        self.witness_permission.is_some()
    }

    // Param is passed by value, moved
    pub fn set_witness_permission(&mut self, v: Permission) {
        self.witness_permission = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_witness_permission(&mut self) -> &mut Permission {
        if self.witness_permission.is_none() {
            self.witness_permission.set_default();
        }
        self.witness_permission.as_mut().unwrap()
    }

    // Take field
    pub fn take_witness_permission(&mut self) -> Permission {
        self.witness_permission.take().unwrap_or_else(|| Permission::new())
    }

    // repeated .protocol.Permission active_permission = 33;


    pub fn get_active_permission(&self) -> &[Permission] {
        &self.active_permission
    }
    pub fn clear_active_permission(&mut self) {
        self.active_permission.clear();
    }

    // Param is passed by value, moved
    pub fn set_active_permission(&mut self, v: ::protobuf::RepeatedField<Permission>) {
        self.active_permission = v;
    }

    // Mutable pointer to the field.
    pub fn mut_active_permission(&mut self) -> &mut ::protobuf::RepeatedField<Permission> {
        &mut self.active_permission
    }

    // Take field
    pub fn take_active_permission(&mut self) -> ::protobuf::RepeatedField<Permission> {
        ::std::mem::replace(&mut self.active_permission, ::protobuf::RepeatedField::new())
    }
}

impl ::protobuf::Message for Account {
    fn is_initialized(&self) -> bool {
        for v in &self.votes {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.frozen {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.frozen_supply {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.account_resource {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.owner_permission {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.witness_permission {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.active_permission {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_bytes_into(wire_type, is, &mut self.account_name)?;
                },
                2 => {
                    ::protobuf::rt::read_proto3_enum_with_unknown_fields_into(wire_type, is, &mut self.field_type, 2, &mut self.unknown_fields)?
                },
                3 => {
                    ::protobuf::rt::read_singular_proto3_bytes_into(wire_type, is, &mut self.address)?;
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.balance = tmp;
                },
                5 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.votes)?;
                },
                6 => {
                    ::protobuf::rt::read_map_into::<::protobuf::types::ProtobufTypeString, ::protobuf::types::ProtobufTypeInt64>(wire_type, is, &mut self.asset)?;
                },
                56 => {
                    ::protobuf::rt::read_map_into::<::protobuf::types::ProtobufTypeString, ::protobuf::types::ProtobufTypeInt64>(wire_type, is, &mut self.assetV2)?;
                },
                7 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.frozen)?;
                },
                8 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.net_usage = tmp;
                },
                41 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.acquired_delegated_frozen_balance_for_bandwidth = tmp;
                },
                42 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.delegated_frozen_balance_for_bandwidth = tmp;
                },
                9 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.create_time = tmp;
                },
                10 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.latest_opration_time = tmp;
                },
                11 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.allowance = tmp;
                },
                12 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.latest_withdraw_time = tmp;
                },
                13 => {
                    ::protobuf::rt::read_singular_proto3_bytes_into(wire_type, is, &mut self.code)?;
                },
                14 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.is_witness = tmp;
                },
                15 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.is_committee = tmp;
                },
                16 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.frozen_supply)?;
                },
                17 => {
                    ::protobuf::rt::read_singular_proto3_bytes_into(wire_type, is, &mut self.asset_issued_name)?;
                },
                57 => {
                    ::protobuf::rt::read_singular_proto3_bytes_into(wire_type, is, &mut self.asset_issued_ID)?;
                },
                18 => {
                    ::protobuf::rt::read_map_into::<::protobuf::types::ProtobufTypeString, ::protobuf::types::ProtobufTypeInt64>(wire_type, is, &mut self.latest_asset_operation_time)?;
                },
                58 => {
                    ::protobuf::rt::read_map_into::<::protobuf::types::ProtobufTypeString, ::protobuf::types::ProtobufTypeInt64>(wire_type, is, &mut self.latest_asset_operation_timeV2)?;
                },
                19 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.free_net_usage = tmp;
                },
                20 => {
                    ::protobuf::rt::read_map_into::<::protobuf::types::ProtobufTypeString, ::protobuf::types::ProtobufTypeInt64>(wire_type, is, &mut self.free_asset_net_usage)?;
                },
                59 => {
                    ::protobuf::rt::read_map_into::<::protobuf::types::ProtobufTypeString, ::protobuf::types::ProtobufTypeInt64>(wire_type, is, &mut self.free_asset_net_usageV2)?;
                },
                21 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.latest_consume_time = tmp;
                },
                22 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.latest_consume_free_time = tmp;
                },
                23 => {
                    ::protobuf::rt::read_singular_proto3_bytes_into(wire_type, is, &mut self.account_id)?;
                },
                26 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.account_resource)?;
                },
                30 => {
                    ::protobuf::rt::read_singular_proto3_bytes_into(wire_type, is, &mut self.codeHash)?;
                },
                31 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.owner_permission)?;
                },
                32 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.witness_permission)?;
                },
                33 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.active_permission)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.account_name.is_empty() {
            my_size += ::protobuf::rt::bytes_size(1, &self.account_name);
        }
        if self.field_type != AccountType::Normal {
            my_size += ::protobuf::rt::enum_size(2, self.field_type);
        }
        if !self.address.is_empty() {
            my_size += ::protobuf::rt::bytes_size(3, &self.address);
        }
        if self.balance != 0 {
            my_size += ::protobuf::rt::value_size(4, self.balance, ::protobuf::wire_format::WireTypeVarint);
        }
        for value in &self.votes {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::compute_map_size::<::protobuf::types::ProtobufTypeString, ::protobuf::types::ProtobufTypeInt64>(6, &self.asset);
        my_size += ::protobuf::rt::compute_map_size::<::protobuf::types::ProtobufTypeString, ::protobuf::types::ProtobufTypeInt64>(56, &self.assetV2);
        for value in &self.frozen {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        if self.net_usage != 0 {
            my_size += ::protobuf::rt::value_size(8, self.net_usage, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.acquired_delegated_frozen_balance_for_bandwidth != 0 {
            my_size += ::protobuf::rt::value_size(41, self.acquired_delegated_frozen_balance_for_bandwidth, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.delegated_frozen_balance_for_bandwidth != 0 {
            my_size += ::protobuf::rt::value_size(42, self.delegated_frozen_balance_for_bandwidth, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.create_time != 0 {
            my_size += ::protobuf::rt::value_size(9, self.create_time, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.latest_opration_time != 0 {
            my_size += ::protobuf::rt::value_size(10, self.latest_opration_time, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.allowance != 0 {
            my_size += ::protobuf::rt::value_size(11, self.allowance, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.latest_withdraw_time != 0 {
            my_size += ::protobuf::rt::value_size(12, self.latest_withdraw_time, ::protobuf::wire_format::WireTypeVarint);
        }
        if !self.code.is_empty() {
            my_size += ::protobuf::rt::bytes_size(13, &self.code);
        }
        if self.is_witness != false {
            my_size += 2;
        }
        if self.is_committee != false {
            my_size += 2;
        }
        for value in &self.frozen_supply {
            let len = value.compute_size();
            my_size += 2 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        if !self.asset_issued_name.is_empty() {
            my_size += ::protobuf::rt::bytes_size(17, &self.asset_issued_name);
        }
        if !self.asset_issued_ID.is_empty() {
            my_size += ::protobuf::rt::bytes_size(57, &self.asset_issued_ID);
        }
        my_size += ::protobuf::rt::compute_map_size::<::protobuf::types::ProtobufTypeString, ::protobuf::types::ProtobufTypeInt64>(18, &self.latest_asset_operation_time);
        my_size += ::protobuf::rt::compute_map_size::<::protobuf::types::ProtobufTypeString, ::protobuf::types::ProtobufTypeInt64>(58, &self.latest_asset_operation_timeV2);
        if self.free_net_usage != 0 {
            my_size += ::protobuf::rt::value_size(19, self.free_net_usage, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::compute_map_size::<::protobuf::types::ProtobufTypeString, ::protobuf::types::ProtobufTypeInt64>(20, &self.free_asset_net_usage);
        my_size += ::protobuf::rt::compute_map_size::<::protobuf::types::ProtobufTypeString, ::protobuf::types::ProtobufTypeInt64>(59, &self.free_asset_net_usageV2);
        if self.latest_consume_time != 0 {
            my_size += ::protobuf::rt::value_size(21, self.latest_consume_time, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.latest_consume_free_time != 0 {
            my_size += ::protobuf::rt::value_size(22, self.latest_consume_free_time, ::protobuf::wire_format::WireTypeVarint);
        }
        if !self.account_id.is_empty() {
            my_size += ::protobuf::rt::bytes_size(23, &self.account_id);
        }
        if let Some(ref v) = self.account_resource.as_ref() {
            let len = v.compute_size();
            my_size += 2 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if !self.codeHash.is_empty() {
            my_size += ::protobuf::rt::bytes_size(30, &self.codeHash);
        }
        if let Some(ref v) = self.owner_permission.as_ref() {
            let len = v.compute_size();
            my_size += 2 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.witness_permission.as_ref() {
            let len = v.compute_size();
            my_size += 2 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        for value in &self.active_permission {
            let len = value.compute_size();
            my_size += 2 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if !self.account_name.is_empty() {
            os.write_bytes(1, &self.account_name)?;
        }
        if self.field_type != AccountType::Normal {
            os.write_enum(2, self.field_type.value())?;
        }
        if !self.address.is_empty() {
            os.write_bytes(3, &self.address)?;
        }
        if self.balance != 0 {
            os.write_int64(4, self.balance)?;
        }
        for v in &self.votes {
            os.write_tag(5, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        ::protobuf::rt::write_map_with_cached_sizes::<::protobuf::types::ProtobufTypeString, ::protobuf::types::ProtobufTypeInt64>(6, &self.asset, os)?;
        ::protobuf::rt::write_map_with_cached_sizes::<::protobuf::types::ProtobufTypeString, ::protobuf::types::ProtobufTypeInt64>(56, &self.assetV2, os)?;
        for v in &self.frozen {
            os.write_tag(7, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        if self.net_usage != 0 {
            os.write_int64(8, self.net_usage)?;
        }
        if self.acquired_delegated_frozen_balance_for_bandwidth != 0 {
            os.write_int64(41, self.acquired_delegated_frozen_balance_for_bandwidth)?;
        }
        if self.delegated_frozen_balance_for_bandwidth != 0 {
            os.write_int64(42, self.delegated_frozen_balance_for_bandwidth)?;
        }
        if self.create_time != 0 {
            os.write_int64(9, self.create_time)?;
        }
        if self.latest_opration_time != 0 {
            os.write_int64(10, self.latest_opration_time)?;
        }
        if self.allowance != 0 {
            os.write_int64(11, self.allowance)?;
        }
        if self.latest_withdraw_time != 0 {
            os.write_int64(12, self.latest_withdraw_time)?;
        }
        if !self.code.is_empty() {
            os.write_bytes(13, &self.code)?;
        }
        if self.is_witness != false {
            os.write_bool(14, self.is_witness)?;
        }
        if self.is_committee != false {
            os.write_bool(15, self.is_committee)?;
        }
        for v in &self.frozen_supply {
            os.write_tag(16, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        if !self.asset_issued_name.is_empty() {
            os.write_bytes(17, &self.asset_issued_name)?;
        }
        if !self.asset_issued_ID.is_empty() {
            os.write_bytes(57, &self.asset_issued_ID)?;
        }
        ::protobuf::rt::write_map_with_cached_sizes::<::protobuf::types::ProtobufTypeString, ::protobuf::types::ProtobufTypeInt64>(18, &self.latest_asset_operation_time, os)?;
        ::protobuf::rt::write_map_with_cached_sizes::<::protobuf::types::ProtobufTypeString, ::protobuf::types::ProtobufTypeInt64>(58, &self.latest_asset_operation_timeV2, os)?;
        if self.free_net_usage != 0 {
            os.write_int64(19, self.free_net_usage)?;
        }
        ::protobuf::rt::write_map_with_cached_sizes::<::protobuf::types::ProtobufTypeString, ::protobuf::types::ProtobufTypeInt64>(20, &self.free_asset_net_usage, os)?;
        ::protobuf::rt::write_map_with_cached_sizes::<::protobuf::types::ProtobufTypeString, ::protobuf::types::ProtobufTypeInt64>(59, &self.free_asset_net_usageV2, os)?;
        if self.latest_consume_time != 0 {
            os.write_int64(21, self.latest_consume_time)?;
        }
        if self.latest_consume_free_time != 0 {
            os.write_int64(22, self.latest_consume_free_time)?;
        }
        if !self.account_id.is_empty() {
            os.write_bytes(23, &self.account_id)?;
        }
        if let Some(ref v) = self.account_resource.as_ref() {
            os.write_tag(26, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if !self.codeHash.is_empty() {
            os.write_bytes(30, &self.codeHash)?;
        }
        if let Some(ref v) = self.owner_permission.as_ref() {
            os.write_tag(31, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.witness_permission.as_ref() {
            os.write_tag(32, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        for v in &self.active_permission {
            os.write_tag(33, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> Account {
        Account::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                    "account_name",
                    |m: &Account| { &m.account_name },
                    |m: &mut Account| { &mut m.account_name },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeEnum<AccountType>>(
                    "type",
                    |m: &Account| { &m.field_type },
                    |m: &mut Account| { &mut m.field_type },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                    "address",
                    |m: &Account| { &m.address },
                    |m: &mut Account| { &mut m.address },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                    "balance",
                    |m: &Account| { &m.balance },
                    |m: &mut Account| { &mut m.balance },
                ));
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Vote>>(
                    "votes",
                    |m: &Account| { &m.votes },
                    |m: &mut Account| { &mut m.votes },
                ));
                fields.push(::protobuf::reflect::accessor::make_map_accessor::<_, ::protobuf::types::ProtobufTypeString, ::protobuf::types::ProtobufTypeInt64>(
                    "asset",
                    |m: &Account| { &m.asset },
                    |m: &mut Account| { &mut m.asset },
                ));
                fields.push(::protobuf::reflect::accessor::make_map_accessor::<_, ::protobuf::types::ProtobufTypeString, ::protobuf::types::ProtobufTypeInt64>(
                    "assetV2",
                    |m: &Account| { &m.assetV2 },
                    |m: &mut Account| { &mut m.assetV2 },
                ));
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Account_Frozen>>(
                    "frozen",
                    |m: &Account| { &m.frozen },
                    |m: &mut Account| { &mut m.frozen },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                    "net_usage",
                    |m: &Account| { &m.net_usage },
                    |m: &mut Account| { &mut m.net_usage },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                    "acquired_delegated_frozen_balance_for_bandwidth",
                    |m: &Account| { &m.acquired_delegated_frozen_balance_for_bandwidth },
                    |m: &mut Account| { &mut m.acquired_delegated_frozen_balance_for_bandwidth },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                    "delegated_frozen_balance_for_bandwidth",
                    |m: &Account| { &m.delegated_frozen_balance_for_bandwidth },
                    |m: &mut Account| { &mut m.delegated_frozen_balance_for_bandwidth },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                    "create_time",
                    |m: &Account| { &m.create_time },
                    |m: &mut Account| { &mut m.create_time },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                    "latest_opration_time",
                    |m: &Account| { &m.latest_opration_time },
                    |m: &mut Account| { &mut m.latest_opration_time },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                    "allowance",
                    |m: &Account| { &m.allowance },
                    |m: &mut Account| { &mut m.allowance },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                    "latest_withdraw_time",
                    |m: &Account| { &m.latest_withdraw_time },
                    |m: &mut Account| { &mut m.latest_withdraw_time },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                    "code",
                    |m: &Account| { &m.code },
                    |m: &mut Account| { &mut m.code },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                    "is_witness",
                    |m: &Account| { &m.is_witness },
                    |m: &mut Account| { &mut m.is_witness },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                    "is_committee",
                    |m: &Account| { &m.is_committee },
                    |m: &mut Account| { &mut m.is_committee },
                ));
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Account_Frozen>>(
                    "frozen_supply",
                    |m: &Account| { &m.frozen_supply },
                    |m: &mut Account| { &mut m.frozen_supply },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                    "asset_issued_name",
                    |m: &Account| { &m.asset_issued_name },
                    |m: &mut Account| { &mut m.asset_issued_name },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                    "asset_issued_ID",
                    |m: &Account| { &m.asset_issued_ID },
                    |m: &mut Account| { &mut m.asset_issued_ID },
                ));
                fields.push(::protobuf::reflect::accessor::make_map_accessor::<_, ::protobuf::types::ProtobufTypeString, ::protobuf::types::ProtobufTypeInt64>(
                    "latest_asset_operation_time",
                    |m: &Account| { &m.latest_asset_operation_time },
                    |m: &mut Account| { &mut m.latest_asset_operation_time },
                ));
                fields.push(::protobuf::reflect::accessor::make_map_accessor::<_, ::protobuf::types::ProtobufTypeString, ::protobuf::types::ProtobufTypeInt64>(
                    "latest_asset_operation_timeV2",
                    |m: &Account| { &m.latest_asset_operation_timeV2 },
                    |m: &mut Account| { &mut m.latest_asset_operation_timeV2 },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                    "free_net_usage",
                    |m: &Account| { &m.free_net_usage },
                    |m: &mut Account| { &mut m.free_net_usage },
                ));
                fields.push(::protobuf::reflect::accessor::make_map_accessor::<_, ::protobuf::types::ProtobufTypeString, ::protobuf::types::ProtobufTypeInt64>(
                    "free_asset_net_usage",
                    |m: &Account| { &m.free_asset_net_usage },
                    |m: &mut Account| { &mut m.free_asset_net_usage },
                ));
                fields.push(::protobuf::reflect::accessor::make_map_accessor::<_, ::protobuf::types::ProtobufTypeString, ::protobuf::types::ProtobufTypeInt64>(
                    "free_asset_net_usageV2",
                    |m: &Account| { &m.free_asset_net_usageV2 },
                    |m: &mut Account| { &mut m.free_asset_net_usageV2 },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                    "latest_consume_time",
                    |m: &Account| { &m.latest_consume_time },
                    |m: &mut Account| { &mut m.latest_consume_time },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                    "latest_consume_free_time",
                    |m: &Account| { &m.latest_consume_free_time },
                    |m: &mut Account| { &mut m.latest_consume_free_time },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                    "account_id",
                    |m: &Account| { &m.account_id },
                    |m: &mut Account| { &mut m.account_id },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Account_AccountResource>>(
                    "account_resource",
                    |m: &Account| { &m.account_resource },
                    |m: &mut Account| { &mut m.account_resource },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                    "codeHash",
                    |m: &Account| { &m.codeHash },
                    |m: &mut Account| { &mut m.codeHash },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Permission>>(
                    "owner_permission",
                    |m: &Account| { &m.owner_permission },
                    |m: &mut Account| { &mut m.owner_permission },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Permission>>(
                    "witness_permission",
                    |m: &Account| { &m.witness_permission },
                    |m: &mut Account| { &mut m.witness_permission },
                ));
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Permission>>(
                    "active_permission",
                    |m: &Account| { &m.active_permission },
                    |m: &mut Account| { &mut m.active_permission },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<Account>(
                    "Account",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static Account {
        static mut instance: ::protobuf::lazy::Lazy<Account> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const Account,
        };
        unsafe {
            instance.get(Account::new)
        }
    }
}

impl ::protobuf::Clear for Account {
    fn clear(&mut self) {
        self.account_name.clear();
        self.field_type = AccountType::Normal;
        self.address.clear();
        self.balance = 0;
        self.votes.clear();
        self.asset.clear();
        self.assetV2.clear();
        self.frozen.clear();
        self.net_usage = 0;
        self.acquired_delegated_frozen_balance_for_bandwidth = 0;
        self.delegated_frozen_balance_for_bandwidth = 0;
        self.create_time = 0;
        self.latest_opration_time = 0;
        self.allowance = 0;
        self.latest_withdraw_time = 0;
        self.code.clear();
        self.is_witness = false;
        self.is_committee = false;
        self.frozen_supply.clear();
        self.asset_issued_name.clear();
        self.asset_issued_ID.clear();
        self.latest_asset_operation_time.clear();
        self.latest_asset_operation_timeV2.clear();
        self.free_net_usage = 0;
        self.free_asset_net_usage.clear();
        self.free_asset_net_usageV2.clear();
        self.latest_consume_time = 0;
        self.latest_consume_free_time = 0;
        self.account_id.clear();
        self.account_resource.clear();
        self.codeHash.clear();
        self.owner_permission.clear();
        self.witness_permission.clear();
        self.active_permission.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for Account {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Account {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct Account_Frozen {
    // message fields
    pub frozen_balance: i64,
    pub expire_time: i64,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a Account_Frozen {
    fn default() -> &'a Account_Frozen {
        <Account_Frozen as ::protobuf::Message>::default_instance()
    }
}

impl Account_Frozen {
    pub fn new() -> Account_Frozen {
        ::std::default::Default::default()
    }

    // int64 frozen_balance = 1;


    pub fn get_frozen_balance(&self) -> i64 {
        self.frozen_balance
    }
    pub fn clear_frozen_balance(&mut self) {
        self.frozen_balance = 0;
    }

    // Param is passed by value, moved
    pub fn set_frozen_balance(&mut self, v: i64) {
        self.frozen_balance = v;
    }

    // int64 expire_time = 2;


    pub fn get_expire_time(&self) -> i64 {
        self.expire_time
    }
    pub fn clear_expire_time(&mut self) {
        self.expire_time = 0;
    }

    // Param is passed by value, moved
    pub fn set_expire_time(&mut self, v: i64) {
        self.expire_time = v;
    }
}

impl ::protobuf::Message for Account_Frozen {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.frozen_balance = tmp;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.expire_time = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.frozen_balance != 0 {
            my_size += ::protobuf::rt::value_size(1, self.frozen_balance, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.expire_time != 0 {
            my_size += ::protobuf::rt::value_size(2, self.expire_time, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if self.frozen_balance != 0 {
            os.write_int64(1, self.frozen_balance)?;
        }
        if self.expire_time != 0 {
            os.write_int64(2, self.expire_time)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> Account_Frozen {
        Account_Frozen::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                    "frozen_balance",
                    |m: &Account_Frozen| { &m.frozen_balance },
                    |m: &mut Account_Frozen| { &mut m.frozen_balance },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                    "expire_time",
                    |m: &Account_Frozen| { &m.expire_time },
                    |m: &mut Account_Frozen| { &mut m.expire_time },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<Account_Frozen>(
                    "Account_Frozen",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static Account_Frozen {
        static mut instance: ::protobuf::lazy::Lazy<Account_Frozen> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const Account_Frozen,
        };
        unsafe {
            instance.get(Account_Frozen::new)
        }
    }
}

impl ::protobuf::Clear for Account_Frozen {
    fn clear(&mut self) {
        self.frozen_balance = 0;
        self.expire_time = 0;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for Account_Frozen {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Account_Frozen {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct Account_AccountResource {
    // message fields
    pub energy_usage: i64,
    pub frozen_balance_for_energy: ::protobuf::SingularPtrField<Account_Frozen>,
    pub latest_consume_time_for_energy: i64,
    pub acquired_delegated_frozen_balance_for_energy: i64,
    pub delegated_frozen_balance_for_energy: i64,
    pub storage_limit: i64,
    pub storage_usage: i64,
    pub latest_exchange_storage_time: i64,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a Account_AccountResource {
    fn default() -> &'a Account_AccountResource {
        <Account_AccountResource as ::protobuf::Message>::default_instance()
    }
}

impl Account_AccountResource {
    pub fn new() -> Account_AccountResource {
        ::std::default::Default::default()
    }

    // int64 energy_usage = 1;


    pub fn get_energy_usage(&self) -> i64 {
        self.energy_usage
    }
    pub fn clear_energy_usage(&mut self) {
        self.energy_usage = 0;
    }

    // Param is passed by value, moved
    pub fn set_energy_usage(&mut self, v: i64) {
        self.energy_usage = v;
    }

    // .protocol.Account.Frozen frozen_balance_for_energy = 2;


    pub fn get_frozen_balance_for_energy(&self) -> &Account_Frozen {
        self.frozen_balance_for_energy.as_ref().unwrap_or_else(|| Account_Frozen::default_instance())
    }
    pub fn clear_frozen_balance_for_energy(&mut self) {
        self.frozen_balance_for_energy.clear();
    }

    pub fn has_frozen_balance_for_energy(&self) -> bool {
        self.frozen_balance_for_energy.is_some()
    }

    // Param is passed by value, moved
    pub fn set_frozen_balance_for_energy(&mut self, v: Account_Frozen) {
        self.frozen_balance_for_energy = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_frozen_balance_for_energy(&mut self) -> &mut Account_Frozen {
        if self.frozen_balance_for_energy.is_none() {
            self.frozen_balance_for_energy.set_default();
        }
        self.frozen_balance_for_energy.as_mut().unwrap()
    }

    // Take field
    pub fn take_frozen_balance_for_energy(&mut self) -> Account_Frozen {
        self.frozen_balance_for_energy.take().unwrap_or_else(|| Account_Frozen::new())
    }

    // int64 latest_consume_time_for_energy = 3;


    pub fn get_latest_consume_time_for_energy(&self) -> i64 {
        self.latest_consume_time_for_energy
    }
    pub fn clear_latest_consume_time_for_energy(&mut self) {
        self.latest_consume_time_for_energy = 0;
    }

    // Param is passed by value, moved
    pub fn set_latest_consume_time_for_energy(&mut self, v: i64) {
        self.latest_consume_time_for_energy = v;
    }

    // int64 acquired_delegated_frozen_balance_for_energy = 4;


    pub fn get_acquired_delegated_frozen_balance_for_energy(&self) -> i64 {
        self.acquired_delegated_frozen_balance_for_energy
    }
    pub fn clear_acquired_delegated_frozen_balance_for_energy(&mut self) {
        self.acquired_delegated_frozen_balance_for_energy = 0;
    }

    // Param is passed by value, moved
    pub fn set_acquired_delegated_frozen_balance_for_energy(&mut self, v: i64) {
        self.acquired_delegated_frozen_balance_for_energy = v;
    }

    // int64 delegated_frozen_balance_for_energy = 5;


    pub fn get_delegated_frozen_balance_for_energy(&self) -> i64 {
        self.delegated_frozen_balance_for_energy
    }
    pub fn clear_delegated_frozen_balance_for_energy(&mut self) {
        self.delegated_frozen_balance_for_energy = 0;
    }

    // Param is passed by value, moved
    pub fn set_delegated_frozen_balance_for_energy(&mut self, v: i64) {
        self.delegated_frozen_balance_for_energy = v;
    }

    // int64 storage_limit = 6;


    pub fn get_storage_limit(&self) -> i64 {
        self.storage_limit
    }
    pub fn clear_storage_limit(&mut self) {
        self.storage_limit = 0;
    }

    // Param is passed by value, moved
    pub fn set_storage_limit(&mut self, v: i64) {
        self.storage_limit = v;
    }

    // int64 storage_usage = 7;


    pub fn get_storage_usage(&self) -> i64 {
        self.storage_usage
    }
    pub fn clear_storage_usage(&mut self) {
        self.storage_usage = 0;
    }

    // Param is passed by value, moved
    pub fn set_storage_usage(&mut self, v: i64) {
        self.storage_usage = v;
    }

    // int64 latest_exchange_storage_time = 8;


    pub fn get_latest_exchange_storage_time(&self) -> i64 {
        self.latest_exchange_storage_time
    }
    pub fn clear_latest_exchange_storage_time(&mut self) {
        self.latest_exchange_storage_time = 0;
    }

    // Param is passed by value, moved
    pub fn set_latest_exchange_storage_time(&mut self, v: i64) {
        self.latest_exchange_storage_time = v;
    }
}

impl ::protobuf::Message for Account_AccountResource {
    fn is_initialized(&self) -> bool {
        for v in &self.frozen_balance_for_energy {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.energy_usage = tmp;
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.frozen_balance_for_energy)?;
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.latest_consume_time_for_energy = tmp;
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.acquired_delegated_frozen_balance_for_energy = tmp;
                },
                5 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.delegated_frozen_balance_for_energy = tmp;
                },
                6 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.storage_limit = tmp;
                },
                7 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.storage_usage = tmp;
                },
                8 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.latest_exchange_storage_time = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.energy_usage != 0 {
            my_size += ::protobuf::rt::value_size(1, self.energy_usage, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(ref v) = self.frozen_balance_for_energy.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if self.latest_consume_time_for_energy != 0 {
            my_size += ::protobuf::rt::value_size(3, self.latest_consume_time_for_energy, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.acquired_delegated_frozen_balance_for_energy != 0 {
            my_size += ::protobuf::rt::value_size(4, self.acquired_delegated_frozen_balance_for_energy, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.delegated_frozen_balance_for_energy != 0 {
            my_size += ::protobuf::rt::value_size(5, self.delegated_frozen_balance_for_energy, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.storage_limit != 0 {
            my_size += ::protobuf::rt::value_size(6, self.storage_limit, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.storage_usage != 0 {
            my_size += ::protobuf::rt::value_size(7, self.storage_usage, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.latest_exchange_storage_time != 0 {
            my_size += ::protobuf::rt::value_size(8, self.latest_exchange_storage_time, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if self.energy_usage != 0 {
            os.write_int64(1, self.energy_usage)?;
        }
        if let Some(ref v) = self.frozen_balance_for_energy.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if self.latest_consume_time_for_energy != 0 {
            os.write_int64(3, self.latest_consume_time_for_energy)?;
        }
        if self.acquired_delegated_frozen_balance_for_energy != 0 {
            os.write_int64(4, self.acquired_delegated_frozen_balance_for_energy)?;
        }
        if self.delegated_frozen_balance_for_energy != 0 {
            os.write_int64(5, self.delegated_frozen_balance_for_energy)?;
        }
        if self.storage_limit != 0 {
            os.write_int64(6, self.storage_limit)?;
        }
        if self.storage_usage != 0 {
            os.write_int64(7, self.storage_usage)?;
        }
        if self.latest_exchange_storage_time != 0 {
            os.write_int64(8, self.latest_exchange_storage_time)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> Account_AccountResource {
        Account_AccountResource::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                    "energy_usage",
                    |m: &Account_AccountResource| { &m.energy_usage },
                    |m: &mut Account_AccountResource| { &mut m.energy_usage },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Account_Frozen>>(
                    "frozen_balance_for_energy",
                    |m: &Account_AccountResource| { &m.frozen_balance_for_energy },
                    |m: &mut Account_AccountResource| { &mut m.frozen_balance_for_energy },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                    "latest_consume_time_for_energy",
                    |m: &Account_AccountResource| { &m.latest_consume_time_for_energy },
                    |m: &mut Account_AccountResource| { &mut m.latest_consume_time_for_energy },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                    "acquired_delegated_frozen_balance_for_energy",
                    |m: &Account_AccountResource| { &m.acquired_delegated_frozen_balance_for_energy },
                    |m: &mut Account_AccountResource| { &mut m.acquired_delegated_frozen_balance_for_energy },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                    "delegated_frozen_balance_for_energy",
                    |m: &Account_AccountResource| { &m.delegated_frozen_balance_for_energy },
                    |m: &mut Account_AccountResource| { &mut m.delegated_frozen_balance_for_energy },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                    "storage_limit",
                    |m: &Account_AccountResource| { &m.storage_limit },
                    |m: &mut Account_AccountResource| { &mut m.storage_limit },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                    "storage_usage",
                    |m: &Account_AccountResource| { &m.storage_usage },
                    |m: &mut Account_AccountResource| { &mut m.storage_usage },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                    "latest_exchange_storage_time",
                    |m: &Account_AccountResource| { &m.latest_exchange_storage_time },
                    |m: &mut Account_AccountResource| { &mut m.latest_exchange_storage_time },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<Account_AccountResource>(
                    "Account_AccountResource",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static Account_AccountResource {
        static mut instance: ::protobuf::lazy::Lazy<Account_AccountResource> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const Account_AccountResource,
        };
        unsafe {
            instance.get(Account_AccountResource::new)
        }
    }
}

impl ::protobuf::Clear for Account_AccountResource {
    fn clear(&mut self) {
        self.energy_usage = 0;
        self.frozen_balance_for_energy.clear();
        self.latest_consume_time_for_energy = 0;
        self.acquired_delegated_frozen_balance_for_energy = 0;
        self.delegated_frozen_balance_for_energy = 0;
        self.storage_limit = 0;
        self.storage_usage = 0;
        self.latest_exchange_storage_time = 0;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for Account_AccountResource {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Account_AccountResource {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct Key {
    // message fields
    pub address: ::std::vec::Vec<u8>,
    pub weight: i64,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a Key {
    fn default() -> &'a Key {
        <Key as ::protobuf::Message>::default_instance()
    }
}

impl Key {
    pub fn new() -> Key {
        ::std::default::Default::default()
    }

    // bytes address = 1;


    pub fn get_address(&self) -> &[u8] {
        &self.address
    }
    pub fn clear_address(&mut self) {
        self.address.clear();
    }

    // Param is passed by value, moved
    pub fn set_address(&mut self, v: ::std::vec::Vec<u8>) {
        self.address = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_address(&mut self) -> &mut ::std::vec::Vec<u8> {
        &mut self.address
    }

    // Take field
    pub fn take_address(&mut self) -> ::std::vec::Vec<u8> {
        ::std::mem::replace(&mut self.address, ::std::vec::Vec::new())
    }

    // int64 weight = 2;


    pub fn get_weight(&self) -> i64 {
        self.weight
    }
    pub fn clear_weight(&mut self) {
        self.weight = 0;
    }

    // Param is passed by value, moved
    pub fn set_weight(&mut self, v: i64) {
        self.weight = v;
    }
}

impl ::protobuf::Message for Key {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_bytes_into(wire_type, is, &mut self.address)?;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.weight = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.address.is_empty() {
            my_size += ::protobuf::rt::bytes_size(1, &self.address);
        }
        if self.weight != 0 {
            my_size += ::protobuf::rt::value_size(2, self.weight, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if !self.address.is_empty() {
            os.write_bytes(1, &self.address)?;
        }
        if self.weight != 0 {
            os.write_int64(2, self.weight)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> Key {
        Key::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                    "address",
                    |m: &Key| { &m.address },
                    |m: &mut Key| { &mut m.address },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                    "weight",
                    |m: &Key| { &m.weight },
                    |m: &mut Key| { &mut m.weight },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<Key>(
                    "Key",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static Key {
        static mut instance: ::protobuf::lazy::Lazy<Key> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const Key,
        };
        unsafe {
            instance.get(Key::new)
        }
    }
}

impl ::protobuf::Clear for Key {
    fn clear(&mut self) {
        self.address.clear();
        self.weight = 0;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for Key {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Key {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct DelegatedResource {
    // message fields
    pub from: ::std::vec::Vec<u8>,
    pub to: ::std::vec::Vec<u8>,
    pub frozen_balance_for_bandwidth: i64,
    pub frozen_balance_for_energy: i64,
    pub expire_time_for_bandwidth: i64,
    pub expire_time_for_energy: i64,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a DelegatedResource {
    fn default() -> &'a DelegatedResource {
        <DelegatedResource as ::protobuf::Message>::default_instance()
    }
}

impl DelegatedResource {
    pub fn new() -> DelegatedResource {
        ::std::default::Default::default()
    }

    // bytes from = 1;


    pub fn get_from(&self) -> &[u8] {
        &self.from
    }
    pub fn clear_from(&mut self) {
        self.from.clear();
    }

    // Param is passed by value, moved
    pub fn set_from(&mut self, v: ::std::vec::Vec<u8>) {
        self.from = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_from(&mut self) -> &mut ::std::vec::Vec<u8> {
        &mut self.from
    }

    // Take field
    pub fn take_from(&mut self) -> ::std::vec::Vec<u8> {
        ::std::mem::replace(&mut self.from, ::std::vec::Vec::new())
    }

    // bytes to = 2;


    pub fn get_to(&self) -> &[u8] {
        &self.to
    }
    pub fn clear_to(&mut self) {
        self.to.clear();
    }

    // Param is passed by value, moved
    pub fn set_to(&mut self, v: ::std::vec::Vec<u8>) {
        self.to = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_to(&mut self) -> &mut ::std::vec::Vec<u8> {
        &mut self.to
    }

    // Take field
    pub fn take_to(&mut self) -> ::std::vec::Vec<u8> {
        ::std::mem::replace(&mut self.to, ::std::vec::Vec::new())
    }

    // int64 frozen_balance_for_bandwidth = 3;


    pub fn get_frozen_balance_for_bandwidth(&self) -> i64 {
        self.frozen_balance_for_bandwidth
    }
    pub fn clear_frozen_balance_for_bandwidth(&mut self) {
        self.frozen_balance_for_bandwidth = 0;
    }

    // Param is passed by value, moved
    pub fn set_frozen_balance_for_bandwidth(&mut self, v: i64) {
        self.frozen_balance_for_bandwidth = v;
    }

    // int64 frozen_balance_for_energy = 4;


    pub fn get_frozen_balance_for_energy(&self) -> i64 {
        self.frozen_balance_for_energy
    }
    pub fn clear_frozen_balance_for_energy(&mut self) {
        self.frozen_balance_for_energy = 0;
    }

    // Param is passed by value, moved
    pub fn set_frozen_balance_for_energy(&mut self, v: i64) {
        self.frozen_balance_for_energy = v;
    }

    // int64 expire_time_for_bandwidth = 5;


    pub fn get_expire_time_for_bandwidth(&self) -> i64 {
        self.expire_time_for_bandwidth
    }
    pub fn clear_expire_time_for_bandwidth(&mut self) {
        self.expire_time_for_bandwidth = 0;
    }

    // Param is passed by value, moved
    pub fn set_expire_time_for_bandwidth(&mut self, v: i64) {
        self.expire_time_for_bandwidth = v;
    }

    // int64 expire_time_for_energy = 6;


    pub fn get_expire_time_for_energy(&self) -> i64 {
        self.expire_time_for_energy
    }
    pub fn clear_expire_time_for_energy(&mut self) {
        self.expire_time_for_energy = 0;
    }

    // Param is passed by value, moved
    pub fn set_expire_time_for_energy(&mut self, v: i64) {
        self.expire_time_for_energy = v;
    }
}

impl ::protobuf::Message for DelegatedResource {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_bytes_into(wire_type, is, &mut self.from)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_bytes_into(wire_type, is, &mut self.to)?;
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.frozen_balance_for_bandwidth = tmp;
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.frozen_balance_for_energy = tmp;
                },
                5 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.expire_time_for_bandwidth = tmp;
                },
                6 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.expire_time_for_energy = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.from.is_empty() {
            my_size += ::protobuf::rt::bytes_size(1, &self.from);
        }
        if !self.to.is_empty() {
            my_size += ::protobuf::rt::bytes_size(2, &self.to);
        }
        if self.frozen_balance_for_bandwidth != 0 {
            my_size += ::protobuf::rt::value_size(3, self.frozen_balance_for_bandwidth, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.frozen_balance_for_energy != 0 {
            my_size += ::protobuf::rt::value_size(4, self.frozen_balance_for_energy, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.expire_time_for_bandwidth != 0 {
            my_size += ::protobuf::rt::value_size(5, self.expire_time_for_bandwidth, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.expire_time_for_energy != 0 {
            my_size += ::protobuf::rt::value_size(6, self.expire_time_for_energy, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if !self.from.is_empty() {
            os.write_bytes(1, &self.from)?;
        }
        if !self.to.is_empty() {
            os.write_bytes(2, &self.to)?;
        }
        if self.frozen_balance_for_bandwidth != 0 {
            os.write_int64(3, self.frozen_balance_for_bandwidth)?;
        }
        if self.frozen_balance_for_energy != 0 {
            os.write_int64(4, self.frozen_balance_for_energy)?;
        }
        if self.expire_time_for_bandwidth != 0 {
            os.write_int64(5, self.expire_time_for_bandwidth)?;
        }
        if self.expire_time_for_energy != 0 {
            os.write_int64(6, self.expire_time_for_energy)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> DelegatedResource {
        DelegatedResource::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                    "from",
                    |m: &DelegatedResource| { &m.from },
                    |m: &mut DelegatedResource| { &mut m.from },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                    "to",
                    |m: &DelegatedResource| { &m.to },
                    |m: &mut DelegatedResource| { &mut m.to },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                    "frozen_balance_for_bandwidth",
                    |m: &DelegatedResource| { &m.frozen_balance_for_bandwidth },
                    |m: &mut DelegatedResource| { &mut m.frozen_balance_for_bandwidth },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                    "frozen_balance_for_energy",
                    |m: &DelegatedResource| { &m.frozen_balance_for_energy },
                    |m: &mut DelegatedResource| { &mut m.frozen_balance_for_energy },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                    "expire_time_for_bandwidth",
                    |m: &DelegatedResource| { &m.expire_time_for_bandwidth },
                    |m: &mut DelegatedResource| { &mut m.expire_time_for_bandwidth },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                    "expire_time_for_energy",
                    |m: &DelegatedResource| { &m.expire_time_for_energy },
                    |m: &mut DelegatedResource| { &mut m.expire_time_for_energy },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<DelegatedResource>(
                    "DelegatedResource",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static DelegatedResource {
        static mut instance: ::protobuf::lazy::Lazy<DelegatedResource> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const DelegatedResource,
        };
        unsafe {
            instance.get(DelegatedResource::new)
        }
    }
}

impl ::protobuf::Clear for DelegatedResource {
    fn clear(&mut self) {
        self.from.clear();
        self.to.clear();
        self.frozen_balance_for_bandwidth = 0;
        self.frozen_balance_for_energy = 0;
        self.expire_time_for_bandwidth = 0;
        self.expire_time_for_energy = 0;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for DelegatedResource {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for DelegatedResource {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct authority {
    // message fields
    pub account: ::protobuf::SingularPtrField<AccountId>,
    pub permission_name: ::std::vec::Vec<u8>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a authority {
    fn default() -> &'a authority {
        <authority as ::protobuf::Message>::default_instance()
    }
}

impl authority {
    pub fn new() -> authority {
        ::std::default::Default::default()
    }

    // .protocol.AccountId account = 1;


    pub fn get_account(&self) -> &AccountId {
        self.account.as_ref().unwrap_or_else(|| AccountId::default_instance())
    }
    pub fn clear_account(&mut self) {
        self.account.clear();
    }

    pub fn has_account(&self) -> bool {
        self.account.is_some()
    }

    // Param is passed by value, moved
    pub fn set_account(&mut self, v: AccountId) {
        self.account = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_account(&mut self) -> &mut AccountId {
        if self.account.is_none() {
            self.account.set_default();
        }
        self.account.as_mut().unwrap()
    }

    // Take field
    pub fn take_account(&mut self) -> AccountId {
        self.account.take().unwrap_or_else(|| AccountId::new())
    }

    // bytes permission_name = 2;


    pub fn get_permission_name(&self) -> &[u8] {
        &self.permission_name
    }
    pub fn clear_permission_name(&mut self) {
        self.permission_name.clear();
    }

    // Param is passed by value, moved
    pub fn set_permission_name(&mut self, v: ::std::vec::Vec<u8>) {
        self.permission_name = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_permission_name(&mut self) -> &mut ::std::vec::Vec<u8> {
        &mut self.permission_name
    }

    // Take field
    pub fn take_permission_name(&mut self) -> ::std::vec::Vec<u8> {
        ::std::mem::replace(&mut self.permission_name, ::std::vec::Vec::new())
    }
}

impl ::protobuf::Message for authority {
    fn is_initialized(&self) -> bool {
        for v in &self.account {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.account)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_bytes_into(wire_type, is, &mut self.permission_name)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.account.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if !self.permission_name.is_empty() {
            my_size += ::protobuf::rt::bytes_size(2, &self.permission_name);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.account.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if !self.permission_name.is_empty() {
            os.write_bytes(2, &self.permission_name)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> authority {
        authority::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<AccountId>>(
                    "account",
                    |m: &authority| { &m.account },
                    |m: &mut authority| { &mut m.account },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                    "permission_name",
                    |m: &authority| { &m.permission_name },
                    |m: &mut authority| { &mut m.permission_name },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<authority>(
                    "authority",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static authority {
        static mut instance: ::protobuf::lazy::Lazy<authority> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const authority,
        };
        unsafe {
            instance.get(authority::new)
        }
    }
}

impl ::protobuf::Clear for authority {
    fn clear(&mut self) {
        self.account.clear();
        self.permission_name.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for authority {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for authority {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct Permission {
    // message fields
    pub field_type: Permission_PermissionType,
    pub id: i32,
    pub permission_name: ::std::string::String,
    pub threshold: i64,
    pub parent_id: i32,
    pub operations: ::std::vec::Vec<u8>,
    pub keys: ::protobuf::RepeatedField<Key>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a Permission {
    fn default() -> &'a Permission {
        <Permission as ::protobuf::Message>::default_instance()
    }
}

impl Permission {
    pub fn new() -> Permission {
        ::std::default::Default::default()
    }

    // .protocol.Permission.PermissionType type = 1;


    pub fn get_field_type(&self) -> Permission_PermissionType {
        self.field_type
    }
    pub fn clear_field_type(&mut self) {
        self.field_type = Permission_PermissionType::Owner;
    }

    // Param is passed by value, moved
    pub fn set_field_type(&mut self, v: Permission_PermissionType) {
        self.field_type = v;
    }

    // int32 id = 2;


    pub fn get_id(&self) -> i32 {
        self.id
    }
    pub fn clear_id(&mut self) {
        self.id = 0;
    }

    // Param is passed by value, moved
    pub fn set_id(&mut self, v: i32) {
        self.id = v;
    }

    // string permission_name = 3;


    pub fn get_permission_name(&self) -> &str {
        &self.permission_name
    }
    pub fn clear_permission_name(&mut self) {
        self.permission_name.clear();
    }

    // Param is passed by value, moved
    pub fn set_permission_name(&mut self, v: ::std::string::String) {
        self.permission_name = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_permission_name(&mut self) -> &mut ::std::string::String {
        &mut self.permission_name
    }

    // Take field
    pub fn take_permission_name(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.permission_name, ::std::string::String::new())
    }

    // int64 threshold = 4;


    pub fn get_threshold(&self) -> i64 {
        self.threshold
    }
    pub fn clear_threshold(&mut self) {
        self.threshold = 0;
    }

    // Param is passed by value, moved
    pub fn set_threshold(&mut self, v: i64) {
        self.threshold = v;
    }

    // int32 parent_id = 5;


    pub fn get_parent_id(&self) -> i32 {
        self.parent_id
    }
    pub fn clear_parent_id(&mut self) {
        self.parent_id = 0;
    }

    // Param is passed by value, moved
    pub fn set_parent_id(&mut self, v: i32) {
        self.parent_id = v;
    }

    // bytes operations = 6;


    pub fn get_operations(&self) -> &[u8] {
        &self.operations
    }
    pub fn clear_operations(&mut self) {
        self.operations.clear();
    }

    // Param is passed by value, moved
    pub fn set_operations(&mut self, v: ::std::vec::Vec<u8>) {
        self.operations = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_operations(&mut self) -> &mut ::std::vec::Vec<u8> {
        &mut self.operations
    }

    // Take field
    pub fn take_operations(&mut self) -> ::std::vec::Vec<u8> {
        ::std::mem::replace(&mut self.operations, ::std::vec::Vec::new())
    }

    // repeated .protocol.Key keys = 7;


    pub fn get_keys(&self) -> &[Key] {
        &self.keys
    }
    pub fn clear_keys(&mut self) {
        self.keys.clear();
    }

    // Param is passed by value, moved
    pub fn set_keys(&mut self, v: ::protobuf::RepeatedField<Key>) {
        self.keys = v;
    }

    // Mutable pointer to the field.
    pub fn mut_keys(&mut self) -> &mut ::protobuf::RepeatedField<Key> {
        &mut self.keys
    }

    // Take field
    pub fn take_keys(&mut self) -> ::protobuf::RepeatedField<Key> {
        ::std::mem::replace(&mut self.keys, ::protobuf::RepeatedField::new())
    }
}

impl ::protobuf::Message for Permission {
    fn is_initialized(&self) -> bool {
        for v in &self.keys {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_proto3_enum_with_unknown_fields_into(wire_type, is, &mut self.field_type, 1, &mut self.unknown_fields)?
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.id = tmp;
                },
                3 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.permission_name)?;
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.threshold = tmp;
                },
                5 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.parent_id = tmp;
                },
                6 => {
                    ::protobuf::rt::read_singular_proto3_bytes_into(wire_type, is, &mut self.operations)?;
                },
                7 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.keys)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.field_type != Permission_PermissionType::Owner {
            my_size += ::protobuf::rt::enum_size(1, self.field_type);
        }
        if self.id != 0 {
            my_size += ::protobuf::rt::value_size(2, self.id, ::protobuf::wire_format::WireTypeVarint);
        }
        if !self.permission_name.is_empty() {
            my_size += ::protobuf::rt::string_size(3, &self.permission_name);
        }
        if self.threshold != 0 {
            my_size += ::protobuf::rt::value_size(4, self.threshold, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.parent_id != 0 {
            my_size += ::protobuf::rt::value_size(5, self.parent_id, ::protobuf::wire_format::WireTypeVarint);
        }
        if !self.operations.is_empty() {
            my_size += ::protobuf::rt::bytes_size(6, &self.operations);
        }
        for value in &self.keys {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if self.field_type != Permission_PermissionType::Owner {
            os.write_enum(1, self.field_type.value())?;
        }
        if self.id != 0 {
            os.write_int32(2, self.id)?;
        }
        if !self.permission_name.is_empty() {
            os.write_string(3, &self.permission_name)?;
        }
        if self.threshold != 0 {
            os.write_int64(4, self.threshold)?;
        }
        if self.parent_id != 0 {
            os.write_int32(5, self.parent_id)?;
        }
        if !self.operations.is_empty() {
            os.write_bytes(6, &self.operations)?;
        }
        for v in &self.keys {
            os.write_tag(7, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> Permission {
        Permission::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeEnum<Permission_PermissionType>>(
                    "type",
                    |m: &Permission| { &m.field_type },
                    |m: &mut Permission| { &mut m.field_type },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                    "id",
                    |m: &Permission| { &m.id },
                    |m: &mut Permission| { &mut m.id },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "permission_name",
                    |m: &Permission| { &m.permission_name },
                    |m: &mut Permission| { &mut m.permission_name },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                    "threshold",
                    |m: &Permission| { &m.threshold },
                    |m: &mut Permission| { &mut m.threshold },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                    "parent_id",
                    |m: &Permission| { &m.parent_id },
                    |m: &mut Permission| { &mut m.parent_id },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                    "operations",
                    |m: &Permission| { &m.operations },
                    |m: &mut Permission| { &mut m.operations },
                ));
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Key>>(
                    "keys",
                    |m: &Permission| { &m.keys },
                    |m: &mut Permission| { &mut m.keys },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<Permission>(
                    "Permission",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static Permission {
        static mut instance: ::protobuf::lazy::Lazy<Permission> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const Permission,
        };
        unsafe {
            instance.get(Permission::new)
        }
    }
}

impl ::protobuf::Clear for Permission {
    fn clear(&mut self) {
        self.field_type = Permission_PermissionType::Owner;
        self.id = 0;
        self.permission_name.clear();
        self.threshold = 0;
        self.parent_id = 0;
        self.operations.clear();
        self.keys.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for Permission {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Permission {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(Clone,PartialEq,Eq,Debug,Hash)]
pub enum Permission_PermissionType {
    Owner = 0,
    Witness = 1,
    Active = 2,
}

impl ::protobuf::ProtobufEnum for Permission_PermissionType {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<Permission_PermissionType> {
        match value {
            0 => ::std::option::Option::Some(Permission_PermissionType::Owner),
            1 => ::std::option::Option::Some(Permission_PermissionType::Witness),
            2 => ::std::option::Option::Some(Permission_PermissionType::Active),
            _ => ::std::option::Option::None
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [Permission_PermissionType] = &[
            Permission_PermissionType::Owner,
            Permission_PermissionType::Witness,
            Permission_PermissionType::Active,
        ];
        values
    }

    fn enum_descriptor_static() -> &'static ::protobuf::reflect::EnumDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::EnumDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                ::protobuf::reflect::EnumDescriptor::new("Permission_PermissionType", file_descriptor_proto())
            })
        }
    }
}

impl ::std::marker::Copy for Permission_PermissionType {
}

impl ::std::default::Default for Permission_PermissionType {
    fn default() -> Self {
        Permission_PermissionType::Owner
    }
}

impl ::protobuf::reflect::ProtobufValue for Permission_PermissionType {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Enum(self.descriptor())
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct Witness {
    // message fields
    pub address: ::std::vec::Vec<u8>,
    pub voteCount: i64,
    pub pubKey: ::std::vec::Vec<u8>,
    pub url: ::std::string::String,
    pub totalProduced: i64,
    pub totalMissed: i64,
    pub latestBlockNum: i64,
    pub latestSlotNum: i64,
    pub isJobs: bool,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a Witness {
    fn default() -> &'a Witness {
        <Witness as ::protobuf::Message>::default_instance()
    }
}

impl Witness {
    pub fn new() -> Witness {
        ::std::default::Default::default()
    }

    // bytes address = 1;


    pub fn get_address(&self) -> &[u8] {
        &self.address
    }
    pub fn clear_address(&mut self) {
        self.address.clear();
    }

    // Param is passed by value, moved
    pub fn set_address(&mut self, v: ::std::vec::Vec<u8>) {
        self.address = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_address(&mut self) -> &mut ::std::vec::Vec<u8> {
        &mut self.address
    }

    // Take field
    pub fn take_address(&mut self) -> ::std::vec::Vec<u8> {
        ::std::mem::replace(&mut self.address, ::std::vec::Vec::new())
    }

    // int64 voteCount = 2;


    pub fn get_voteCount(&self) -> i64 {
        self.voteCount
    }
    pub fn clear_voteCount(&mut self) {
        self.voteCount = 0;
    }

    // Param is passed by value, moved
    pub fn set_voteCount(&mut self, v: i64) {
        self.voteCount = v;
    }

    // bytes pubKey = 3;


    pub fn get_pubKey(&self) -> &[u8] {
        &self.pubKey
    }
    pub fn clear_pubKey(&mut self) {
        self.pubKey.clear();
    }

    // Param is passed by value, moved
    pub fn set_pubKey(&mut self, v: ::std::vec::Vec<u8>) {
        self.pubKey = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_pubKey(&mut self) -> &mut ::std::vec::Vec<u8> {
        &mut self.pubKey
    }

    // Take field
    pub fn take_pubKey(&mut self) -> ::std::vec::Vec<u8> {
        ::std::mem::replace(&mut self.pubKey, ::std::vec::Vec::new())
    }

    // string url = 4;


    pub fn get_url(&self) -> &str {
        &self.url
    }
    pub fn clear_url(&mut self) {
        self.url.clear();
    }

    // Param is passed by value, moved
    pub fn set_url(&mut self, v: ::std::string::String) {
        self.url = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_url(&mut self) -> &mut ::std::string::String {
        &mut self.url
    }

    // Take field
    pub fn take_url(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.url, ::std::string::String::new())
    }

    // int64 totalProduced = 5;


    pub fn get_totalProduced(&self) -> i64 {
        self.totalProduced
    }
    pub fn clear_totalProduced(&mut self) {
        self.totalProduced = 0;
    }

    // Param is passed by value, moved
    pub fn set_totalProduced(&mut self, v: i64) {
        self.totalProduced = v;
    }

    // int64 totalMissed = 6;


    pub fn get_totalMissed(&self) -> i64 {
        self.totalMissed
    }
    pub fn clear_totalMissed(&mut self) {
        self.totalMissed = 0;
    }

    // Param is passed by value, moved
    pub fn set_totalMissed(&mut self, v: i64) {
        self.totalMissed = v;
    }

    // int64 latestBlockNum = 7;


    pub fn get_latestBlockNum(&self) -> i64 {
        self.latestBlockNum
    }
    pub fn clear_latestBlockNum(&mut self) {
        self.latestBlockNum = 0;
    }

    // Param is passed by value, moved
    pub fn set_latestBlockNum(&mut self, v: i64) {
        self.latestBlockNum = v;
    }

    // int64 latestSlotNum = 8;


    pub fn get_latestSlotNum(&self) -> i64 {
        self.latestSlotNum
    }
    pub fn clear_latestSlotNum(&mut self) {
        self.latestSlotNum = 0;
    }

    // Param is passed by value, moved
    pub fn set_latestSlotNum(&mut self, v: i64) {
        self.latestSlotNum = v;
    }

    // bool isJobs = 9;


    pub fn get_isJobs(&self) -> bool {
        self.isJobs
    }
    pub fn clear_isJobs(&mut self) {
        self.isJobs = false;
    }

    // Param is passed by value, moved
    pub fn set_isJobs(&mut self, v: bool) {
        self.isJobs = v;
    }
}

impl ::protobuf::Message for Witness {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_bytes_into(wire_type, is, &mut self.address)?;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.voteCount = tmp;
                },
                3 => {
                    ::protobuf::rt::read_singular_proto3_bytes_into(wire_type, is, &mut self.pubKey)?;
                },
                4 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.url)?;
                },
                5 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.totalProduced = tmp;
                },
                6 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.totalMissed = tmp;
                },
                7 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.latestBlockNum = tmp;
                },
                8 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.latestSlotNum = tmp;
                },
                9 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.isJobs = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.address.is_empty() {
            my_size += ::protobuf::rt::bytes_size(1, &self.address);
        }
        if self.voteCount != 0 {
            my_size += ::protobuf::rt::value_size(2, self.voteCount, ::protobuf::wire_format::WireTypeVarint);
        }
        if !self.pubKey.is_empty() {
            my_size += ::protobuf::rt::bytes_size(3, &self.pubKey);
        }
        if !self.url.is_empty() {
            my_size += ::protobuf::rt::string_size(4, &self.url);
        }
        if self.totalProduced != 0 {
            my_size += ::protobuf::rt::value_size(5, self.totalProduced, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.totalMissed != 0 {
            my_size += ::protobuf::rt::value_size(6, self.totalMissed, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.latestBlockNum != 0 {
            my_size += ::protobuf::rt::value_size(7, self.latestBlockNum, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.latestSlotNum != 0 {
            my_size += ::protobuf::rt::value_size(8, self.latestSlotNum, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.isJobs != false {
            my_size += 2;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if !self.address.is_empty() {
            os.write_bytes(1, &self.address)?;
        }
        if self.voteCount != 0 {
            os.write_int64(2, self.voteCount)?;
        }
        if !self.pubKey.is_empty() {
            os.write_bytes(3, &self.pubKey)?;
        }
        if !self.url.is_empty() {
            os.write_string(4, &self.url)?;
        }
        if self.totalProduced != 0 {
            os.write_int64(5, self.totalProduced)?;
        }
        if self.totalMissed != 0 {
            os.write_int64(6, self.totalMissed)?;
        }
        if self.latestBlockNum != 0 {
            os.write_int64(7, self.latestBlockNum)?;
        }
        if self.latestSlotNum != 0 {
            os.write_int64(8, self.latestSlotNum)?;
        }
        if self.isJobs != false {
            os.write_bool(9, self.isJobs)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> Witness {
        Witness::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                    "address",
                    |m: &Witness| { &m.address },
                    |m: &mut Witness| { &mut m.address },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                    "voteCount",
                    |m: &Witness| { &m.voteCount },
                    |m: &mut Witness| { &mut m.voteCount },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                    "pubKey",
                    |m: &Witness| { &m.pubKey },
                    |m: &mut Witness| { &mut m.pubKey },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "url",
                    |m: &Witness| { &m.url },
                    |m: &mut Witness| { &mut m.url },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                    "totalProduced",
                    |m: &Witness| { &m.totalProduced },
                    |m: &mut Witness| { &mut m.totalProduced },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                    "totalMissed",
                    |m: &Witness| { &m.totalMissed },
                    |m: &mut Witness| { &mut m.totalMissed },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                    "latestBlockNum",
                    |m: &Witness| { &m.latestBlockNum },
                    |m: &mut Witness| { &mut m.latestBlockNum },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                    "latestSlotNum",
                    |m: &Witness| { &m.latestSlotNum },
                    |m: &mut Witness| { &mut m.latestSlotNum },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                    "isJobs",
                    |m: &Witness| { &m.isJobs },
                    |m: &mut Witness| { &mut m.isJobs },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<Witness>(
                    "Witness",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static Witness {
        static mut instance: ::protobuf::lazy::Lazy<Witness> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const Witness,
        };
        unsafe {
            instance.get(Witness::new)
        }
    }
}

impl ::protobuf::Clear for Witness {
    fn clear(&mut self) {
        self.address.clear();
        self.voteCount = 0;
        self.pubKey.clear();
        self.url.clear();
        self.totalProduced = 0;
        self.totalMissed = 0;
        self.latestBlockNum = 0;
        self.latestSlotNum = 0;
        self.isJobs = false;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for Witness {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Witness {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct Votes {
    // message fields
    pub address: ::std::vec::Vec<u8>,
    pub old_votes: ::protobuf::RepeatedField<Vote>,
    pub new_votes: ::protobuf::RepeatedField<Vote>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a Votes {
    fn default() -> &'a Votes {
        <Votes as ::protobuf::Message>::default_instance()
    }
}

impl Votes {
    pub fn new() -> Votes {
        ::std::default::Default::default()
    }

    // bytes address = 1;


    pub fn get_address(&self) -> &[u8] {
        &self.address
    }
    pub fn clear_address(&mut self) {
        self.address.clear();
    }

    // Param is passed by value, moved
    pub fn set_address(&mut self, v: ::std::vec::Vec<u8>) {
        self.address = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_address(&mut self) -> &mut ::std::vec::Vec<u8> {
        &mut self.address
    }

    // Take field
    pub fn take_address(&mut self) -> ::std::vec::Vec<u8> {
        ::std::mem::replace(&mut self.address, ::std::vec::Vec::new())
    }

    // repeated .protocol.Vote old_votes = 2;


    pub fn get_old_votes(&self) -> &[Vote] {
        &self.old_votes
    }
    pub fn clear_old_votes(&mut self) {
        self.old_votes.clear();
    }

    // Param is passed by value, moved
    pub fn set_old_votes(&mut self, v: ::protobuf::RepeatedField<Vote>) {
        self.old_votes = v;
    }

    // Mutable pointer to the field.
    pub fn mut_old_votes(&mut self) -> &mut ::protobuf::RepeatedField<Vote> {
        &mut self.old_votes
    }

    // Take field
    pub fn take_old_votes(&mut self) -> ::protobuf::RepeatedField<Vote> {
        ::std::mem::replace(&mut self.old_votes, ::protobuf::RepeatedField::new())
    }

    // repeated .protocol.Vote new_votes = 3;


    pub fn get_new_votes(&self) -> &[Vote] {
        &self.new_votes
    }
    pub fn clear_new_votes(&mut self) {
        self.new_votes.clear();
    }

    // Param is passed by value, moved
    pub fn set_new_votes(&mut self, v: ::protobuf::RepeatedField<Vote>) {
        self.new_votes = v;
    }

    // Mutable pointer to the field.
    pub fn mut_new_votes(&mut self) -> &mut ::protobuf::RepeatedField<Vote> {
        &mut self.new_votes
    }

    // Take field
    pub fn take_new_votes(&mut self) -> ::protobuf::RepeatedField<Vote> {
        ::std::mem::replace(&mut self.new_votes, ::protobuf::RepeatedField::new())
    }
}

impl ::protobuf::Message for Votes {
    fn is_initialized(&self) -> bool {
        for v in &self.old_votes {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.new_votes {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_bytes_into(wire_type, is, &mut self.address)?;
                },
                2 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.old_votes)?;
                },
                3 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.new_votes)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.address.is_empty() {
            my_size += ::protobuf::rt::bytes_size(1, &self.address);
        }
        for value in &self.old_votes {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        for value in &self.new_votes {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if !self.address.is_empty() {
            os.write_bytes(1, &self.address)?;
        }
        for v in &self.old_votes {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        for v in &self.new_votes {
            os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> Votes {
        Votes::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                    "address",
                    |m: &Votes| { &m.address },
                    |m: &mut Votes| { &mut m.address },
                ));
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Vote>>(
                    "old_votes",
                    |m: &Votes| { &m.old_votes },
                    |m: &mut Votes| { &mut m.old_votes },
                ));
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Vote>>(
                    "new_votes",
                    |m: &Votes| { &m.new_votes },
                    |m: &mut Votes| { &mut m.new_votes },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<Votes>(
                    "Votes",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static Votes {
        static mut instance: ::protobuf::lazy::Lazy<Votes> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const Votes,
        };
        unsafe {
            instance.get(Votes::new)
        }
    }
}

impl ::protobuf::Clear for Votes {
    fn clear(&mut self) {
        self.address.clear();
        self.old_votes.clear();
        self.new_votes.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for Votes {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Votes {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct TXOutput {
    // message fields
    pub value: i64,
    pub pubKeyHash: ::std::vec::Vec<u8>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a TXOutput {
    fn default() -> &'a TXOutput {
        <TXOutput as ::protobuf::Message>::default_instance()
    }
}

impl TXOutput {
    pub fn new() -> TXOutput {
        ::std::default::Default::default()
    }

    // int64 value = 1;


    pub fn get_value(&self) -> i64 {
        self.value
    }
    pub fn clear_value(&mut self) {
        self.value = 0;
    }

    // Param is passed by value, moved
    pub fn set_value(&mut self, v: i64) {
        self.value = v;
    }

    // bytes pubKeyHash = 2;


    pub fn get_pubKeyHash(&self) -> &[u8] {
        &self.pubKeyHash
    }
    pub fn clear_pubKeyHash(&mut self) {
        self.pubKeyHash.clear();
    }

    // Param is passed by value, moved
    pub fn set_pubKeyHash(&mut self, v: ::std::vec::Vec<u8>) {
        self.pubKeyHash = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_pubKeyHash(&mut self) -> &mut ::std::vec::Vec<u8> {
        &mut self.pubKeyHash
    }

    // Take field
    pub fn take_pubKeyHash(&mut self) -> ::std::vec::Vec<u8> {
        ::std::mem::replace(&mut self.pubKeyHash, ::std::vec::Vec::new())
    }
}

impl ::protobuf::Message for TXOutput {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.value = tmp;
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_bytes_into(wire_type, is, &mut self.pubKeyHash)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.value != 0 {
            my_size += ::protobuf::rt::value_size(1, self.value, ::protobuf::wire_format::WireTypeVarint);
        }
        if !self.pubKeyHash.is_empty() {
            my_size += ::protobuf::rt::bytes_size(2, &self.pubKeyHash);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if self.value != 0 {
            os.write_int64(1, self.value)?;
        }
        if !self.pubKeyHash.is_empty() {
            os.write_bytes(2, &self.pubKeyHash)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> TXOutput {
        TXOutput::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                    "value",
                    |m: &TXOutput| { &m.value },
                    |m: &mut TXOutput| { &mut m.value },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                    "pubKeyHash",
                    |m: &TXOutput| { &m.pubKeyHash },
                    |m: &mut TXOutput| { &mut m.pubKeyHash },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<TXOutput>(
                    "TXOutput",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static TXOutput {
        static mut instance: ::protobuf::lazy::Lazy<TXOutput> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const TXOutput,
        };
        unsafe {
            instance.get(TXOutput::new)
        }
    }
}

impl ::protobuf::Clear for TXOutput {
    fn clear(&mut self) {
        self.value = 0;
        self.pubKeyHash.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for TXOutput {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for TXOutput {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct TXInput {
    // message fields
    pub raw_data: ::protobuf::SingularPtrField<TXInput_raw>,
    pub signature: ::std::vec::Vec<u8>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a TXInput {
    fn default() -> &'a TXInput {
        <TXInput as ::protobuf::Message>::default_instance()
    }
}

impl TXInput {
    pub fn new() -> TXInput {
        ::std::default::Default::default()
    }

    // .protocol.TXInput.raw raw_data = 1;


    pub fn get_raw_data(&self) -> &TXInput_raw {
        self.raw_data.as_ref().unwrap_or_else(|| TXInput_raw::default_instance())
    }
    pub fn clear_raw_data(&mut self) {
        self.raw_data.clear();
    }

    pub fn has_raw_data(&self) -> bool {
        self.raw_data.is_some()
    }

    // Param is passed by value, moved
    pub fn set_raw_data(&mut self, v: TXInput_raw) {
        self.raw_data = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_raw_data(&mut self) -> &mut TXInput_raw {
        if self.raw_data.is_none() {
            self.raw_data.set_default();
        }
        self.raw_data.as_mut().unwrap()
    }

    // Take field
    pub fn take_raw_data(&mut self) -> TXInput_raw {
        self.raw_data.take().unwrap_or_else(|| TXInput_raw::new())
    }

    // bytes signature = 4;


    pub fn get_signature(&self) -> &[u8] {
        &self.signature
    }
    pub fn clear_signature(&mut self) {
        self.signature.clear();
    }

    // Param is passed by value, moved
    pub fn set_signature(&mut self, v: ::std::vec::Vec<u8>) {
        self.signature = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_signature(&mut self) -> &mut ::std::vec::Vec<u8> {
        &mut self.signature
    }

    // Take field
    pub fn take_signature(&mut self) -> ::std::vec::Vec<u8> {
        ::std::mem::replace(&mut self.signature, ::std::vec::Vec::new())
    }
}

impl ::protobuf::Message for TXInput {
    fn is_initialized(&self) -> bool {
        for v in &self.raw_data {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.raw_data)?;
                },
                4 => {
                    ::protobuf::rt::read_singular_proto3_bytes_into(wire_type, is, &mut self.signature)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.raw_data.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if !self.signature.is_empty() {
            my_size += ::protobuf::rt::bytes_size(4, &self.signature);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.raw_data.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if !self.signature.is_empty() {
            os.write_bytes(4, &self.signature)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> TXInput {
        TXInput::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<TXInput_raw>>(
                    "raw_data",
                    |m: &TXInput| { &m.raw_data },
                    |m: &mut TXInput| { &mut m.raw_data },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                    "signature",
                    |m: &TXInput| { &m.signature },
                    |m: &mut TXInput| { &mut m.signature },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<TXInput>(
                    "TXInput",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static TXInput {
        static mut instance: ::protobuf::lazy::Lazy<TXInput> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const TXInput,
        };
        unsafe {
            instance.get(TXInput::new)
        }
    }
}

impl ::protobuf::Clear for TXInput {
    fn clear(&mut self) {
        self.raw_data.clear();
        self.signature.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for TXInput {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for TXInput {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct TXInput_raw {
    // message fields
    pub txID: ::std::vec::Vec<u8>,
    pub vout: i64,
    pub pubKey: ::std::vec::Vec<u8>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a TXInput_raw {
    fn default() -> &'a TXInput_raw {
        <TXInput_raw as ::protobuf::Message>::default_instance()
    }
}

impl TXInput_raw {
    pub fn new() -> TXInput_raw {
        ::std::default::Default::default()
    }

    // bytes txID = 1;


    pub fn get_txID(&self) -> &[u8] {
        &self.txID
    }
    pub fn clear_txID(&mut self) {
        self.txID.clear();
    }

    // Param is passed by value, moved
    pub fn set_txID(&mut self, v: ::std::vec::Vec<u8>) {
        self.txID = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_txID(&mut self) -> &mut ::std::vec::Vec<u8> {
        &mut self.txID
    }

    // Take field
    pub fn take_txID(&mut self) -> ::std::vec::Vec<u8> {
        ::std::mem::replace(&mut self.txID, ::std::vec::Vec::new())
    }

    // int64 vout = 2;


    pub fn get_vout(&self) -> i64 {
        self.vout
    }
    pub fn clear_vout(&mut self) {
        self.vout = 0;
    }

    // Param is passed by value, moved
    pub fn set_vout(&mut self, v: i64) {
        self.vout = v;
    }

    // bytes pubKey = 3;


    pub fn get_pubKey(&self) -> &[u8] {
        &self.pubKey
    }
    pub fn clear_pubKey(&mut self) {
        self.pubKey.clear();
    }

    // Param is passed by value, moved
    pub fn set_pubKey(&mut self, v: ::std::vec::Vec<u8>) {
        self.pubKey = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_pubKey(&mut self) -> &mut ::std::vec::Vec<u8> {
        &mut self.pubKey
    }

    // Take field
    pub fn take_pubKey(&mut self) -> ::std::vec::Vec<u8> {
        ::std::mem::replace(&mut self.pubKey, ::std::vec::Vec::new())
    }
}

impl ::protobuf::Message for TXInput_raw {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_bytes_into(wire_type, is, &mut self.txID)?;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.vout = tmp;
                },
                3 => {
                    ::protobuf::rt::read_singular_proto3_bytes_into(wire_type, is, &mut self.pubKey)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.txID.is_empty() {
            my_size += ::protobuf::rt::bytes_size(1, &self.txID);
        }
        if self.vout != 0 {
            my_size += ::protobuf::rt::value_size(2, self.vout, ::protobuf::wire_format::WireTypeVarint);
        }
        if !self.pubKey.is_empty() {
            my_size += ::protobuf::rt::bytes_size(3, &self.pubKey);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if !self.txID.is_empty() {
            os.write_bytes(1, &self.txID)?;
        }
        if self.vout != 0 {
            os.write_int64(2, self.vout)?;
        }
        if !self.pubKey.is_empty() {
            os.write_bytes(3, &self.pubKey)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> TXInput_raw {
        TXInput_raw::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                    "txID",
                    |m: &TXInput_raw| { &m.txID },
                    |m: &mut TXInput_raw| { &mut m.txID },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                    "vout",
                    |m: &TXInput_raw| { &m.vout },
                    |m: &mut TXInput_raw| { &mut m.vout },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                    "pubKey",
                    |m: &TXInput_raw| { &m.pubKey },
                    |m: &mut TXInput_raw| { &mut m.pubKey },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<TXInput_raw>(
                    "TXInput_raw",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static TXInput_raw {
        static mut instance: ::protobuf::lazy::Lazy<TXInput_raw> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const TXInput_raw,
        };
        unsafe {
            instance.get(TXInput_raw::new)
        }
    }
}

impl ::protobuf::Clear for TXInput_raw {
    fn clear(&mut self) {
        self.txID.clear();
        self.vout = 0;
        self.pubKey.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for TXInput_raw {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for TXInput_raw {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct TXOutputs {
    // message fields
    pub outputs: ::protobuf::RepeatedField<TXOutput>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a TXOutputs {
    fn default() -> &'a TXOutputs {
        <TXOutputs as ::protobuf::Message>::default_instance()
    }
}

impl TXOutputs {
    pub fn new() -> TXOutputs {
        ::std::default::Default::default()
    }

    // repeated .protocol.TXOutput outputs = 1;


    pub fn get_outputs(&self) -> &[TXOutput] {
        &self.outputs
    }
    pub fn clear_outputs(&mut self) {
        self.outputs.clear();
    }

    // Param is passed by value, moved
    pub fn set_outputs(&mut self, v: ::protobuf::RepeatedField<TXOutput>) {
        self.outputs = v;
    }

    // Mutable pointer to the field.
    pub fn mut_outputs(&mut self) -> &mut ::protobuf::RepeatedField<TXOutput> {
        &mut self.outputs
    }

    // Take field
    pub fn take_outputs(&mut self) -> ::protobuf::RepeatedField<TXOutput> {
        ::std::mem::replace(&mut self.outputs, ::protobuf::RepeatedField::new())
    }
}

impl ::protobuf::Message for TXOutputs {
    fn is_initialized(&self) -> bool {
        for v in &self.outputs {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.outputs)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in &self.outputs {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        for v in &self.outputs {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> TXOutputs {
        TXOutputs::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<TXOutput>>(
                    "outputs",
                    |m: &TXOutputs| { &m.outputs },
                    |m: &mut TXOutputs| { &mut m.outputs },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<TXOutputs>(
                    "TXOutputs",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static TXOutputs {
        static mut instance: ::protobuf::lazy::Lazy<TXOutputs> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const TXOutputs,
        };
        unsafe {
            instance.get(TXOutputs::new)
        }
    }
}

impl ::protobuf::Clear for TXOutputs {
    fn clear(&mut self) {
        self.outputs.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for TXOutputs {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for TXOutputs {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct ResourceReceipt {
    // message fields
    pub energy_usage: i64,
    pub energy_fee: i64,
    pub origin_energy_usage: i64,
    pub energy_usage_total: i64,
    pub net_usage: i64,
    pub net_fee: i64,
    pub result: Transaction_Result_contractResult,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a ResourceReceipt {
    fn default() -> &'a ResourceReceipt {
        <ResourceReceipt as ::protobuf::Message>::default_instance()
    }
}

impl ResourceReceipt {
    pub fn new() -> ResourceReceipt {
        ::std::default::Default::default()
    }

    // int64 energy_usage = 1;


    pub fn get_energy_usage(&self) -> i64 {
        self.energy_usage
    }
    pub fn clear_energy_usage(&mut self) {
        self.energy_usage = 0;
    }

    // Param is passed by value, moved
    pub fn set_energy_usage(&mut self, v: i64) {
        self.energy_usage = v;
    }

    // int64 energy_fee = 2;


    pub fn get_energy_fee(&self) -> i64 {
        self.energy_fee
    }
    pub fn clear_energy_fee(&mut self) {
        self.energy_fee = 0;
    }

    // Param is passed by value, moved
    pub fn set_energy_fee(&mut self, v: i64) {
        self.energy_fee = v;
    }

    // int64 origin_energy_usage = 3;


    pub fn get_origin_energy_usage(&self) -> i64 {
        self.origin_energy_usage
    }
    pub fn clear_origin_energy_usage(&mut self) {
        self.origin_energy_usage = 0;
    }

    // Param is passed by value, moved
    pub fn set_origin_energy_usage(&mut self, v: i64) {
        self.origin_energy_usage = v;
    }

    // int64 energy_usage_total = 4;


    pub fn get_energy_usage_total(&self) -> i64 {
        self.energy_usage_total
    }
    pub fn clear_energy_usage_total(&mut self) {
        self.energy_usage_total = 0;
    }

    // Param is passed by value, moved
    pub fn set_energy_usage_total(&mut self, v: i64) {
        self.energy_usage_total = v;
    }

    // int64 net_usage = 5;


    pub fn get_net_usage(&self) -> i64 {
        self.net_usage
    }
    pub fn clear_net_usage(&mut self) {
        self.net_usage = 0;
    }

    // Param is passed by value, moved
    pub fn set_net_usage(&mut self, v: i64) {
        self.net_usage = v;
    }

    // int64 net_fee = 6;


    pub fn get_net_fee(&self) -> i64 {
        self.net_fee
    }
    pub fn clear_net_fee(&mut self) {
        self.net_fee = 0;
    }

    // Param is passed by value, moved
    pub fn set_net_fee(&mut self, v: i64) {
        self.net_fee = v;
    }

    // .protocol.Transaction.Result.contractResult result = 7;


    pub fn get_result(&self) -> Transaction_Result_contractResult {
        self.result
    }
    pub fn clear_result(&mut self) {
        self.result = Transaction_Result_contractResult::DEFAULT;
    }

    // Param is passed by value, moved
    pub fn set_result(&mut self, v: Transaction_Result_contractResult) {
        self.result = v;
    }
}

impl ::protobuf::Message for ResourceReceipt {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.energy_usage = tmp;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.energy_fee = tmp;
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.origin_energy_usage = tmp;
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.energy_usage_total = tmp;
                },
                5 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.net_usage = tmp;
                },
                6 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.net_fee = tmp;
                },
                7 => {
                    ::protobuf::rt::read_proto3_enum_with_unknown_fields_into(wire_type, is, &mut self.result, 7, &mut self.unknown_fields)?
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.energy_usage != 0 {
            my_size += ::protobuf::rt::value_size(1, self.energy_usage, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.energy_fee != 0 {
            my_size += ::protobuf::rt::value_size(2, self.energy_fee, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.origin_energy_usage != 0 {
            my_size += ::protobuf::rt::value_size(3, self.origin_energy_usage, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.energy_usage_total != 0 {
            my_size += ::protobuf::rt::value_size(4, self.energy_usage_total, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.net_usage != 0 {
            my_size += ::protobuf::rt::value_size(5, self.net_usage, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.net_fee != 0 {
            my_size += ::protobuf::rt::value_size(6, self.net_fee, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.result != Transaction_Result_contractResult::DEFAULT {
            my_size += ::protobuf::rt::enum_size(7, self.result);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if self.energy_usage != 0 {
            os.write_int64(1, self.energy_usage)?;
        }
        if self.energy_fee != 0 {
            os.write_int64(2, self.energy_fee)?;
        }
        if self.origin_energy_usage != 0 {
            os.write_int64(3, self.origin_energy_usage)?;
        }
        if self.energy_usage_total != 0 {
            os.write_int64(4, self.energy_usage_total)?;
        }
        if self.net_usage != 0 {
            os.write_int64(5, self.net_usage)?;
        }
        if self.net_fee != 0 {
            os.write_int64(6, self.net_fee)?;
        }
        if self.result != Transaction_Result_contractResult::DEFAULT {
            os.write_enum(7, self.result.value())?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> ResourceReceipt {
        ResourceReceipt::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                    "energy_usage",
                    |m: &ResourceReceipt| { &m.energy_usage },
                    |m: &mut ResourceReceipt| { &mut m.energy_usage },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                    "energy_fee",
                    |m: &ResourceReceipt| { &m.energy_fee },
                    |m: &mut ResourceReceipt| { &mut m.energy_fee },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                    "origin_energy_usage",
                    |m: &ResourceReceipt| { &m.origin_energy_usage },
                    |m: &mut ResourceReceipt| { &mut m.origin_energy_usage },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                    "energy_usage_total",
                    |m: &ResourceReceipt| { &m.energy_usage_total },
                    |m: &mut ResourceReceipt| { &mut m.energy_usage_total },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                    "net_usage",
                    |m: &ResourceReceipt| { &m.net_usage },
                    |m: &mut ResourceReceipt| { &mut m.net_usage },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                    "net_fee",
                    |m: &ResourceReceipt| { &m.net_fee },
                    |m: &mut ResourceReceipt| { &mut m.net_fee },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeEnum<Transaction_Result_contractResult>>(
                    "result",
                    |m: &ResourceReceipt| { &m.result },
                    |m: &mut ResourceReceipt| { &mut m.result },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<ResourceReceipt>(
                    "ResourceReceipt",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static ResourceReceipt {
        static mut instance: ::protobuf::lazy::Lazy<ResourceReceipt> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ResourceReceipt,
        };
        unsafe {
            instance.get(ResourceReceipt::new)
        }
    }
}

impl ::protobuf::Clear for ResourceReceipt {
    fn clear(&mut self) {
        self.energy_usage = 0;
        self.energy_fee = 0;
        self.origin_energy_usage = 0;
        self.energy_usage_total = 0;
        self.net_usage = 0;
        self.net_fee = 0;
        self.result = Transaction_Result_contractResult::DEFAULT;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ResourceReceipt {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ResourceReceipt {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct Transaction {
    // message fields
    pub raw_data: ::protobuf::SingularPtrField<Transaction_raw>,
    pub signature: ::protobuf::RepeatedField<::std::vec::Vec<u8>>,
    pub ret: ::protobuf::RepeatedField<Transaction_Result>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a Transaction {
    fn default() -> &'a Transaction {
        <Transaction as ::protobuf::Message>::default_instance()
    }
}

impl Transaction {
    pub fn new() -> Transaction {
        ::std::default::Default::default()
    }

    // .protocol.Transaction.raw raw_data = 1;


    pub fn get_raw_data(&self) -> &Transaction_raw {
        self.raw_data.as_ref().unwrap_or_else(|| Transaction_raw::default_instance())
    }
    pub fn clear_raw_data(&mut self) {
        self.raw_data.clear();
    }

    pub fn has_raw_data(&self) -> bool {
        self.raw_data.is_some()
    }

    // Param is passed by value, moved
    pub fn set_raw_data(&mut self, v: Transaction_raw) {
        self.raw_data = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_raw_data(&mut self) -> &mut Transaction_raw {
        if self.raw_data.is_none() {
            self.raw_data.set_default();
        }
        self.raw_data.as_mut().unwrap()
    }

    // Take field
    pub fn take_raw_data(&mut self) -> Transaction_raw {
        self.raw_data.take().unwrap_or_else(|| Transaction_raw::new())
    }

    // repeated bytes signature = 2;


    pub fn get_signature(&self) -> &[::std::vec::Vec<u8>] {
        &self.signature
    }
    pub fn clear_signature(&mut self) {
        self.signature.clear();
    }

    // Param is passed by value, moved
    pub fn set_signature(&mut self, v: ::protobuf::RepeatedField<::std::vec::Vec<u8>>) {
        self.signature = v;
    }

    // Mutable pointer to the field.
    pub fn mut_signature(&mut self) -> &mut ::protobuf::RepeatedField<::std::vec::Vec<u8>> {
        &mut self.signature
    }

    // Take field
    pub fn take_signature(&mut self) -> ::protobuf::RepeatedField<::std::vec::Vec<u8>> {
        ::std::mem::replace(&mut self.signature, ::protobuf::RepeatedField::new())
    }

    // repeated .protocol.Transaction.Result ret = 5;


    pub fn get_ret(&self) -> &[Transaction_Result] {
        &self.ret
    }
    pub fn clear_ret(&mut self) {
        self.ret.clear();
    }

    // Param is passed by value, moved
    pub fn set_ret(&mut self, v: ::protobuf::RepeatedField<Transaction_Result>) {
        self.ret = v;
    }

    // Mutable pointer to the field.
    pub fn mut_ret(&mut self) -> &mut ::protobuf::RepeatedField<Transaction_Result> {
        &mut self.ret
    }

    // Take field
    pub fn take_ret(&mut self) -> ::protobuf::RepeatedField<Transaction_Result> {
        ::std::mem::replace(&mut self.ret, ::protobuf::RepeatedField::new())
    }
}

impl ::protobuf::Message for Transaction {
    fn is_initialized(&self) -> bool {
        for v in &self.raw_data {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.ret {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.raw_data)?;
                },
                2 => {
                    ::protobuf::rt::read_repeated_bytes_into(wire_type, is, &mut self.signature)?;
                },
                5 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.ret)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.raw_data.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        for value in &self.signature {
            my_size += ::protobuf::rt::bytes_size(2, &value);
        };
        for value in &self.ret {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.raw_data.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        for v in &self.signature {
            os.write_bytes(2, &v)?;
        };
        for v in &self.ret {
            os.write_tag(5, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> Transaction {
        Transaction::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Transaction_raw>>(
                    "raw_data",
                    |m: &Transaction| { &m.raw_data },
                    |m: &mut Transaction| { &mut m.raw_data },
                ));
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                    "signature",
                    |m: &Transaction| { &m.signature },
                    |m: &mut Transaction| { &mut m.signature },
                ));
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Transaction_Result>>(
                    "ret",
                    |m: &Transaction| { &m.ret },
                    |m: &mut Transaction| { &mut m.ret },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<Transaction>(
                    "Transaction",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static Transaction {
        static mut instance: ::protobuf::lazy::Lazy<Transaction> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const Transaction,
        };
        unsafe {
            instance.get(Transaction::new)
        }
    }
}

impl ::protobuf::Clear for Transaction {
    fn clear(&mut self) {
        self.raw_data.clear();
        self.signature.clear();
        self.ret.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for Transaction {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Transaction {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct Transaction_Contract {
    // message fields
    pub field_type: Transaction_Contract_ContractType,
    pub parameter: ::protobuf::SingularPtrField<::protobuf::well_known_types::Any>,
    pub provider: ::std::vec::Vec<u8>,
    pub ContractName: ::std::vec::Vec<u8>,
    pub Permission_id: i32,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a Transaction_Contract {
    fn default() -> &'a Transaction_Contract {
        <Transaction_Contract as ::protobuf::Message>::default_instance()
    }
}

impl Transaction_Contract {
    pub fn new() -> Transaction_Contract {
        ::std::default::Default::default()
    }

    // .protocol.Transaction.Contract.ContractType type = 1;


    pub fn get_field_type(&self) -> Transaction_Contract_ContractType {
        self.field_type
    }
    pub fn clear_field_type(&mut self) {
        self.field_type = Transaction_Contract_ContractType::AccountCreateContract;
    }

    // Param is passed by value, moved
    pub fn set_field_type(&mut self, v: Transaction_Contract_ContractType) {
        self.field_type = v;
    }

    // .google.protobuf.Any parameter = 2;


    pub fn get_parameter(&self) -> &::protobuf::well_known_types::Any {
        self.parameter.as_ref().unwrap_or_else(|| ::protobuf::well_known_types::Any::default_instance())
    }
    pub fn clear_parameter(&mut self) {
        self.parameter.clear();
    }

    pub fn has_parameter(&self) -> bool {
        self.parameter.is_some()
    }

    // Param is passed by value, moved
    pub fn set_parameter(&mut self, v: ::protobuf::well_known_types::Any) {
        self.parameter = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_parameter(&mut self) -> &mut ::protobuf::well_known_types::Any {
        if self.parameter.is_none() {
            self.parameter.set_default();
        }
        self.parameter.as_mut().unwrap()
    }

    // Take field
    pub fn take_parameter(&mut self) -> ::protobuf::well_known_types::Any {
        self.parameter.take().unwrap_or_else(|| ::protobuf::well_known_types::Any::new())
    }

    // bytes provider = 3;


    pub fn get_provider(&self) -> &[u8] {
        &self.provider
    }
    pub fn clear_provider(&mut self) {
        self.provider.clear();
    }

    // Param is passed by value, moved
    pub fn set_provider(&mut self, v: ::std::vec::Vec<u8>) {
        self.provider = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_provider(&mut self) -> &mut ::std::vec::Vec<u8> {
        &mut self.provider
    }

    // Take field
    pub fn take_provider(&mut self) -> ::std::vec::Vec<u8> {
        ::std::mem::replace(&mut self.provider, ::std::vec::Vec::new())
    }

    // bytes ContractName = 4;


    pub fn get_ContractName(&self) -> &[u8] {
        &self.ContractName
    }
    pub fn clear_ContractName(&mut self) {
        self.ContractName.clear();
    }

    // Param is passed by value, moved
    pub fn set_ContractName(&mut self, v: ::std::vec::Vec<u8>) {
        self.ContractName = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_ContractName(&mut self) -> &mut ::std::vec::Vec<u8> {
        &mut self.ContractName
    }

    // Take field
    pub fn take_ContractName(&mut self) -> ::std::vec::Vec<u8> {
        ::std::mem::replace(&mut self.ContractName, ::std::vec::Vec::new())
    }

    // int32 Permission_id = 5;


    pub fn get_Permission_id(&self) -> i32 {
        self.Permission_id
    }
    pub fn clear_Permission_id(&mut self) {
        self.Permission_id = 0;
    }

    // Param is passed by value, moved
    pub fn set_Permission_id(&mut self, v: i32) {
        self.Permission_id = v;
    }
}

impl ::protobuf::Message for Transaction_Contract {
    fn is_initialized(&self) -> bool {
        for v in &self.parameter {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_proto3_enum_with_unknown_fields_into(wire_type, is, &mut self.field_type, 1, &mut self.unknown_fields)?
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.parameter)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_proto3_bytes_into(wire_type, is, &mut self.provider)?;
                },
                4 => {
                    ::protobuf::rt::read_singular_proto3_bytes_into(wire_type, is, &mut self.ContractName)?;
                },
                5 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.Permission_id = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.field_type != Transaction_Contract_ContractType::AccountCreateContract {
            my_size += ::protobuf::rt::enum_size(1, self.field_type);
        }
        if let Some(ref v) = self.parameter.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if !self.provider.is_empty() {
            my_size += ::protobuf::rt::bytes_size(3, &self.provider);
        }
        if !self.ContractName.is_empty() {
            my_size += ::protobuf::rt::bytes_size(4, &self.ContractName);
        }
        if self.Permission_id != 0 {
            my_size += ::protobuf::rt::value_size(5, self.Permission_id, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if self.field_type != Transaction_Contract_ContractType::AccountCreateContract {
            os.write_enum(1, self.field_type.value())?;
        }
        if let Some(ref v) = self.parameter.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if !self.provider.is_empty() {
            os.write_bytes(3, &self.provider)?;
        }
        if !self.ContractName.is_empty() {
            os.write_bytes(4, &self.ContractName)?;
        }
        if self.Permission_id != 0 {
            os.write_int32(5, self.Permission_id)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> Transaction_Contract {
        Transaction_Contract::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeEnum<Transaction_Contract_ContractType>>(
                    "type",
                    |m: &Transaction_Contract| { &m.field_type },
                    |m: &mut Transaction_Contract| { &mut m.field_type },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<::protobuf::well_known_types::Any>>(
                    "parameter",
                    |m: &Transaction_Contract| { &m.parameter },
                    |m: &mut Transaction_Contract| { &mut m.parameter },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                    "provider",
                    |m: &Transaction_Contract| { &m.provider },
                    |m: &mut Transaction_Contract| { &mut m.provider },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                    "ContractName",
                    |m: &Transaction_Contract| { &m.ContractName },
                    |m: &mut Transaction_Contract| { &mut m.ContractName },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                    "Permission_id",
                    |m: &Transaction_Contract| { &m.Permission_id },
                    |m: &mut Transaction_Contract| { &mut m.Permission_id },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<Transaction_Contract>(
                    "Transaction_Contract",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static Transaction_Contract {
        static mut instance: ::protobuf::lazy::Lazy<Transaction_Contract> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const Transaction_Contract,
        };
        unsafe {
            instance.get(Transaction_Contract::new)
        }
    }
}

impl ::protobuf::Clear for Transaction_Contract {
    fn clear(&mut self) {
        self.field_type = Transaction_Contract_ContractType::AccountCreateContract;
        self.parameter.clear();
        self.provider.clear();
        self.ContractName.clear();
        self.Permission_id = 0;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for Transaction_Contract {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Transaction_Contract {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(Clone,PartialEq,Eq,Debug,Hash)]
pub enum Transaction_Contract_ContractType {
    AccountCreateContract = 0,
    TransferContract = 1,
    TransferAssetContract = 2,
    VoteAssetContract = 3,
    VoteWitnessContract = 4,
    WitnessCreateContract = 5,
    AssetIssueContract = 6,
    WitnessUpdateContract = 8,
    ParticipateAssetIssueContract = 9,
    AccountUpdateContract = 10,
    FreezeBalanceContract = 11,
    UnfreezeBalanceContract = 12,
    WithdrawBalanceContract = 13,
    UnfreezeAssetContract = 14,
    UpdateAssetContract = 15,
    ProposalCreateContract = 16,
    ProposalApproveContract = 17,
    ProposalDeleteContract = 18,
    SetAccountIdContract = 19,
    CustomContract = 20,
    CreateSmartContract = 30,
    TriggerSmartContract = 31,
    GetContract = 32,
    UpdateSettingContract = 33,
    ExchangeCreateContract = 41,
    ExchangeInjectContract = 42,
    ExchangeWithdrawContract = 43,
    ExchangeTransactionContract = 44,
    UpdateEnergyLimitContract = 45,
    AccountPermissionUpdateContract = 46,
    ClearABIContract = 48,
}

impl ::protobuf::ProtobufEnum for Transaction_Contract_ContractType {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<Transaction_Contract_ContractType> {
        match value {
            0 => ::std::option::Option::Some(Transaction_Contract_ContractType::AccountCreateContract),
            1 => ::std::option::Option::Some(Transaction_Contract_ContractType::TransferContract),
            2 => ::std::option::Option::Some(Transaction_Contract_ContractType::TransferAssetContract),
            3 => ::std::option::Option::Some(Transaction_Contract_ContractType::VoteAssetContract),
            4 => ::std::option::Option::Some(Transaction_Contract_ContractType::VoteWitnessContract),
            5 => ::std::option::Option::Some(Transaction_Contract_ContractType::WitnessCreateContract),
            6 => ::std::option::Option::Some(Transaction_Contract_ContractType::AssetIssueContract),
            8 => ::std::option::Option::Some(Transaction_Contract_ContractType::WitnessUpdateContract),
            9 => ::std::option::Option::Some(Transaction_Contract_ContractType::ParticipateAssetIssueContract),
            10 => ::std::option::Option::Some(Transaction_Contract_ContractType::AccountUpdateContract),
            11 => ::std::option::Option::Some(Transaction_Contract_ContractType::FreezeBalanceContract),
            12 => ::std::option::Option::Some(Transaction_Contract_ContractType::UnfreezeBalanceContract),
            13 => ::std::option::Option::Some(Transaction_Contract_ContractType::WithdrawBalanceContract),
            14 => ::std::option::Option::Some(Transaction_Contract_ContractType::UnfreezeAssetContract),
            15 => ::std::option::Option::Some(Transaction_Contract_ContractType::UpdateAssetContract),
            16 => ::std::option::Option::Some(Transaction_Contract_ContractType::ProposalCreateContract),
            17 => ::std::option::Option::Some(Transaction_Contract_ContractType::ProposalApproveContract),
            18 => ::std::option::Option::Some(Transaction_Contract_ContractType::ProposalDeleteContract),
            19 => ::std::option::Option::Some(Transaction_Contract_ContractType::SetAccountIdContract),
            20 => ::std::option::Option::Some(Transaction_Contract_ContractType::CustomContract),
            30 => ::std::option::Option::Some(Transaction_Contract_ContractType::CreateSmartContract),
            31 => ::std::option::Option::Some(Transaction_Contract_ContractType::TriggerSmartContract),
            32 => ::std::option::Option::Some(Transaction_Contract_ContractType::GetContract),
            33 => ::std::option::Option::Some(Transaction_Contract_ContractType::UpdateSettingContract),
            41 => ::std::option::Option::Some(Transaction_Contract_ContractType::ExchangeCreateContract),
            42 => ::std::option::Option::Some(Transaction_Contract_ContractType::ExchangeInjectContract),
            43 => ::std::option::Option::Some(Transaction_Contract_ContractType::ExchangeWithdrawContract),
            44 => ::std::option::Option::Some(Transaction_Contract_ContractType::ExchangeTransactionContract),
            45 => ::std::option::Option::Some(Transaction_Contract_ContractType::UpdateEnergyLimitContract),
            46 => ::std::option::Option::Some(Transaction_Contract_ContractType::AccountPermissionUpdateContract),
            48 => ::std::option::Option::Some(Transaction_Contract_ContractType::ClearABIContract),
            _ => ::std::option::Option::None
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [Transaction_Contract_ContractType] = &[
            Transaction_Contract_ContractType::AccountCreateContract,
            Transaction_Contract_ContractType::TransferContract,
            Transaction_Contract_ContractType::TransferAssetContract,
            Transaction_Contract_ContractType::VoteAssetContract,
            Transaction_Contract_ContractType::VoteWitnessContract,
            Transaction_Contract_ContractType::WitnessCreateContract,
            Transaction_Contract_ContractType::AssetIssueContract,
            Transaction_Contract_ContractType::WitnessUpdateContract,
            Transaction_Contract_ContractType::ParticipateAssetIssueContract,
            Transaction_Contract_ContractType::AccountUpdateContract,
            Transaction_Contract_ContractType::FreezeBalanceContract,
            Transaction_Contract_ContractType::UnfreezeBalanceContract,
            Transaction_Contract_ContractType::WithdrawBalanceContract,
            Transaction_Contract_ContractType::UnfreezeAssetContract,
            Transaction_Contract_ContractType::UpdateAssetContract,
            Transaction_Contract_ContractType::ProposalCreateContract,
            Transaction_Contract_ContractType::ProposalApproveContract,
            Transaction_Contract_ContractType::ProposalDeleteContract,
            Transaction_Contract_ContractType::SetAccountIdContract,
            Transaction_Contract_ContractType::CustomContract,
            Transaction_Contract_ContractType::CreateSmartContract,
            Transaction_Contract_ContractType::TriggerSmartContract,
            Transaction_Contract_ContractType::GetContract,
            Transaction_Contract_ContractType::UpdateSettingContract,
            Transaction_Contract_ContractType::ExchangeCreateContract,
            Transaction_Contract_ContractType::ExchangeInjectContract,
            Transaction_Contract_ContractType::ExchangeWithdrawContract,
            Transaction_Contract_ContractType::ExchangeTransactionContract,
            Transaction_Contract_ContractType::UpdateEnergyLimitContract,
            Transaction_Contract_ContractType::AccountPermissionUpdateContract,
            Transaction_Contract_ContractType::ClearABIContract,
        ];
        values
    }

    fn enum_descriptor_static() -> &'static ::protobuf::reflect::EnumDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::EnumDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                ::protobuf::reflect::EnumDescriptor::new("Transaction_Contract_ContractType", file_descriptor_proto())
            })
        }
    }
}

impl ::std::marker::Copy for Transaction_Contract_ContractType {
}

impl ::std::default::Default for Transaction_Contract_ContractType {
    fn default() -> Self {
        Transaction_Contract_ContractType::AccountCreateContract
    }
}

impl ::protobuf::reflect::ProtobufValue for Transaction_Contract_ContractType {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Enum(self.descriptor())
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct Transaction_Result {
    // message fields
    pub fee: i64,
    pub ret: Transaction_Result_code,
    pub contractRet: Transaction_Result_contractResult,
    pub assetIssueID: ::std::string::String,
    pub withdraw_amount: i64,
    pub unfreeze_amount: i64,
    pub exchange_received_amount: i64,
    pub exchange_inject_another_amount: i64,
    pub exchange_withdraw_another_amount: i64,
    pub exchange_id: i64,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a Transaction_Result {
    fn default() -> &'a Transaction_Result {
        <Transaction_Result as ::protobuf::Message>::default_instance()
    }
}

impl Transaction_Result {
    pub fn new() -> Transaction_Result {
        ::std::default::Default::default()
    }

    // int64 fee = 1;


    pub fn get_fee(&self) -> i64 {
        self.fee
    }
    pub fn clear_fee(&mut self) {
        self.fee = 0;
    }

    // Param is passed by value, moved
    pub fn set_fee(&mut self, v: i64) {
        self.fee = v;
    }

    // .protocol.Transaction.Result.code ret = 2;


    pub fn get_ret(&self) -> Transaction_Result_code {
        self.ret
    }
    pub fn clear_ret(&mut self) {
        self.ret = Transaction_Result_code::SUCESS;
    }

    // Param is passed by value, moved
    pub fn set_ret(&mut self, v: Transaction_Result_code) {
        self.ret = v;
    }

    // .protocol.Transaction.Result.contractResult contractRet = 3;


    pub fn get_contractRet(&self) -> Transaction_Result_contractResult {
        self.contractRet
    }
    pub fn clear_contractRet(&mut self) {
        self.contractRet = Transaction_Result_contractResult::DEFAULT;
    }

    // Param is passed by value, moved
    pub fn set_contractRet(&mut self, v: Transaction_Result_contractResult) {
        self.contractRet = v;
    }

    // string assetIssueID = 14;


    pub fn get_assetIssueID(&self) -> &str {
        &self.assetIssueID
    }
    pub fn clear_assetIssueID(&mut self) {
        self.assetIssueID.clear();
    }

    // Param is passed by value, moved
    pub fn set_assetIssueID(&mut self, v: ::std::string::String) {
        self.assetIssueID = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_assetIssueID(&mut self) -> &mut ::std::string::String {
        &mut self.assetIssueID
    }

    // Take field
    pub fn take_assetIssueID(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.assetIssueID, ::std::string::String::new())
    }

    // int64 withdraw_amount = 15;


    pub fn get_withdraw_amount(&self) -> i64 {
        self.withdraw_amount
    }
    pub fn clear_withdraw_amount(&mut self) {
        self.withdraw_amount = 0;
    }

    // Param is passed by value, moved
    pub fn set_withdraw_amount(&mut self, v: i64) {
        self.withdraw_amount = v;
    }

    // int64 unfreeze_amount = 16;


    pub fn get_unfreeze_amount(&self) -> i64 {
        self.unfreeze_amount
    }
    pub fn clear_unfreeze_amount(&mut self) {
        self.unfreeze_amount = 0;
    }

    // Param is passed by value, moved
    pub fn set_unfreeze_amount(&mut self, v: i64) {
        self.unfreeze_amount = v;
    }

    // int64 exchange_received_amount = 18;


    pub fn get_exchange_received_amount(&self) -> i64 {
        self.exchange_received_amount
    }
    pub fn clear_exchange_received_amount(&mut self) {
        self.exchange_received_amount = 0;
    }

    // Param is passed by value, moved
    pub fn set_exchange_received_amount(&mut self, v: i64) {
        self.exchange_received_amount = v;
    }

    // int64 exchange_inject_another_amount = 19;


    pub fn get_exchange_inject_another_amount(&self) -> i64 {
        self.exchange_inject_another_amount
    }
    pub fn clear_exchange_inject_another_amount(&mut self) {
        self.exchange_inject_another_amount = 0;
    }

    // Param is passed by value, moved
    pub fn set_exchange_inject_another_amount(&mut self, v: i64) {
        self.exchange_inject_another_amount = v;
    }

    // int64 exchange_withdraw_another_amount = 20;


    pub fn get_exchange_withdraw_another_amount(&self) -> i64 {
        self.exchange_withdraw_another_amount
    }
    pub fn clear_exchange_withdraw_another_amount(&mut self) {
        self.exchange_withdraw_another_amount = 0;
    }

    // Param is passed by value, moved
    pub fn set_exchange_withdraw_another_amount(&mut self, v: i64) {
        self.exchange_withdraw_another_amount = v;
    }

    // int64 exchange_id = 21;


    pub fn get_exchange_id(&self) -> i64 {
        self.exchange_id
    }
    pub fn clear_exchange_id(&mut self) {
        self.exchange_id = 0;
    }

    // Param is passed by value, moved
    pub fn set_exchange_id(&mut self, v: i64) {
        self.exchange_id = v;
    }
}

impl ::protobuf::Message for Transaction_Result {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.fee = tmp;
                },
                2 => {
                    ::protobuf::rt::read_proto3_enum_with_unknown_fields_into(wire_type, is, &mut self.ret, 2, &mut self.unknown_fields)?
                },
                3 => {
                    ::protobuf::rt::read_proto3_enum_with_unknown_fields_into(wire_type, is, &mut self.contractRet, 3, &mut self.unknown_fields)?
                },
                14 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.assetIssueID)?;
                },
                15 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.withdraw_amount = tmp;
                },
                16 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.unfreeze_amount = tmp;
                },
                18 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.exchange_received_amount = tmp;
                },
                19 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.exchange_inject_another_amount = tmp;
                },
                20 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.exchange_withdraw_another_amount = tmp;
                },
                21 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.exchange_id = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.fee != 0 {
            my_size += ::protobuf::rt::value_size(1, self.fee, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.ret != Transaction_Result_code::SUCESS {
            my_size += ::protobuf::rt::enum_size(2, self.ret);
        }
        if self.contractRet != Transaction_Result_contractResult::DEFAULT {
            my_size += ::protobuf::rt::enum_size(3, self.contractRet);
        }
        if !self.assetIssueID.is_empty() {
            my_size += ::protobuf::rt::string_size(14, &self.assetIssueID);
        }
        if self.withdraw_amount != 0 {
            my_size += ::protobuf::rt::value_size(15, self.withdraw_amount, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.unfreeze_amount != 0 {
            my_size += ::protobuf::rt::value_size(16, self.unfreeze_amount, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.exchange_received_amount != 0 {
            my_size += ::protobuf::rt::value_size(18, self.exchange_received_amount, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.exchange_inject_another_amount != 0 {
            my_size += ::protobuf::rt::value_size(19, self.exchange_inject_another_amount, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.exchange_withdraw_another_amount != 0 {
            my_size += ::protobuf::rt::value_size(20, self.exchange_withdraw_another_amount, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.exchange_id != 0 {
            my_size += ::protobuf::rt::value_size(21, self.exchange_id, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if self.fee != 0 {
            os.write_int64(1, self.fee)?;
        }
        if self.ret != Transaction_Result_code::SUCESS {
            os.write_enum(2, self.ret.value())?;
        }
        if self.contractRet != Transaction_Result_contractResult::DEFAULT {
            os.write_enum(3, self.contractRet.value())?;
        }
        if !self.assetIssueID.is_empty() {
            os.write_string(14, &self.assetIssueID)?;
        }
        if self.withdraw_amount != 0 {
            os.write_int64(15, self.withdraw_amount)?;
        }
        if self.unfreeze_amount != 0 {
            os.write_int64(16, self.unfreeze_amount)?;
        }
        if self.exchange_received_amount != 0 {
            os.write_int64(18, self.exchange_received_amount)?;
        }
        if self.exchange_inject_another_amount != 0 {
            os.write_int64(19, self.exchange_inject_another_amount)?;
        }
        if self.exchange_withdraw_another_amount != 0 {
            os.write_int64(20, self.exchange_withdraw_another_amount)?;
        }
        if self.exchange_id != 0 {
            os.write_int64(21, self.exchange_id)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> Transaction_Result {
        Transaction_Result::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                    "fee",
                    |m: &Transaction_Result| { &m.fee },
                    |m: &mut Transaction_Result| { &mut m.fee },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeEnum<Transaction_Result_code>>(
                    "ret",
                    |m: &Transaction_Result| { &m.ret },
                    |m: &mut Transaction_Result| { &mut m.ret },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeEnum<Transaction_Result_contractResult>>(
                    "contractRet",
                    |m: &Transaction_Result| { &m.contractRet },
                    |m: &mut Transaction_Result| { &mut m.contractRet },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "assetIssueID",
                    |m: &Transaction_Result| { &m.assetIssueID },
                    |m: &mut Transaction_Result| { &mut m.assetIssueID },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                    "withdraw_amount",
                    |m: &Transaction_Result| { &m.withdraw_amount },
                    |m: &mut Transaction_Result| { &mut m.withdraw_amount },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                    "unfreeze_amount",
                    |m: &Transaction_Result| { &m.unfreeze_amount },
                    |m: &mut Transaction_Result| { &mut m.unfreeze_amount },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                    "exchange_received_amount",
                    |m: &Transaction_Result| { &m.exchange_received_amount },
                    |m: &mut Transaction_Result| { &mut m.exchange_received_amount },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                    "exchange_inject_another_amount",
                    |m: &Transaction_Result| { &m.exchange_inject_another_amount },
                    |m: &mut Transaction_Result| { &mut m.exchange_inject_another_amount },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                    "exchange_withdraw_another_amount",
                    |m: &Transaction_Result| { &m.exchange_withdraw_another_amount },
                    |m: &mut Transaction_Result| { &mut m.exchange_withdraw_another_amount },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                    "exchange_id",
                    |m: &Transaction_Result| { &m.exchange_id },
                    |m: &mut Transaction_Result| { &mut m.exchange_id },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<Transaction_Result>(
                    "Transaction_Result",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static Transaction_Result {
        static mut instance: ::protobuf::lazy::Lazy<Transaction_Result> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const Transaction_Result,
        };
        unsafe {
            instance.get(Transaction_Result::new)
        }
    }
}

impl ::protobuf::Clear for Transaction_Result {
    fn clear(&mut self) {
        self.fee = 0;
        self.ret = Transaction_Result_code::SUCESS;
        self.contractRet = Transaction_Result_contractResult::DEFAULT;
        self.assetIssueID.clear();
        self.withdraw_amount = 0;
        self.unfreeze_amount = 0;
        self.exchange_received_amount = 0;
        self.exchange_inject_another_amount = 0;
        self.exchange_withdraw_another_amount = 0;
        self.exchange_id = 0;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for Transaction_Result {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Transaction_Result {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(Clone,PartialEq,Eq,Debug,Hash)]
pub enum Transaction_Result_code {
    SUCESS = 0,
    FAILED = 1,
}

impl ::protobuf::ProtobufEnum for Transaction_Result_code {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<Transaction_Result_code> {
        match value {
            0 => ::std::option::Option::Some(Transaction_Result_code::SUCESS),
            1 => ::std::option::Option::Some(Transaction_Result_code::FAILED),
            _ => ::std::option::Option::None
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [Transaction_Result_code] = &[
            Transaction_Result_code::SUCESS,
            Transaction_Result_code::FAILED,
        ];
        values
    }

    fn enum_descriptor_static() -> &'static ::protobuf::reflect::EnumDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::EnumDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                ::protobuf::reflect::EnumDescriptor::new("Transaction_Result_code", file_descriptor_proto())
            })
        }
    }
}

impl ::std::marker::Copy for Transaction_Result_code {
}

impl ::std::default::Default for Transaction_Result_code {
    fn default() -> Self {
        Transaction_Result_code::SUCESS
    }
}

impl ::protobuf::reflect::ProtobufValue for Transaction_Result_code {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Enum(self.descriptor())
    }
}

#[derive(Clone,PartialEq,Eq,Debug,Hash)]
pub enum Transaction_Result_contractResult {
    DEFAULT = 0,
    SUCCESS = 1,
    REVERT = 2,
    BAD_JUMP_DESTINATION = 3,
    OUT_OF_MEMORY = 4,
    PRECOMPILED_CONTRACT = 5,
    STACK_TOO_SMALL = 6,
    STACK_TOO_LARGE = 7,
    ILLEGAL_OPERATION = 8,
    STACK_OVERFLOW = 9,
    OUT_OF_ENERGY = 10,
    OUT_OF_TIME = 11,
    JVM_STACK_OVER_FLOW = 12,
    UNKNOWN = 13,
    TRANSFER_FAILED = 14,
}

impl ::protobuf::ProtobufEnum for Transaction_Result_contractResult {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<Transaction_Result_contractResult> {
        match value {
            0 => ::std::option::Option::Some(Transaction_Result_contractResult::DEFAULT),
            1 => ::std::option::Option::Some(Transaction_Result_contractResult::SUCCESS),
            2 => ::std::option::Option::Some(Transaction_Result_contractResult::REVERT),
            3 => ::std::option::Option::Some(Transaction_Result_contractResult::BAD_JUMP_DESTINATION),
            4 => ::std::option::Option::Some(Transaction_Result_contractResult::OUT_OF_MEMORY),
            5 => ::std::option::Option::Some(Transaction_Result_contractResult::PRECOMPILED_CONTRACT),
            6 => ::std::option::Option::Some(Transaction_Result_contractResult::STACK_TOO_SMALL),
            7 => ::std::option::Option::Some(Transaction_Result_contractResult::STACK_TOO_LARGE),
            8 => ::std::option::Option::Some(Transaction_Result_contractResult::ILLEGAL_OPERATION),
            9 => ::std::option::Option::Some(Transaction_Result_contractResult::STACK_OVERFLOW),
            10 => ::std::option::Option::Some(Transaction_Result_contractResult::OUT_OF_ENERGY),
            11 => ::std::option::Option::Some(Transaction_Result_contractResult::OUT_OF_TIME),
            12 => ::std::option::Option::Some(Transaction_Result_contractResult::JVM_STACK_OVER_FLOW),
            13 => ::std::option::Option::Some(Transaction_Result_contractResult::UNKNOWN),
            14 => ::std::option::Option::Some(Transaction_Result_contractResult::TRANSFER_FAILED),
            _ => ::std::option::Option::None
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [Transaction_Result_contractResult] = &[
            Transaction_Result_contractResult::DEFAULT,
            Transaction_Result_contractResult::SUCCESS,
            Transaction_Result_contractResult::REVERT,
            Transaction_Result_contractResult::BAD_JUMP_DESTINATION,
            Transaction_Result_contractResult::OUT_OF_MEMORY,
            Transaction_Result_contractResult::PRECOMPILED_CONTRACT,
            Transaction_Result_contractResult::STACK_TOO_SMALL,
            Transaction_Result_contractResult::STACK_TOO_LARGE,
            Transaction_Result_contractResult::ILLEGAL_OPERATION,
            Transaction_Result_contractResult::STACK_OVERFLOW,
            Transaction_Result_contractResult::OUT_OF_ENERGY,
            Transaction_Result_contractResult::OUT_OF_TIME,
            Transaction_Result_contractResult::JVM_STACK_OVER_FLOW,
            Transaction_Result_contractResult::UNKNOWN,
            Transaction_Result_contractResult::TRANSFER_FAILED,
        ];
        values
    }

    fn enum_descriptor_static() -> &'static ::protobuf::reflect::EnumDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::EnumDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                ::protobuf::reflect::EnumDescriptor::new("Transaction_Result_contractResult", file_descriptor_proto())
            })
        }
    }
}

impl ::std::marker::Copy for Transaction_Result_contractResult {
}

impl ::std::default::Default for Transaction_Result_contractResult {
    fn default() -> Self {
        Transaction_Result_contractResult::DEFAULT
    }
}

impl ::protobuf::reflect::ProtobufValue for Transaction_Result_contractResult {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Enum(self.descriptor())
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct Transaction_raw {
    // message fields
    pub ref_block_bytes: ::std::vec::Vec<u8>,
    pub ref_block_num: i64,
    pub ref_block_hash: ::std::vec::Vec<u8>,
    pub expiration: i64,
    pub auths: ::protobuf::RepeatedField<authority>,
    pub data: ::std::vec::Vec<u8>,
    pub contract: ::protobuf::RepeatedField<Transaction_Contract>,
    pub scripts: ::std::vec::Vec<u8>,
    pub timestamp: i64,
    pub fee_limit: i64,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a Transaction_raw {
    fn default() -> &'a Transaction_raw {
        <Transaction_raw as ::protobuf::Message>::default_instance()
    }
}

impl Transaction_raw {
    pub fn new() -> Transaction_raw {
        ::std::default::Default::default()
    }

    // bytes ref_block_bytes = 1;


    pub fn get_ref_block_bytes(&self) -> &[u8] {
        &self.ref_block_bytes
    }
    pub fn clear_ref_block_bytes(&mut self) {
        self.ref_block_bytes.clear();
    }

    // Param is passed by value, moved
    pub fn set_ref_block_bytes(&mut self, v: ::std::vec::Vec<u8>) {
        self.ref_block_bytes = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_ref_block_bytes(&mut self) -> &mut ::std::vec::Vec<u8> {
        &mut self.ref_block_bytes
    }

    // Take field
    pub fn take_ref_block_bytes(&mut self) -> ::std::vec::Vec<u8> {
        ::std::mem::replace(&mut self.ref_block_bytes, ::std::vec::Vec::new())
    }

    // int64 ref_block_num = 3;


    pub fn get_ref_block_num(&self) -> i64 {
        self.ref_block_num
    }
    pub fn clear_ref_block_num(&mut self) {
        self.ref_block_num = 0;
    }

    // Param is passed by value, moved
    pub fn set_ref_block_num(&mut self, v: i64) {
        self.ref_block_num = v;
    }

    // bytes ref_block_hash = 4;


    pub fn get_ref_block_hash(&self) -> &[u8] {
        &self.ref_block_hash
    }
    pub fn clear_ref_block_hash(&mut self) {
        self.ref_block_hash.clear();
    }

    // Param is passed by value, moved
    pub fn set_ref_block_hash(&mut self, v: ::std::vec::Vec<u8>) {
        self.ref_block_hash = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_ref_block_hash(&mut self) -> &mut ::std::vec::Vec<u8> {
        &mut self.ref_block_hash
    }

    // Take field
    pub fn take_ref_block_hash(&mut self) -> ::std::vec::Vec<u8> {
        ::std::mem::replace(&mut self.ref_block_hash, ::std::vec::Vec::new())
    }

    // int64 expiration = 8;


    pub fn get_expiration(&self) -> i64 {
        self.expiration
    }
    pub fn clear_expiration(&mut self) {
        self.expiration = 0;
    }

    // Param is passed by value, moved
    pub fn set_expiration(&mut self, v: i64) {
        self.expiration = v;
    }

    // repeated .protocol.authority auths = 9;


    pub fn get_auths(&self) -> &[authority] {
        &self.auths
    }
    pub fn clear_auths(&mut self) {
        self.auths.clear();
    }

    // Param is passed by value, moved
    pub fn set_auths(&mut self, v: ::protobuf::RepeatedField<authority>) {
        self.auths = v;
    }

    // Mutable pointer to the field.
    pub fn mut_auths(&mut self) -> &mut ::protobuf::RepeatedField<authority> {
        &mut self.auths
    }

    // Take field
    pub fn take_auths(&mut self) -> ::protobuf::RepeatedField<authority> {
        ::std::mem::replace(&mut self.auths, ::protobuf::RepeatedField::new())
    }

    // bytes data = 10;


    pub fn get_data(&self) -> &[u8] {
        &self.data
    }
    pub fn clear_data(&mut self) {
        self.data.clear();
    }

    // Param is passed by value, moved
    pub fn set_data(&mut self, v: ::std::vec::Vec<u8>) {
        self.data = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_data(&mut self) -> &mut ::std::vec::Vec<u8> {
        &mut self.data
    }

    // Take field
    pub fn take_data(&mut self) -> ::std::vec::Vec<u8> {
        ::std::mem::replace(&mut self.data, ::std::vec::Vec::new())
    }

    // repeated .protocol.Transaction.Contract contract = 11;


    pub fn get_contract(&self) -> &[Transaction_Contract] {
        &self.contract
    }
    pub fn clear_contract(&mut self) {
        self.contract.clear();
    }

    // Param is passed by value, moved
    pub fn set_contract(&mut self, v: ::protobuf::RepeatedField<Transaction_Contract>) {
        self.contract = v;
    }

    // Mutable pointer to the field.
    pub fn mut_contract(&mut self) -> &mut ::protobuf::RepeatedField<Transaction_Contract> {
        &mut self.contract
    }

    // Take field
    pub fn take_contract(&mut self) -> ::protobuf::RepeatedField<Transaction_Contract> {
        ::std::mem::replace(&mut self.contract, ::protobuf::RepeatedField::new())
    }

    // bytes scripts = 12;


    pub fn get_scripts(&self) -> &[u8] {
        &self.scripts
    }
    pub fn clear_scripts(&mut self) {
        self.scripts.clear();
    }

    // Param is passed by value, moved
    pub fn set_scripts(&mut self, v: ::std::vec::Vec<u8>) {
        self.scripts = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_scripts(&mut self) -> &mut ::std::vec::Vec<u8> {
        &mut self.scripts
    }

    // Take field
    pub fn take_scripts(&mut self) -> ::std::vec::Vec<u8> {
        ::std::mem::replace(&mut self.scripts, ::std::vec::Vec::new())
    }

    // int64 timestamp = 14;


    pub fn get_timestamp(&self) -> i64 {
        self.timestamp
    }
    pub fn clear_timestamp(&mut self) {
        self.timestamp = 0;
    }

    // Param is passed by value, moved
    pub fn set_timestamp(&mut self, v: i64) {
        self.timestamp = v;
    }

    // int64 fee_limit = 18;


    pub fn get_fee_limit(&self) -> i64 {
        self.fee_limit
    }
    pub fn clear_fee_limit(&mut self) {
        self.fee_limit = 0;
    }

    // Param is passed by value, moved
    pub fn set_fee_limit(&mut self, v: i64) {
        self.fee_limit = v;
    }
}

impl ::protobuf::Message for Transaction_raw {
    fn is_initialized(&self) -> bool {
        for v in &self.auths {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.contract {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_bytes_into(wire_type, is, &mut self.ref_block_bytes)?;
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.ref_block_num = tmp;
                },
                4 => {
                    ::protobuf::rt::read_singular_proto3_bytes_into(wire_type, is, &mut self.ref_block_hash)?;
                },
                8 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.expiration = tmp;
                },
                9 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.auths)?;
                },
                10 => {
                    ::protobuf::rt::read_singular_proto3_bytes_into(wire_type, is, &mut self.data)?;
                },
                11 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.contract)?;
                },
                12 => {
                    ::protobuf::rt::read_singular_proto3_bytes_into(wire_type, is, &mut self.scripts)?;
                },
                14 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.timestamp = tmp;
                },
                18 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.fee_limit = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.ref_block_bytes.is_empty() {
            my_size += ::protobuf::rt::bytes_size(1, &self.ref_block_bytes);
        }
        if self.ref_block_num != 0 {
            my_size += ::protobuf::rt::value_size(3, self.ref_block_num, ::protobuf::wire_format::WireTypeVarint);
        }
        if !self.ref_block_hash.is_empty() {
            my_size += ::protobuf::rt::bytes_size(4, &self.ref_block_hash);
        }
        if self.expiration != 0 {
            my_size += ::protobuf::rt::value_size(8, self.expiration, ::protobuf::wire_format::WireTypeVarint);
        }
        for value in &self.auths {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        if !self.data.is_empty() {
            my_size += ::protobuf::rt::bytes_size(10, &self.data);
        }
        for value in &self.contract {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        if !self.scripts.is_empty() {
            my_size += ::protobuf::rt::bytes_size(12, &self.scripts);
        }
        if self.timestamp != 0 {
            my_size += ::protobuf::rt::value_size(14, self.timestamp, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.fee_limit != 0 {
            my_size += ::protobuf::rt::value_size(18, self.fee_limit, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if !self.ref_block_bytes.is_empty() {
            os.write_bytes(1, &self.ref_block_bytes)?;
        }
        if self.ref_block_num != 0 {
            os.write_int64(3, self.ref_block_num)?;
        }
        if !self.ref_block_hash.is_empty() {
            os.write_bytes(4, &self.ref_block_hash)?;
        }
        if self.expiration != 0 {
            os.write_int64(8, self.expiration)?;
        }
        for v in &self.auths {
            os.write_tag(9, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        if !self.data.is_empty() {
            os.write_bytes(10, &self.data)?;
        }
        for v in &self.contract {
            os.write_tag(11, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        if !self.scripts.is_empty() {
            os.write_bytes(12, &self.scripts)?;
        }
        if self.timestamp != 0 {
            os.write_int64(14, self.timestamp)?;
        }
        if self.fee_limit != 0 {
            os.write_int64(18, self.fee_limit)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> Transaction_raw {
        Transaction_raw::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                    "ref_block_bytes",
                    |m: &Transaction_raw| { &m.ref_block_bytes },
                    |m: &mut Transaction_raw| { &mut m.ref_block_bytes },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                    "ref_block_num",
                    |m: &Transaction_raw| { &m.ref_block_num },
                    |m: &mut Transaction_raw| { &mut m.ref_block_num },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                    "ref_block_hash",
                    |m: &Transaction_raw| { &m.ref_block_hash },
                    |m: &mut Transaction_raw| { &mut m.ref_block_hash },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                    "expiration",
                    |m: &Transaction_raw| { &m.expiration },
                    |m: &mut Transaction_raw| { &mut m.expiration },
                ));
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<authority>>(
                    "auths",
                    |m: &Transaction_raw| { &m.auths },
                    |m: &mut Transaction_raw| { &mut m.auths },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                    "data",
                    |m: &Transaction_raw| { &m.data },
                    |m: &mut Transaction_raw| { &mut m.data },
                ));
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Transaction_Contract>>(
                    "contract",
                    |m: &Transaction_raw| { &m.contract },
                    |m: &mut Transaction_raw| { &mut m.contract },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                    "scripts",
                    |m: &Transaction_raw| { &m.scripts },
                    |m: &mut Transaction_raw| { &mut m.scripts },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                    "timestamp",
                    |m: &Transaction_raw| { &m.timestamp },
                    |m: &mut Transaction_raw| { &mut m.timestamp },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                    "fee_limit",
                    |m: &Transaction_raw| { &m.fee_limit },
                    |m: &mut Transaction_raw| { &mut m.fee_limit },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<Transaction_raw>(
                    "Transaction_raw",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static Transaction_raw {
        static mut instance: ::protobuf::lazy::Lazy<Transaction_raw> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const Transaction_raw,
        };
        unsafe {
            instance.get(Transaction_raw::new)
        }
    }
}

impl ::protobuf::Clear for Transaction_raw {
    fn clear(&mut self) {
        self.ref_block_bytes.clear();
        self.ref_block_num = 0;
        self.ref_block_hash.clear();
        self.expiration = 0;
        self.auths.clear();
        self.data.clear();
        self.contract.clear();
        self.scripts.clear();
        self.timestamp = 0;
        self.fee_limit = 0;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for Transaction_raw {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Transaction_raw {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct TransactionInfo {
    // message fields
    pub id: ::std::vec::Vec<u8>,
    pub fee: i64,
    pub blockNumber: i64,
    pub blockTimeStamp: i64,
    pub contractResult: ::protobuf::RepeatedField<::std::vec::Vec<u8>>,
    pub contract_address: ::std::vec::Vec<u8>,
    pub receipt: ::protobuf::SingularPtrField<ResourceReceipt>,
    pub log: ::protobuf::RepeatedField<TransactionInfo_Log>,
    pub result: TransactionInfo_code,
    pub resMessage: ::std::vec::Vec<u8>,
    pub assetIssueID: ::std::string::String,
    pub withdraw_amount: i64,
    pub unfreeze_amount: i64,
    pub internal_transactions: ::protobuf::RepeatedField<InternalTransaction>,
    pub exchange_received_amount: i64,
    pub exchange_inject_another_amount: i64,
    pub exchange_withdraw_another_amount: i64,
    pub exchange_id: i64,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a TransactionInfo {
    fn default() -> &'a TransactionInfo {
        <TransactionInfo as ::protobuf::Message>::default_instance()
    }
}

impl TransactionInfo {
    pub fn new() -> TransactionInfo {
        ::std::default::Default::default()
    }

    // bytes id = 1;


    pub fn get_id(&self) -> &[u8] {
        &self.id
    }
    pub fn clear_id(&mut self) {
        self.id.clear();
    }

    // Param is passed by value, moved
    pub fn set_id(&mut self, v: ::std::vec::Vec<u8>) {
        self.id = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_id(&mut self) -> &mut ::std::vec::Vec<u8> {
        &mut self.id
    }

    // Take field
    pub fn take_id(&mut self) -> ::std::vec::Vec<u8> {
        ::std::mem::replace(&mut self.id, ::std::vec::Vec::new())
    }

    // int64 fee = 2;


    pub fn get_fee(&self) -> i64 {
        self.fee
    }
    pub fn clear_fee(&mut self) {
        self.fee = 0;
    }

    // Param is passed by value, moved
    pub fn set_fee(&mut self, v: i64) {
        self.fee = v;
    }

    // int64 blockNumber = 3;


    pub fn get_blockNumber(&self) -> i64 {
        self.blockNumber
    }
    pub fn clear_blockNumber(&mut self) {
        self.blockNumber = 0;
    }

    // Param is passed by value, moved
    pub fn set_blockNumber(&mut self, v: i64) {
        self.blockNumber = v;
    }

    // int64 blockTimeStamp = 4;


    pub fn get_blockTimeStamp(&self) -> i64 {
        self.blockTimeStamp
    }
    pub fn clear_blockTimeStamp(&mut self) {
        self.blockTimeStamp = 0;
    }

    // Param is passed by value, moved
    pub fn set_blockTimeStamp(&mut self, v: i64) {
        self.blockTimeStamp = v;
    }

    // repeated bytes contractResult = 5;


    pub fn get_contractResult(&self) -> &[::std::vec::Vec<u8>] {
        &self.contractResult
    }
    pub fn clear_contractResult(&mut self) {
        self.contractResult.clear();
    }

    // Param is passed by value, moved
    pub fn set_contractResult(&mut self, v: ::protobuf::RepeatedField<::std::vec::Vec<u8>>) {
        self.contractResult = v;
    }

    // Mutable pointer to the field.
    pub fn mut_contractResult(&mut self) -> &mut ::protobuf::RepeatedField<::std::vec::Vec<u8>> {
        &mut self.contractResult
    }

    // Take field
    pub fn take_contractResult(&mut self) -> ::protobuf::RepeatedField<::std::vec::Vec<u8>> {
        ::std::mem::replace(&mut self.contractResult, ::protobuf::RepeatedField::new())
    }

    // bytes contract_address = 6;


    pub fn get_contract_address(&self) -> &[u8] {
        &self.contract_address
    }
    pub fn clear_contract_address(&mut self) {
        self.contract_address.clear();
    }

    // Param is passed by value, moved
    pub fn set_contract_address(&mut self, v: ::std::vec::Vec<u8>) {
        self.contract_address = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_contract_address(&mut self) -> &mut ::std::vec::Vec<u8> {
        &mut self.contract_address
    }

    // Take field
    pub fn take_contract_address(&mut self) -> ::std::vec::Vec<u8> {
        ::std::mem::replace(&mut self.contract_address, ::std::vec::Vec::new())
    }

    // .protocol.ResourceReceipt receipt = 7;


    pub fn get_receipt(&self) -> &ResourceReceipt {
        self.receipt.as_ref().unwrap_or_else(|| ResourceReceipt::default_instance())
    }
    pub fn clear_receipt(&mut self) {
        self.receipt.clear();
    }

    pub fn has_receipt(&self) -> bool {
        self.receipt.is_some()
    }

    // Param is passed by value, moved
    pub fn set_receipt(&mut self, v: ResourceReceipt) {
        self.receipt = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_receipt(&mut self) -> &mut ResourceReceipt {
        if self.receipt.is_none() {
            self.receipt.set_default();
        }
        self.receipt.as_mut().unwrap()
    }

    // Take field
    pub fn take_receipt(&mut self) -> ResourceReceipt {
        self.receipt.take().unwrap_or_else(|| ResourceReceipt::new())
    }

    // repeated .protocol.TransactionInfo.Log log = 8;


    pub fn get_log(&self) -> &[TransactionInfo_Log] {
        &self.log
    }
    pub fn clear_log(&mut self) {
        self.log.clear();
    }

    // Param is passed by value, moved
    pub fn set_log(&mut self, v: ::protobuf::RepeatedField<TransactionInfo_Log>) {
        self.log = v;
    }

    // Mutable pointer to the field.
    pub fn mut_log(&mut self) -> &mut ::protobuf::RepeatedField<TransactionInfo_Log> {
        &mut self.log
    }

    // Take field
    pub fn take_log(&mut self) -> ::protobuf::RepeatedField<TransactionInfo_Log> {
        ::std::mem::replace(&mut self.log, ::protobuf::RepeatedField::new())
    }

    // .protocol.TransactionInfo.code result = 9;


    pub fn get_result(&self) -> TransactionInfo_code {
        self.result
    }
    pub fn clear_result(&mut self) {
        self.result = TransactionInfo_code::SUCESS;
    }

    // Param is passed by value, moved
    pub fn set_result(&mut self, v: TransactionInfo_code) {
        self.result = v;
    }

    // bytes resMessage = 10;


    pub fn get_resMessage(&self) -> &[u8] {
        &self.resMessage
    }
    pub fn clear_resMessage(&mut self) {
        self.resMessage.clear();
    }

    // Param is passed by value, moved
    pub fn set_resMessage(&mut self, v: ::std::vec::Vec<u8>) {
        self.resMessage = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_resMessage(&mut self) -> &mut ::std::vec::Vec<u8> {
        &mut self.resMessage
    }

    // Take field
    pub fn take_resMessage(&mut self) -> ::std::vec::Vec<u8> {
        ::std::mem::replace(&mut self.resMessage, ::std::vec::Vec::new())
    }

    // string assetIssueID = 14;


    pub fn get_assetIssueID(&self) -> &str {
        &self.assetIssueID
    }
    pub fn clear_assetIssueID(&mut self) {
        self.assetIssueID.clear();
    }

    // Param is passed by value, moved
    pub fn set_assetIssueID(&mut self, v: ::std::string::String) {
        self.assetIssueID = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_assetIssueID(&mut self) -> &mut ::std::string::String {
        &mut self.assetIssueID
    }

    // Take field
    pub fn take_assetIssueID(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.assetIssueID, ::std::string::String::new())
    }

    // int64 withdraw_amount = 15;


    pub fn get_withdraw_amount(&self) -> i64 {
        self.withdraw_amount
    }
    pub fn clear_withdraw_amount(&mut self) {
        self.withdraw_amount = 0;
    }

    // Param is passed by value, moved
    pub fn set_withdraw_amount(&mut self, v: i64) {
        self.withdraw_amount = v;
    }

    // int64 unfreeze_amount = 16;


    pub fn get_unfreeze_amount(&self) -> i64 {
        self.unfreeze_amount
    }
    pub fn clear_unfreeze_amount(&mut self) {
        self.unfreeze_amount = 0;
    }

    // Param is passed by value, moved
    pub fn set_unfreeze_amount(&mut self, v: i64) {
        self.unfreeze_amount = v;
    }

    // repeated .protocol.InternalTransaction internal_transactions = 17;


    pub fn get_internal_transactions(&self) -> &[InternalTransaction] {
        &self.internal_transactions
    }
    pub fn clear_internal_transactions(&mut self) {
        self.internal_transactions.clear();
    }

    // Param is passed by value, moved
    pub fn set_internal_transactions(&mut self, v: ::protobuf::RepeatedField<InternalTransaction>) {
        self.internal_transactions = v;
    }

    // Mutable pointer to the field.
    pub fn mut_internal_transactions(&mut self) -> &mut ::protobuf::RepeatedField<InternalTransaction> {
        &mut self.internal_transactions
    }

    // Take field
    pub fn take_internal_transactions(&mut self) -> ::protobuf::RepeatedField<InternalTransaction> {
        ::std::mem::replace(&mut self.internal_transactions, ::protobuf::RepeatedField::new())
    }

    // int64 exchange_received_amount = 18;


    pub fn get_exchange_received_amount(&self) -> i64 {
        self.exchange_received_amount
    }
    pub fn clear_exchange_received_amount(&mut self) {
        self.exchange_received_amount = 0;
    }

    // Param is passed by value, moved
    pub fn set_exchange_received_amount(&mut self, v: i64) {
        self.exchange_received_amount = v;
    }

    // int64 exchange_inject_another_amount = 19;


    pub fn get_exchange_inject_another_amount(&self) -> i64 {
        self.exchange_inject_another_amount
    }
    pub fn clear_exchange_inject_another_amount(&mut self) {
        self.exchange_inject_another_amount = 0;
    }

    // Param is passed by value, moved
    pub fn set_exchange_inject_another_amount(&mut self, v: i64) {
        self.exchange_inject_another_amount = v;
    }

    // int64 exchange_withdraw_another_amount = 20;


    pub fn get_exchange_withdraw_another_amount(&self) -> i64 {
        self.exchange_withdraw_another_amount
    }
    pub fn clear_exchange_withdraw_another_amount(&mut self) {
        self.exchange_withdraw_another_amount = 0;
    }

    // Param is passed by value, moved
    pub fn set_exchange_withdraw_another_amount(&mut self, v: i64) {
        self.exchange_withdraw_another_amount = v;
    }

    // int64 exchange_id = 21;


    pub fn get_exchange_id(&self) -> i64 {
        self.exchange_id
    }
    pub fn clear_exchange_id(&mut self) {
        self.exchange_id = 0;
    }

    // Param is passed by value, moved
    pub fn set_exchange_id(&mut self, v: i64) {
        self.exchange_id = v;
    }
}

impl ::protobuf::Message for TransactionInfo {
    fn is_initialized(&self) -> bool {
        for v in &self.receipt {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.log {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.internal_transactions {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_bytes_into(wire_type, is, &mut self.id)?;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.fee = tmp;
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.blockNumber = tmp;
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.blockTimeStamp = tmp;
                },
                5 => {
                    ::protobuf::rt::read_repeated_bytes_into(wire_type, is, &mut self.contractResult)?;
                },
                6 => {
                    ::protobuf::rt::read_singular_proto3_bytes_into(wire_type, is, &mut self.contract_address)?;
                },
                7 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.receipt)?;
                },
                8 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.log)?;
                },
                9 => {
                    ::protobuf::rt::read_proto3_enum_with_unknown_fields_into(wire_type, is, &mut self.result, 9, &mut self.unknown_fields)?
                },
                10 => {
                    ::protobuf::rt::read_singular_proto3_bytes_into(wire_type, is, &mut self.resMessage)?;
                },
                14 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.assetIssueID)?;
                },
                15 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.withdraw_amount = tmp;
                },
                16 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.unfreeze_amount = tmp;
                },
                17 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.internal_transactions)?;
                },
                18 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.exchange_received_amount = tmp;
                },
                19 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.exchange_inject_another_amount = tmp;
                },
                20 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.exchange_withdraw_another_amount = tmp;
                },
                21 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.exchange_id = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.id.is_empty() {
            my_size += ::protobuf::rt::bytes_size(1, &self.id);
        }
        if self.fee != 0 {
            my_size += ::protobuf::rt::value_size(2, self.fee, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.blockNumber != 0 {
            my_size += ::protobuf::rt::value_size(3, self.blockNumber, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.blockTimeStamp != 0 {
            my_size += ::protobuf::rt::value_size(4, self.blockTimeStamp, ::protobuf::wire_format::WireTypeVarint);
        }
        for value in &self.contractResult {
            my_size += ::protobuf::rt::bytes_size(5, &value);
        };
        if !self.contract_address.is_empty() {
            my_size += ::protobuf::rt::bytes_size(6, &self.contract_address);
        }
        if let Some(ref v) = self.receipt.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        for value in &self.log {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        if self.result != TransactionInfo_code::SUCESS {
            my_size += ::protobuf::rt::enum_size(9, self.result);
        }
        if !self.resMessage.is_empty() {
            my_size += ::protobuf::rt::bytes_size(10, &self.resMessage);
        }
        if !self.assetIssueID.is_empty() {
            my_size += ::protobuf::rt::string_size(14, &self.assetIssueID);
        }
        if self.withdraw_amount != 0 {
            my_size += ::protobuf::rt::value_size(15, self.withdraw_amount, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.unfreeze_amount != 0 {
            my_size += ::protobuf::rt::value_size(16, self.unfreeze_amount, ::protobuf::wire_format::WireTypeVarint);
        }
        for value in &self.internal_transactions {
            let len = value.compute_size();
            my_size += 2 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        if self.exchange_received_amount != 0 {
            my_size += ::protobuf::rt::value_size(18, self.exchange_received_amount, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.exchange_inject_another_amount != 0 {
            my_size += ::protobuf::rt::value_size(19, self.exchange_inject_another_amount, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.exchange_withdraw_another_amount != 0 {
            my_size += ::protobuf::rt::value_size(20, self.exchange_withdraw_another_amount, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.exchange_id != 0 {
            my_size += ::protobuf::rt::value_size(21, self.exchange_id, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if !self.id.is_empty() {
            os.write_bytes(1, &self.id)?;
        }
        if self.fee != 0 {
            os.write_int64(2, self.fee)?;
        }
        if self.blockNumber != 0 {
            os.write_int64(3, self.blockNumber)?;
        }
        if self.blockTimeStamp != 0 {
            os.write_int64(4, self.blockTimeStamp)?;
        }
        for v in &self.contractResult {
            os.write_bytes(5, &v)?;
        };
        if !self.contract_address.is_empty() {
            os.write_bytes(6, &self.contract_address)?;
        }
        if let Some(ref v) = self.receipt.as_ref() {
            os.write_tag(7, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        for v in &self.log {
            os.write_tag(8, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        if self.result != TransactionInfo_code::SUCESS {
            os.write_enum(9, self.result.value())?;
        }
        if !self.resMessage.is_empty() {
            os.write_bytes(10, &self.resMessage)?;
        }
        if !self.assetIssueID.is_empty() {
            os.write_string(14, &self.assetIssueID)?;
        }
        if self.withdraw_amount != 0 {
            os.write_int64(15, self.withdraw_amount)?;
        }
        if self.unfreeze_amount != 0 {
            os.write_int64(16, self.unfreeze_amount)?;
        }
        for v in &self.internal_transactions {
            os.write_tag(17, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        if self.exchange_received_amount != 0 {
            os.write_int64(18, self.exchange_received_amount)?;
        }
        if self.exchange_inject_another_amount != 0 {
            os.write_int64(19, self.exchange_inject_another_amount)?;
        }
        if self.exchange_withdraw_another_amount != 0 {
            os.write_int64(20, self.exchange_withdraw_another_amount)?;
        }
        if self.exchange_id != 0 {
            os.write_int64(21, self.exchange_id)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> TransactionInfo {
        TransactionInfo::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                    "id",
                    |m: &TransactionInfo| { &m.id },
                    |m: &mut TransactionInfo| { &mut m.id },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                    "fee",
                    |m: &TransactionInfo| { &m.fee },
                    |m: &mut TransactionInfo| { &mut m.fee },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                    "blockNumber",
                    |m: &TransactionInfo| { &m.blockNumber },
                    |m: &mut TransactionInfo| { &mut m.blockNumber },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                    "blockTimeStamp",
                    |m: &TransactionInfo| { &m.blockTimeStamp },
                    |m: &mut TransactionInfo| { &mut m.blockTimeStamp },
                ));
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                    "contractResult",
                    |m: &TransactionInfo| { &m.contractResult },
                    |m: &mut TransactionInfo| { &mut m.contractResult },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                    "contract_address",
                    |m: &TransactionInfo| { &m.contract_address },
                    |m: &mut TransactionInfo| { &mut m.contract_address },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<ResourceReceipt>>(
                    "receipt",
                    |m: &TransactionInfo| { &m.receipt },
                    |m: &mut TransactionInfo| { &mut m.receipt },
                ));
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<TransactionInfo_Log>>(
                    "log",
                    |m: &TransactionInfo| { &m.log },
                    |m: &mut TransactionInfo| { &mut m.log },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeEnum<TransactionInfo_code>>(
                    "result",
                    |m: &TransactionInfo| { &m.result },
                    |m: &mut TransactionInfo| { &mut m.result },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                    "resMessage",
                    |m: &TransactionInfo| { &m.resMessage },
                    |m: &mut TransactionInfo| { &mut m.resMessage },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "assetIssueID",
                    |m: &TransactionInfo| { &m.assetIssueID },
                    |m: &mut TransactionInfo| { &mut m.assetIssueID },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                    "withdraw_amount",
                    |m: &TransactionInfo| { &m.withdraw_amount },
                    |m: &mut TransactionInfo| { &mut m.withdraw_amount },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                    "unfreeze_amount",
                    |m: &TransactionInfo| { &m.unfreeze_amount },
                    |m: &mut TransactionInfo| { &mut m.unfreeze_amount },
                ));
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<InternalTransaction>>(
                    "internal_transactions",
                    |m: &TransactionInfo| { &m.internal_transactions },
                    |m: &mut TransactionInfo| { &mut m.internal_transactions },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                    "exchange_received_amount",
                    |m: &TransactionInfo| { &m.exchange_received_amount },
                    |m: &mut TransactionInfo| { &mut m.exchange_received_amount },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                    "exchange_inject_another_amount",
                    |m: &TransactionInfo| { &m.exchange_inject_another_amount },
                    |m: &mut TransactionInfo| { &mut m.exchange_inject_another_amount },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                    "exchange_withdraw_another_amount",
                    |m: &TransactionInfo| { &m.exchange_withdraw_another_amount },
                    |m: &mut TransactionInfo| { &mut m.exchange_withdraw_another_amount },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                    "exchange_id",
                    |m: &TransactionInfo| { &m.exchange_id },
                    |m: &mut TransactionInfo| { &mut m.exchange_id },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<TransactionInfo>(
                    "TransactionInfo",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static TransactionInfo {
        static mut instance: ::protobuf::lazy::Lazy<TransactionInfo> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const TransactionInfo,
        };
        unsafe {
            instance.get(TransactionInfo::new)
        }
    }
}

impl ::protobuf::Clear for TransactionInfo {
    fn clear(&mut self) {
        self.id.clear();
        self.fee = 0;
        self.blockNumber = 0;
        self.blockTimeStamp = 0;
        self.contractResult.clear();
        self.contract_address.clear();
        self.receipt.clear();
        self.log.clear();
        self.result = TransactionInfo_code::SUCESS;
        self.resMessage.clear();
        self.assetIssueID.clear();
        self.withdraw_amount = 0;
        self.unfreeze_amount = 0;
        self.internal_transactions.clear();
        self.exchange_received_amount = 0;
        self.exchange_inject_another_amount = 0;
        self.exchange_withdraw_another_amount = 0;
        self.exchange_id = 0;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for TransactionInfo {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for TransactionInfo {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct TransactionInfo_Log {
    // message fields
    pub address: ::std::vec::Vec<u8>,
    pub topics: ::protobuf::RepeatedField<::std::vec::Vec<u8>>,
    pub data: ::std::vec::Vec<u8>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a TransactionInfo_Log {
    fn default() -> &'a TransactionInfo_Log {
        <TransactionInfo_Log as ::protobuf::Message>::default_instance()
    }
}

impl TransactionInfo_Log {
    pub fn new() -> TransactionInfo_Log {
        ::std::default::Default::default()
    }

    // bytes address = 1;


    pub fn get_address(&self) -> &[u8] {
        &self.address
    }
    pub fn clear_address(&mut self) {
        self.address.clear();
    }

    // Param is passed by value, moved
    pub fn set_address(&mut self, v: ::std::vec::Vec<u8>) {
        self.address = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_address(&mut self) -> &mut ::std::vec::Vec<u8> {
        &mut self.address
    }

    // Take field
    pub fn take_address(&mut self) -> ::std::vec::Vec<u8> {
        ::std::mem::replace(&mut self.address, ::std::vec::Vec::new())
    }

    // repeated bytes topics = 2;


    pub fn get_topics(&self) -> &[::std::vec::Vec<u8>] {
        &self.topics
    }
    pub fn clear_topics(&mut self) {
        self.topics.clear();
    }

    // Param is passed by value, moved
    pub fn set_topics(&mut self, v: ::protobuf::RepeatedField<::std::vec::Vec<u8>>) {
        self.topics = v;
    }

    // Mutable pointer to the field.
    pub fn mut_topics(&mut self) -> &mut ::protobuf::RepeatedField<::std::vec::Vec<u8>> {
        &mut self.topics
    }

    // Take field
    pub fn take_topics(&mut self) -> ::protobuf::RepeatedField<::std::vec::Vec<u8>> {
        ::std::mem::replace(&mut self.topics, ::protobuf::RepeatedField::new())
    }

    // bytes data = 3;


    pub fn get_data(&self) -> &[u8] {
        &self.data
    }
    pub fn clear_data(&mut self) {
        self.data.clear();
    }

    // Param is passed by value, moved
    pub fn set_data(&mut self, v: ::std::vec::Vec<u8>) {
        self.data = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_data(&mut self) -> &mut ::std::vec::Vec<u8> {
        &mut self.data
    }

    // Take field
    pub fn take_data(&mut self) -> ::std::vec::Vec<u8> {
        ::std::mem::replace(&mut self.data, ::std::vec::Vec::new())
    }
}

impl ::protobuf::Message for TransactionInfo_Log {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_bytes_into(wire_type, is, &mut self.address)?;
                },
                2 => {
                    ::protobuf::rt::read_repeated_bytes_into(wire_type, is, &mut self.topics)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_proto3_bytes_into(wire_type, is, &mut self.data)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.address.is_empty() {
            my_size += ::protobuf::rt::bytes_size(1, &self.address);
        }
        for value in &self.topics {
            my_size += ::protobuf::rt::bytes_size(2, &value);
        };
        if !self.data.is_empty() {
            my_size += ::protobuf::rt::bytes_size(3, &self.data);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if !self.address.is_empty() {
            os.write_bytes(1, &self.address)?;
        }
        for v in &self.topics {
            os.write_bytes(2, &v)?;
        };
        if !self.data.is_empty() {
            os.write_bytes(3, &self.data)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> TransactionInfo_Log {
        TransactionInfo_Log::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                    "address",
                    |m: &TransactionInfo_Log| { &m.address },
                    |m: &mut TransactionInfo_Log| { &mut m.address },
                ));
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                    "topics",
                    |m: &TransactionInfo_Log| { &m.topics },
                    |m: &mut TransactionInfo_Log| { &mut m.topics },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                    "data",
                    |m: &TransactionInfo_Log| { &m.data },
                    |m: &mut TransactionInfo_Log| { &mut m.data },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<TransactionInfo_Log>(
                    "TransactionInfo_Log",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static TransactionInfo_Log {
        static mut instance: ::protobuf::lazy::Lazy<TransactionInfo_Log> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const TransactionInfo_Log,
        };
        unsafe {
            instance.get(TransactionInfo_Log::new)
        }
    }
}

impl ::protobuf::Clear for TransactionInfo_Log {
    fn clear(&mut self) {
        self.address.clear();
        self.topics.clear();
        self.data.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for TransactionInfo_Log {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for TransactionInfo_Log {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(Clone,PartialEq,Eq,Debug,Hash)]
pub enum TransactionInfo_code {
    SUCESS = 0,
    FAILED = 1,
}

impl ::protobuf::ProtobufEnum for TransactionInfo_code {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<TransactionInfo_code> {
        match value {
            0 => ::std::option::Option::Some(TransactionInfo_code::SUCESS),
            1 => ::std::option::Option::Some(TransactionInfo_code::FAILED),
            _ => ::std::option::Option::None
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [TransactionInfo_code] = &[
            TransactionInfo_code::SUCESS,
            TransactionInfo_code::FAILED,
        ];
        values
    }

    fn enum_descriptor_static() -> &'static ::protobuf::reflect::EnumDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::EnumDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                ::protobuf::reflect::EnumDescriptor::new("TransactionInfo_code", file_descriptor_proto())
            })
        }
    }
}

impl ::std::marker::Copy for TransactionInfo_code {
}

impl ::std::default::Default for TransactionInfo_code {
    fn default() -> Self {
        TransactionInfo_code::SUCESS
    }
}

impl ::protobuf::reflect::ProtobufValue for TransactionInfo_code {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Enum(self.descriptor())
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct TransactionRet {
    // message fields
    pub blockNumber: i64,
    pub blockTimeStamp: i64,
    pub transactioninfo: ::protobuf::RepeatedField<TransactionInfo>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a TransactionRet {
    fn default() -> &'a TransactionRet {
        <TransactionRet as ::protobuf::Message>::default_instance()
    }
}

impl TransactionRet {
    pub fn new() -> TransactionRet {
        ::std::default::Default::default()
    }

    // int64 blockNumber = 1;


    pub fn get_blockNumber(&self) -> i64 {
        self.blockNumber
    }
    pub fn clear_blockNumber(&mut self) {
        self.blockNumber = 0;
    }

    // Param is passed by value, moved
    pub fn set_blockNumber(&mut self, v: i64) {
        self.blockNumber = v;
    }

    // int64 blockTimeStamp = 2;


    pub fn get_blockTimeStamp(&self) -> i64 {
        self.blockTimeStamp
    }
    pub fn clear_blockTimeStamp(&mut self) {
        self.blockTimeStamp = 0;
    }

    // Param is passed by value, moved
    pub fn set_blockTimeStamp(&mut self, v: i64) {
        self.blockTimeStamp = v;
    }

    // repeated .protocol.TransactionInfo transactioninfo = 3;


    pub fn get_transactioninfo(&self) -> &[TransactionInfo] {
        &self.transactioninfo
    }
    pub fn clear_transactioninfo(&mut self) {
        self.transactioninfo.clear();
    }

    // Param is passed by value, moved
    pub fn set_transactioninfo(&mut self, v: ::protobuf::RepeatedField<TransactionInfo>) {
        self.transactioninfo = v;
    }

    // Mutable pointer to the field.
    pub fn mut_transactioninfo(&mut self) -> &mut ::protobuf::RepeatedField<TransactionInfo> {
        &mut self.transactioninfo
    }

    // Take field
    pub fn take_transactioninfo(&mut self) -> ::protobuf::RepeatedField<TransactionInfo> {
        ::std::mem::replace(&mut self.transactioninfo, ::protobuf::RepeatedField::new())
    }
}

impl ::protobuf::Message for TransactionRet {
    fn is_initialized(&self) -> bool {
        for v in &self.transactioninfo {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.blockNumber = tmp;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.blockTimeStamp = tmp;
                },
                3 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.transactioninfo)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.blockNumber != 0 {
            my_size += ::protobuf::rt::value_size(1, self.blockNumber, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.blockTimeStamp != 0 {
            my_size += ::protobuf::rt::value_size(2, self.blockTimeStamp, ::protobuf::wire_format::WireTypeVarint);
        }
        for value in &self.transactioninfo {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if self.blockNumber != 0 {
            os.write_int64(1, self.blockNumber)?;
        }
        if self.blockTimeStamp != 0 {
            os.write_int64(2, self.blockTimeStamp)?;
        }
        for v in &self.transactioninfo {
            os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> TransactionRet {
        TransactionRet::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                    "blockNumber",
                    |m: &TransactionRet| { &m.blockNumber },
                    |m: &mut TransactionRet| { &mut m.blockNumber },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                    "blockTimeStamp",
                    |m: &TransactionRet| { &m.blockTimeStamp },
                    |m: &mut TransactionRet| { &mut m.blockTimeStamp },
                ));
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<TransactionInfo>>(
                    "transactioninfo",
                    |m: &TransactionRet| { &m.transactioninfo },
                    |m: &mut TransactionRet| { &mut m.transactioninfo },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<TransactionRet>(
                    "TransactionRet",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static TransactionRet {
        static mut instance: ::protobuf::lazy::Lazy<TransactionRet> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const TransactionRet,
        };
        unsafe {
            instance.get(TransactionRet::new)
        }
    }
}

impl ::protobuf::Clear for TransactionRet {
    fn clear(&mut self) {
        self.blockNumber = 0;
        self.blockTimeStamp = 0;
        self.transactioninfo.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for TransactionRet {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for TransactionRet {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct Transactions {
    // message fields
    pub transactions: ::protobuf::RepeatedField<Transaction>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a Transactions {
    fn default() -> &'a Transactions {
        <Transactions as ::protobuf::Message>::default_instance()
    }
}

impl Transactions {
    pub fn new() -> Transactions {
        ::std::default::Default::default()
    }

    // repeated .protocol.Transaction transactions = 1;


    pub fn get_transactions(&self) -> &[Transaction] {
        &self.transactions
    }
    pub fn clear_transactions(&mut self) {
        self.transactions.clear();
    }

    // Param is passed by value, moved
    pub fn set_transactions(&mut self, v: ::protobuf::RepeatedField<Transaction>) {
        self.transactions = v;
    }

    // Mutable pointer to the field.
    pub fn mut_transactions(&mut self) -> &mut ::protobuf::RepeatedField<Transaction> {
        &mut self.transactions
    }

    // Take field
    pub fn take_transactions(&mut self) -> ::protobuf::RepeatedField<Transaction> {
        ::std::mem::replace(&mut self.transactions, ::protobuf::RepeatedField::new())
    }
}

impl ::protobuf::Message for Transactions {
    fn is_initialized(&self) -> bool {
        for v in &self.transactions {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.transactions)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in &self.transactions {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        for v in &self.transactions {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> Transactions {
        Transactions::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Transaction>>(
                    "transactions",
                    |m: &Transactions| { &m.transactions },
                    |m: &mut Transactions| { &mut m.transactions },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<Transactions>(
                    "Transactions",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static Transactions {
        static mut instance: ::protobuf::lazy::Lazy<Transactions> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const Transactions,
        };
        unsafe {
            instance.get(Transactions::new)
        }
    }
}

impl ::protobuf::Clear for Transactions {
    fn clear(&mut self) {
        self.transactions.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for Transactions {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Transactions {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct TransactionSign {
    // message fields
    pub transaction: ::protobuf::SingularPtrField<Transaction>,
    pub privateKey: ::std::vec::Vec<u8>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a TransactionSign {
    fn default() -> &'a TransactionSign {
        <TransactionSign as ::protobuf::Message>::default_instance()
    }
}

impl TransactionSign {
    pub fn new() -> TransactionSign {
        ::std::default::Default::default()
    }

    // .protocol.Transaction transaction = 1;


    pub fn get_transaction(&self) -> &Transaction {
        self.transaction.as_ref().unwrap_or_else(|| Transaction::default_instance())
    }
    pub fn clear_transaction(&mut self) {
        self.transaction.clear();
    }

    pub fn has_transaction(&self) -> bool {
        self.transaction.is_some()
    }

    // Param is passed by value, moved
    pub fn set_transaction(&mut self, v: Transaction) {
        self.transaction = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_transaction(&mut self) -> &mut Transaction {
        if self.transaction.is_none() {
            self.transaction.set_default();
        }
        self.transaction.as_mut().unwrap()
    }

    // Take field
    pub fn take_transaction(&mut self) -> Transaction {
        self.transaction.take().unwrap_or_else(|| Transaction::new())
    }

    // bytes privateKey = 2;


    pub fn get_privateKey(&self) -> &[u8] {
        &self.privateKey
    }
    pub fn clear_privateKey(&mut self) {
        self.privateKey.clear();
    }

    // Param is passed by value, moved
    pub fn set_privateKey(&mut self, v: ::std::vec::Vec<u8>) {
        self.privateKey = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_privateKey(&mut self) -> &mut ::std::vec::Vec<u8> {
        &mut self.privateKey
    }

    // Take field
    pub fn take_privateKey(&mut self) -> ::std::vec::Vec<u8> {
        ::std::mem::replace(&mut self.privateKey, ::std::vec::Vec::new())
    }
}

impl ::protobuf::Message for TransactionSign {
    fn is_initialized(&self) -> bool {
        for v in &self.transaction {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.transaction)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_bytes_into(wire_type, is, &mut self.privateKey)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.transaction.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if !self.privateKey.is_empty() {
            my_size += ::protobuf::rt::bytes_size(2, &self.privateKey);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.transaction.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if !self.privateKey.is_empty() {
            os.write_bytes(2, &self.privateKey)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> TransactionSign {
        TransactionSign::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Transaction>>(
                    "transaction",
                    |m: &TransactionSign| { &m.transaction },
                    |m: &mut TransactionSign| { &mut m.transaction },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                    "privateKey",
                    |m: &TransactionSign| { &m.privateKey },
                    |m: &mut TransactionSign| { &mut m.privateKey },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<TransactionSign>(
                    "TransactionSign",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static TransactionSign {
        static mut instance: ::protobuf::lazy::Lazy<TransactionSign> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const TransactionSign,
        };
        unsafe {
            instance.get(TransactionSign::new)
        }
    }
}

impl ::protobuf::Clear for TransactionSign {
    fn clear(&mut self) {
        self.transaction.clear();
        self.privateKey.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for TransactionSign {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for TransactionSign {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct BlockHeader {
    // message fields
    pub raw_data: ::protobuf::SingularPtrField<BlockHeader_raw>,
    pub witness_signature: ::std::vec::Vec<u8>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a BlockHeader {
    fn default() -> &'a BlockHeader {
        <BlockHeader as ::protobuf::Message>::default_instance()
    }
}

impl BlockHeader {
    pub fn new() -> BlockHeader {
        ::std::default::Default::default()
    }

    // .protocol.BlockHeader.raw raw_data = 1;


    pub fn get_raw_data(&self) -> &BlockHeader_raw {
        self.raw_data.as_ref().unwrap_or_else(|| BlockHeader_raw::default_instance())
    }
    pub fn clear_raw_data(&mut self) {
        self.raw_data.clear();
    }

    pub fn has_raw_data(&self) -> bool {
        self.raw_data.is_some()
    }

    // Param is passed by value, moved
    pub fn set_raw_data(&mut self, v: BlockHeader_raw) {
        self.raw_data = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_raw_data(&mut self) -> &mut BlockHeader_raw {
        if self.raw_data.is_none() {
            self.raw_data.set_default();
        }
        self.raw_data.as_mut().unwrap()
    }

    // Take field
    pub fn take_raw_data(&mut self) -> BlockHeader_raw {
        self.raw_data.take().unwrap_or_else(|| BlockHeader_raw::new())
    }

    // bytes witness_signature = 2;


    pub fn get_witness_signature(&self) -> &[u8] {
        &self.witness_signature
    }
    pub fn clear_witness_signature(&mut self) {
        self.witness_signature.clear();
    }

    // Param is passed by value, moved
    pub fn set_witness_signature(&mut self, v: ::std::vec::Vec<u8>) {
        self.witness_signature = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_witness_signature(&mut self) -> &mut ::std::vec::Vec<u8> {
        &mut self.witness_signature
    }

    // Take field
    pub fn take_witness_signature(&mut self) -> ::std::vec::Vec<u8> {
        ::std::mem::replace(&mut self.witness_signature, ::std::vec::Vec::new())
    }
}

impl ::protobuf::Message for BlockHeader {
    fn is_initialized(&self) -> bool {
        for v in &self.raw_data {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.raw_data)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_bytes_into(wire_type, is, &mut self.witness_signature)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.raw_data.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if !self.witness_signature.is_empty() {
            my_size += ::protobuf::rt::bytes_size(2, &self.witness_signature);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.raw_data.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if !self.witness_signature.is_empty() {
            os.write_bytes(2, &self.witness_signature)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> BlockHeader {
        BlockHeader::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<BlockHeader_raw>>(
                    "raw_data",
                    |m: &BlockHeader| { &m.raw_data },
                    |m: &mut BlockHeader| { &mut m.raw_data },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                    "witness_signature",
                    |m: &BlockHeader| { &m.witness_signature },
                    |m: &mut BlockHeader| { &mut m.witness_signature },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<BlockHeader>(
                    "BlockHeader",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static BlockHeader {
        static mut instance: ::protobuf::lazy::Lazy<BlockHeader> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const BlockHeader,
        };
        unsafe {
            instance.get(BlockHeader::new)
        }
    }
}

impl ::protobuf::Clear for BlockHeader {
    fn clear(&mut self) {
        self.raw_data.clear();
        self.witness_signature.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for BlockHeader {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for BlockHeader {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct BlockHeader_raw {
    // message fields
    pub timestamp: i64,
    pub txTrieRoot: ::std::vec::Vec<u8>,
    pub parentHash: ::std::vec::Vec<u8>,
    pub number: i64,
    pub witness_id: i64,
    pub witness_address: ::std::vec::Vec<u8>,
    pub version: i32,
    pub accountStateRoot: ::std::vec::Vec<u8>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a BlockHeader_raw {
    fn default() -> &'a BlockHeader_raw {
        <BlockHeader_raw as ::protobuf::Message>::default_instance()
    }
}

impl BlockHeader_raw {
    pub fn new() -> BlockHeader_raw {
        ::std::default::Default::default()
    }

    // int64 timestamp = 1;


    pub fn get_timestamp(&self) -> i64 {
        self.timestamp
    }
    pub fn clear_timestamp(&mut self) {
        self.timestamp = 0;
    }

    // Param is passed by value, moved
    pub fn set_timestamp(&mut self, v: i64) {
        self.timestamp = v;
    }

    // bytes txTrieRoot = 2;


    pub fn get_txTrieRoot(&self) -> &[u8] {
        &self.txTrieRoot
    }
    pub fn clear_txTrieRoot(&mut self) {
        self.txTrieRoot.clear();
    }

    // Param is passed by value, moved
    pub fn set_txTrieRoot(&mut self, v: ::std::vec::Vec<u8>) {
        self.txTrieRoot = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_txTrieRoot(&mut self) -> &mut ::std::vec::Vec<u8> {
        &mut self.txTrieRoot
    }

    // Take field
    pub fn take_txTrieRoot(&mut self) -> ::std::vec::Vec<u8> {
        ::std::mem::replace(&mut self.txTrieRoot, ::std::vec::Vec::new())
    }

    // bytes parentHash = 3;


    pub fn get_parentHash(&self) -> &[u8] {
        &self.parentHash
    }
    pub fn clear_parentHash(&mut self) {
        self.parentHash.clear();
    }

    // Param is passed by value, moved
    pub fn set_parentHash(&mut self, v: ::std::vec::Vec<u8>) {
        self.parentHash = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_parentHash(&mut self) -> &mut ::std::vec::Vec<u8> {
        &mut self.parentHash
    }

    // Take field
    pub fn take_parentHash(&mut self) -> ::std::vec::Vec<u8> {
        ::std::mem::replace(&mut self.parentHash, ::std::vec::Vec::new())
    }

    // int64 number = 7;


    pub fn get_number(&self) -> i64 {
        self.number
    }
    pub fn clear_number(&mut self) {
        self.number = 0;
    }

    // Param is passed by value, moved
    pub fn set_number(&mut self, v: i64) {
        self.number = v;
    }

    // int64 witness_id = 8;


    pub fn get_witness_id(&self) -> i64 {
        self.witness_id
    }
    pub fn clear_witness_id(&mut self) {
        self.witness_id = 0;
    }

    // Param is passed by value, moved
    pub fn set_witness_id(&mut self, v: i64) {
        self.witness_id = v;
    }

    // bytes witness_address = 9;


    pub fn get_witness_address(&self) -> &[u8] {
        &self.witness_address
    }
    pub fn clear_witness_address(&mut self) {
        self.witness_address.clear();
    }

    // Param is passed by value, moved
    pub fn set_witness_address(&mut self, v: ::std::vec::Vec<u8>) {
        self.witness_address = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_witness_address(&mut self) -> &mut ::std::vec::Vec<u8> {
        &mut self.witness_address
    }

    // Take field
    pub fn take_witness_address(&mut self) -> ::std::vec::Vec<u8> {
        ::std::mem::replace(&mut self.witness_address, ::std::vec::Vec::new())
    }

    // int32 version = 10;


    pub fn get_version(&self) -> i32 {
        self.version
    }
    pub fn clear_version(&mut self) {
        self.version = 0;
    }

    // Param is passed by value, moved
    pub fn set_version(&mut self, v: i32) {
        self.version = v;
    }

    // bytes accountStateRoot = 11;


    pub fn get_accountStateRoot(&self) -> &[u8] {
        &self.accountStateRoot
    }
    pub fn clear_accountStateRoot(&mut self) {
        self.accountStateRoot.clear();
    }

    // Param is passed by value, moved
    pub fn set_accountStateRoot(&mut self, v: ::std::vec::Vec<u8>) {
        self.accountStateRoot = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_accountStateRoot(&mut self) -> &mut ::std::vec::Vec<u8> {
        &mut self.accountStateRoot
    }

    // Take field
    pub fn take_accountStateRoot(&mut self) -> ::std::vec::Vec<u8> {
        ::std::mem::replace(&mut self.accountStateRoot, ::std::vec::Vec::new())
    }
}

impl ::protobuf::Message for BlockHeader_raw {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.timestamp = tmp;
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_bytes_into(wire_type, is, &mut self.txTrieRoot)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_proto3_bytes_into(wire_type, is, &mut self.parentHash)?;
                },
                7 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.number = tmp;
                },
                8 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.witness_id = tmp;
                },
                9 => {
                    ::protobuf::rt::read_singular_proto3_bytes_into(wire_type, is, &mut self.witness_address)?;
                },
                10 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.version = tmp;
                },
                11 => {
                    ::protobuf::rt::read_singular_proto3_bytes_into(wire_type, is, &mut self.accountStateRoot)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.timestamp != 0 {
            my_size += ::protobuf::rt::value_size(1, self.timestamp, ::protobuf::wire_format::WireTypeVarint);
        }
        if !self.txTrieRoot.is_empty() {
            my_size += ::protobuf::rt::bytes_size(2, &self.txTrieRoot);
        }
        if !self.parentHash.is_empty() {
            my_size += ::protobuf::rt::bytes_size(3, &self.parentHash);
        }
        if self.number != 0 {
            my_size += ::protobuf::rt::value_size(7, self.number, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.witness_id != 0 {
            my_size += ::protobuf::rt::value_size(8, self.witness_id, ::protobuf::wire_format::WireTypeVarint);
        }
        if !self.witness_address.is_empty() {
            my_size += ::protobuf::rt::bytes_size(9, &self.witness_address);
        }
        if self.version != 0 {
            my_size += ::protobuf::rt::value_size(10, self.version, ::protobuf::wire_format::WireTypeVarint);
        }
        if !self.accountStateRoot.is_empty() {
            my_size += ::protobuf::rt::bytes_size(11, &self.accountStateRoot);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if self.timestamp != 0 {
            os.write_int64(1, self.timestamp)?;
        }
        if !self.txTrieRoot.is_empty() {
            os.write_bytes(2, &self.txTrieRoot)?;
        }
        if !self.parentHash.is_empty() {
            os.write_bytes(3, &self.parentHash)?;
        }
        if self.number != 0 {
            os.write_int64(7, self.number)?;
        }
        if self.witness_id != 0 {
            os.write_int64(8, self.witness_id)?;
        }
        if !self.witness_address.is_empty() {
            os.write_bytes(9, &self.witness_address)?;
        }
        if self.version != 0 {
            os.write_int32(10, self.version)?;
        }
        if !self.accountStateRoot.is_empty() {
            os.write_bytes(11, &self.accountStateRoot)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> BlockHeader_raw {
        BlockHeader_raw::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                    "timestamp",
                    |m: &BlockHeader_raw| { &m.timestamp },
                    |m: &mut BlockHeader_raw| { &mut m.timestamp },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                    "txTrieRoot",
                    |m: &BlockHeader_raw| { &m.txTrieRoot },
                    |m: &mut BlockHeader_raw| { &mut m.txTrieRoot },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                    "parentHash",
                    |m: &BlockHeader_raw| { &m.parentHash },
                    |m: &mut BlockHeader_raw| { &mut m.parentHash },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                    "number",
                    |m: &BlockHeader_raw| { &m.number },
                    |m: &mut BlockHeader_raw| { &mut m.number },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                    "witness_id",
                    |m: &BlockHeader_raw| { &m.witness_id },
                    |m: &mut BlockHeader_raw| { &mut m.witness_id },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                    "witness_address",
                    |m: &BlockHeader_raw| { &m.witness_address },
                    |m: &mut BlockHeader_raw| { &mut m.witness_address },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                    "version",
                    |m: &BlockHeader_raw| { &m.version },
                    |m: &mut BlockHeader_raw| { &mut m.version },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                    "accountStateRoot",
                    |m: &BlockHeader_raw| { &m.accountStateRoot },
                    |m: &mut BlockHeader_raw| { &mut m.accountStateRoot },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<BlockHeader_raw>(
                    "BlockHeader_raw",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static BlockHeader_raw {
        static mut instance: ::protobuf::lazy::Lazy<BlockHeader_raw> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const BlockHeader_raw,
        };
        unsafe {
            instance.get(BlockHeader_raw::new)
        }
    }
}

impl ::protobuf::Clear for BlockHeader_raw {
    fn clear(&mut self) {
        self.timestamp = 0;
        self.txTrieRoot.clear();
        self.parentHash.clear();
        self.number = 0;
        self.witness_id = 0;
        self.witness_address.clear();
        self.version = 0;
        self.accountStateRoot.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for BlockHeader_raw {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for BlockHeader_raw {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct Block {
    // message fields
    pub transactions: ::protobuf::RepeatedField<Transaction>,
    pub block_header: ::protobuf::SingularPtrField<BlockHeader>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a Block {
    fn default() -> &'a Block {
        <Block as ::protobuf::Message>::default_instance()
    }
}

impl Block {
    pub fn new() -> Block {
        ::std::default::Default::default()
    }

    // repeated .protocol.Transaction transactions = 1;


    pub fn get_transactions(&self) -> &[Transaction] {
        &self.transactions
    }
    pub fn clear_transactions(&mut self) {
        self.transactions.clear();
    }

    // Param is passed by value, moved
    pub fn set_transactions(&mut self, v: ::protobuf::RepeatedField<Transaction>) {
        self.transactions = v;
    }

    // Mutable pointer to the field.
    pub fn mut_transactions(&mut self) -> &mut ::protobuf::RepeatedField<Transaction> {
        &mut self.transactions
    }

    // Take field
    pub fn take_transactions(&mut self) -> ::protobuf::RepeatedField<Transaction> {
        ::std::mem::replace(&mut self.transactions, ::protobuf::RepeatedField::new())
    }

    // .protocol.BlockHeader block_header = 2;


    pub fn get_block_header(&self) -> &BlockHeader {
        self.block_header.as_ref().unwrap_or_else(|| BlockHeader::default_instance())
    }
    pub fn clear_block_header(&mut self) {
        self.block_header.clear();
    }

    pub fn has_block_header(&self) -> bool {
        self.block_header.is_some()
    }

    // Param is passed by value, moved
    pub fn set_block_header(&mut self, v: BlockHeader) {
        self.block_header = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_block_header(&mut self) -> &mut BlockHeader {
        if self.block_header.is_none() {
            self.block_header.set_default();
        }
        self.block_header.as_mut().unwrap()
    }

    // Take field
    pub fn take_block_header(&mut self) -> BlockHeader {
        self.block_header.take().unwrap_or_else(|| BlockHeader::new())
    }
}

impl ::protobuf::Message for Block {
    fn is_initialized(&self) -> bool {
        for v in &self.transactions {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.block_header {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.transactions)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.block_header)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in &self.transactions {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        if let Some(ref v) = self.block_header.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        for v in &self.transactions {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        if let Some(ref v) = self.block_header.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> Block {
        Block::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Transaction>>(
                    "transactions",
                    |m: &Block| { &m.transactions },
                    |m: &mut Block| { &mut m.transactions },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<BlockHeader>>(
                    "block_header",
                    |m: &Block| { &m.block_header },
                    |m: &mut Block| { &mut m.block_header },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<Block>(
                    "Block",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static Block {
        static mut instance: ::protobuf::lazy::Lazy<Block> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const Block,
        };
        unsafe {
            instance.get(Block::new)
        }
    }
}

impl ::protobuf::Clear for Block {
    fn clear(&mut self) {
        self.transactions.clear();
        self.block_header.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for Block {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Block {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct ChainInventory {
    // message fields
    pub ids: ::protobuf::RepeatedField<ChainInventory_BlockId>,
    pub remain_num: i64,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a ChainInventory {
    fn default() -> &'a ChainInventory {
        <ChainInventory as ::protobuf::Message>::default_instance()
    }
}

impl ChainInventory {
    pub fn new() -> ChainInventory {
        ::std::default::Default::default()
    }

    // repeated .protocol.ChainInventory.BlockId ids = 1;


    pub fn get_ids(&self) -> &[ChainInventory_BlockId] {
        &self.ids
    }
    pub fn clear_ids(&mut self) {
        self.ids.clear();
    }

    // Param is passed by value, moved
    pub fn set_ids(&mut self, v: ::protobuf::RepeatedField<ChainInventory_BlockId>) {
        self.ids = v;
    }

    // Mutable pointer to the field.
    pub fn mut_ids(&mut self) -> &mut ::protobuf::RepeatedField<ChainInventory_BlockId> {
        &mut self.ids
    }

    // Take field
    pub fn take_ids(&mut self) -> ::protobuf::RepeatedField<ChainInventory_BlockId> {
        ::std::mem::replace(&mut self.ids, ::protobuf::RepeatedField::new())
    }

    // int64 remain_num = 2;


    pub fn get_remain_num(&self) -> i64 {
        self.remain_num
    }
    pub fn clear_remain_num(&mut self) {
        self.remain_num = 0;
    }

    // Param is passed by value, moved
    pub fn set_remain_num(&mut self, v: i64) {
        self.remain_num = v;
    }
}

impl ::protobuf::Message for ChainInventory {
    fn is_initialized(&self) -> bool {
        for v in &self.ids {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.ids)?;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.remain_num = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in &self.ids {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        if self.remain_num != 0 {
            my_size += ::protobuf::rt::value_size(2, self.remain_num, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        for v in &self.ids {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        if self.remain_num != 0 {
            os.write_int64(2, self.remain_num)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> ChainInventory {
        ChainInventory::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<ChainInventory_BlockId>>(
                    "ids",
                    |m: &ChainInventory| { &m.ids },
                    |m: &mut ChainInventory| { &mut m.ids },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                    "remain_num",
                    |m: &ChainInventory| { &m.remain_num },
                    |m: &mut ChainInventory| { &mut m.remain_num },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<ChainInventory>(
                    "ChainInventory",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static ChainInventory {
        static mut instance: ::protobuf::lazy::Lazy<ChainInventory> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ChainInventory,
        };
        unsafe {
            instance.get(ChainInventory::new)
        }
    }
}

impl ::protobuf::Clear for ChainInventory {
    fn clear(&mut self) {
        self.ids.clear();
        self.remain_num = 0;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ChainInventory {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ChainInventory {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct ChainInventory_BlockId {
    // message fields
    pub hash: ::std::vec::Vec<u8>,
    pub number: i64,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a ChainInventory_BlockId {
    fn default() -> &'a ChainInventory_BlockId {
        <ChainInventory_BlockId as ::protobuf::Message>::default_instance()
    }
}

impl ChainInventory_BlockId {
    pub fn new() -> ChainInventory_BlockId {
        ::std::default::Default::default()
    }

    // bytes hash = 1;


    pub fn get_hash(&self) -> &[u8] {
        &self.hash
    }
    pub fn clear_hash(&mut self) {
        self.hash.clear();
    }

    // Param is passed by value, moved
    pub fn set_hash(&mut self, v: ::std::vec::Vec<u8>) {
        self.hash = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_hash(&mut self) -> &mut ::std::vec::Vec<u8> {
        &mut self.hash
    }

    // Take field
    pub fn take_hash(&mut self) -> ::std::vec::Vec<u8> {
        ::std::mem::replace(&mut self.hash, ::std::vec::Vec::new())
    }

    // int64 number = 2;


    pub fn get_number(&self) -> i64 {
        self.number
    }
    pub fn clear_number(&mut self) {
        self.number = 0;
    }

    // Param is passed by value, moved
    pub fn set_number(&mut self, v: i64) {
        self.number = v;
    }
}

impl ::protobuf::Message for ChainInventory_BlockId {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_bytes_into(wire_type, is, &mut self.hash)?;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.number = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.hash.is_empty() {
            my_size += ::protobuf::rt::bytes_size(1, &self.hash);
        }
        if self.number != 0 {
            my_size += ::protobuf::rt::value_size(2, self.number, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if !self.hash.is_empty() {
            os.write_bytes(1, &self.hash)?;
        }
        if self.number != 0 {
            os.write_int64(2, self.number)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> ChainInventory_BlockId {
        ChainInventory_BlockId::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                    "hash",
                    |m: &ChainInventory_BlockId| { &m.hash },
                    |m: &mut ChainInventory_BlockId| { &mut m.hash },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                    "number",
                    |m: &ChainInventory_BlockId| { &m.number },
                    |m: &mut ChainInventory_BlockId| { &mut m.number },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<ChainInventory_BlockId>(
                    "ChainInventory_BlockId",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static ChainInventory_BlockId {
        static mut instance: ::protobuf::lazy::Lazy<ChainInventory_BlockId> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ChainInventory_BlockId,
        };
        unsafe {
            instance.get(ChainInventory_BlockId::new)
        }
    }
}

impl ::protobuf::Clear for ChainInventory_BlockId {
    fn clear(&mut self) {
        self.hash.clear();
        self.number = 0;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ChainInventory_BlockId {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ChainInventory_BlockId {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct BlockInventory {
    // message fields
    pub ids: ::protobuf::RepeatedField<BlockInventory_BlockId>,
    pub field_type: BlockInventory_Type,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a BlockInventory {
    fn default() -> &'a BlockInventory {
        <BlockInventory as ::protobuf::Message>::default_instance()
    }
}

impl BlockInventory {
    pub fn new() -> BlockInventory {
        ::std::default::Default::default()
    }

    // repeated .protocol.BlockInventory.BlockId ids = 1;


    pub fn get_ids(&self) -> &[BlockInventory_BlockId] {
        &self.ids
    }
    pub fn clear_ids(&mut self) {
        self.ids.clear();
    }

    // Param is passed by value, moved
    pub fn set_ids(&mut self, v: ::protobuf::RepeatedField<BlockInventory_BlockId>) {
        self.ids = v;
    }

    // Mutable pointer to the field.
    pub fn mut_ids(&mut self) -> &mut ::protobuf::RepeatedField<BlockInventory_BlockId> {
        &mut self.ids
    }

    // Take field
    pub fn take_ids(&mut self) -> ::protobuf::RepeatedField<BlockInventory_BlockId> {
        ::std::mem::replace(&mut self.ids, ::protobuf::RepeatedField::new())
    }

    // .protocol.BlockInventory.Type type = 2;


    pub fn get_field_type(&self) -> BlockInventory_Type {
        self.field_type
    }
    pub fn clear_field_type(&mut self) {
        self.field_type = BlockInventory_Type::SYNC;
    }

    // Param is passed by value, moved
    pub fn set_field_type(&mut self, v: BlockInventory_Type) {
        self.field_type = v;
    }
}

impl ::protobuf::Message for BlockInventory {
    fn is_initialized(&self) -> bool {
        for v in &self.ids {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.ids)?;
                },
                2 => {
                    ::protobuf::rt::read_proto3_enum_with_unknown_fields_into(wire_type, is, &mut self.field_type, 2, &mut self.unknown_fields)?
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in &self.ids {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        if self.field_type != BlockInventory_Type::SYNC {
            my_size += ::protobuf::rt::enum_size(2, self.field_type);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        for v in &self.ids {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        if self.field_type != BlockInventory_Type::SYNC {
            os.write_enum(2, self.field_type.value())?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> BlockInventory {
        BlockInventory::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<BlockInventory_BlockId>>(
                    "ids",
                    |m: &BlockInventory| { &m.ids },
                    |m: &mut BlockInventory| { &mut m.ids },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeEnum<BlockInventory_Type>>(
                    "type",
                    |m: &BlockInventory| { &m.field_type },
                    |m: &mut BlockInventory| { &mut m.field_type },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<BlockInventory>(
                    "BlockInventory",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static BlockInventory {
        static mut instance: ::protobuf::lazy::Lazy<BlockInventory> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const BlockInventory,
        };
        unsafe {
            instance.get(BlockInventory::new)
        }
    }
}

impl ::protobuf::Clear for BlockInventory {
    fn clear(&mut self) {
        self.ids.clear();
        self.field_type = BlockInventory_Type::SYNC;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for BlockInventory {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for BlockInventory {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct BlockInventory_BlockId {
    // message fields
    pub hash: ::std::vec::Vec<u8>,
    pub number: i64,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a BlockInventory_BlockId {
    fn default() -> &'a BlockInventory_BlockId {
        <BlockInventory_BlockId as ::protobuf::Message>::default_instance()
    }
}

impl BlockInventory_BlockId {
    pub fn new() -> BlockInventory_BlockId {
        ::std::default::Default::default()
    }

    // bytes hash = 1;


    pub fn get_hash(&self) -> &[u8] {
        &self.hash
    }
    pub fn clear_hash(&mut self) {
        self.hash.clear();
    }

    // Param is passed by value, moved
    pub fn set_hash(&mut self, v: ::std::vec::Vec<u8>) {
        self.hash = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_hash(&mut self) -> &mut ::std::vec::Vec<u8> {
        &mut self.hash
    }

    // Take field
    pub fn take_hash(&mut self) -> ::std::vec::Vec<u8> {
        ::std::mem::replace(&mut self.hash, ::std::vec::Vec::new())
    }

    // int64 number = 2;


    pub fn get_number(&self) -> i64 {
        self.number
    }
    pub fn clear_number(&mut self) {
        self.number = 0;
    }

    // Param is passed by value, moved
    pub fn set_number(&mut self, v: i64) {
        self.number = v;
    }
}

impl ::protobuf::Message for BlockInventory_BlockId {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_bytes_into(wire_type, is, &mut self.hash)?;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.number = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.hash.is_empty() {
            my_size += ::protobuf::rt::bytes_size(1, &self.hash);
        }
        if self.number != 0 {
            my_size += ::protobuf::rt::value_size(2, self.number, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if !self.hash.is_empty() {
            os.write_bytes(1, &self.hash)?;
        }
        if self.number != 0 {
            os.write_int64(2, self.number)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> BlockInventory_BlockId {
        BlockInventory_BlockId::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                    "hash",
                    |m: &BlockInventory_BlockId| { &m.hash },
                    |m: &mut BlockInventory_BlockId| { &mut m.hash },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                    "number",
                    |m: &BlockInventory_BlockId| { &m.number },
                    |m: &mut BlockInventory_BlockId| { &mut m.number },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<BlockInventory_BlockId>(
                    "BlockInventory_BlockId",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static BlockInventory_BlockId {
        static mut instance: ::protobuf::lazy::Lazy<BlockInventory_BlockId> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const BlockInventory_BlockId,
        };
        unsafe {
            instance.get(BlockInventory_BlockId::new)
        }
    }
}

impl ::protobuf::Clear for BlockInventory_BlockId {
    fn clear(&mut self) {
        self.hash.clear();
        self.number = 0;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for BlockInventory_BlockId {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for BlockInventory_BlockId {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(Clone,PartialEq,Eq,Debug,Hash)]
pub enum BlockInventory_Type {
    SYNC = 0,
    ADVTISE = 1,
    FETCH = 2,
}

impl ::protobuf::ProtobufEnum for BlockInventory_Type {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<BlockInventory_Type> {
        match value {
            0 => ::std::option::Option::Some(BlockInventory_Type::SYNC),
            1 => ::std::option::Option::Some(BlockInventory_Type::ADVTISE),
            2 => ::std::option::Option::Some(BlockInventory_Type::FETCH),
            _ => ::std::option::Option::None
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [BlockInventory_Type] = &[
            BlockInventory_Type::SYNC,
            BlockInventory_Type::ADVTISE,
            BlockInventory_Type::FETCH,
        ];
        values
    }

    fn enum_descriptor_static() -> &'static ::protobuf::reflect::EnumDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::EnumDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                ::protobuf::reflect::EnumDescriptor::new("BlockInventory_Type", file_descriptor_proto())
            })
        }
    }
}

impl ::std::marker::Copy for BlockInventory_Type {
}

impl ::std::default::Default for BlockInventory_Type {
    fn default() -> Self {
        BlockInventory_Type::SYNC
    }
}

impl ::protobuf::reflect::ProtobufValue for BlockInventory_Type {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Enum(self.descriptor())
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct Inventory {
    // message fields
    pub field_type: Inventory_InventoryType,
    pub ids: ::protobuf::RepeatedField<::std::vec::Vec<u8>>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a Inventory {
    fn default() -> &'a Inventory {
        <Inventory as ::protobuf::Message>::default_instance()
    }
}

impl Inventory {
    pub fn new() -> Inventory {
        ::std::default::Default::default()
    }

    // .protocol.Inventory.InventoryType type = 1;


    pub fn get_field_type(&self) -> Inventory_InventoryType {
        self.field_type
    }
    pub fn clear_field_type(&mut self) {
        self.field_type = Inventory_InventoryType::TRX;
    }

    // Param is passed by value, moved
    pub fn set_field_type(&mut self, v: Inventory_InventoryType) {
        self.field_type = v;
    }

    // repeated bytes ids = 2;


    pub fn get_ids(&self) -> &[::std::vec::Vec<u8>] {
        &self.ids
    }
    pub fn clear_ids(&mut self) {
        self.ids.clear();
    }

    // Param is passed by value, moved
    pub fn set_ids(&mut self, v: ::protobuf::RepeatedField<::std::vec::Vec<u8>>) {
        self.ids = v;
    }

    // Mutable pointer to the field.
    pub fn mut_ids(&mut self) -> &mut ::protobuf::RepeatedField<::std::vec::Vec<u8>> {
        &mut self.ids
    }

    // Take field
    pub fn take_ids(&mut self) -> ::protobuf::RepeatedField<::std::vec::Vec<u8>> {
        ::std::mem::replace(&mut self.ids, ::protobuf::RepeatedField::new())
    }
}

impl ::protobuf::Message for Inventory {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_proto3_enum_with_unknown_fields_into(wire_type, is, &mut self.field_type, 1, &mut self.unknown_fields)?
                },
                2 => {
                    ::protobuf::rt::read_repeated_bytes_into(wire_type, is, &mut self.ids)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.field_type != Inventory_InventoryType::TRX {
            my_size += ::protobuf::rt::enum_size(1, self.field_type);
        }
        for value in &self.ids {
            my_size += ::protobuf::rt::bytes_size(2, &value);
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if self.field_type != Inventory_InventoryType::TRX {
            os.write_enum(1, self.field_type.value())?;
        }
        for v in &self.ids {
            os.write_bytes(2, &v)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> Inventory {
        Inventory::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeEnum<Inventory_InventoryType>>(
                    "type",
                    |m: &Inventory| { &m.field_type },
                    |m: &mut Inventory| { &mut m.field_type },
                ));
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                    "ids",
                    |m: &Inventory| { &m.ids },
                    |m: &mut Inventory| { &mut m.ids },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<Inventory>(
                    "Inventory",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static Inventory {
        static mut instance: ::protobuf::lazy::Lazy<Inventory> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const Inventory,
        };
        unsafe {
            instance.get(Inventory::new)
        }
    }
}

impl ::protobuf::Clear for Inventory {
    fn clear(&mut self) {
        self.field_type = Inventory_InventoryType::TRX;
        self.ids.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for Inventory {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Inventory {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(Clone,PartialEq,Eq,Debug,Hash)]
pub enum Inventory_InventoryType {
    TRX = 0,
    BLOCK = 1,
}

impl ::protobuf::ProtobufEnum for Inventory_InventoryType {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<Inventory_InventoryType> {
        match value {
            0 => ::std::option::Option::Some(Inventory_InventoryType::TRX),
            1 => ::std::option::Option::Some(Inventory_InventoryType::BLOCK),
            _ => ::std::option::Option::None
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [Inventory_InventoryType] = &[
            Inventory_InventoryType::TRX,
            Inventory_InventoryType::BLOCK,
        ];
        values
    }

    fn enum_descriptor_static() -> &'static ::protobuf::reflect::EnumDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::EnumDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                ::protobuf::reflect::EnumDescriptor::new("Inventory_InventoryType", file_descriptor_proto())
            })
        }
    }
}

impl ::std::marker::Copy for Inventory_InventoryType {
}

impl ::std::default::Default for Inventory_InventoryType {
    fn default() -> Self {
        Inventory_InventoryType::TRX
    }
}

impl ::protobuf::reflect::ProtobufValue for Inventory_InventoryType {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Enum(self.descriptor())
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct Items {
    // message fields
    pub field_type: Items_ItemType,
    pub blocks: ::protobuf::RepeatedField<Block>,
    pub block_headers: ::protobuf::RepeatedField<BlockHeader>,
    pub transactions: ::protobuf::RepeatedField<Transaction>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a Items {
    fn default() -> &'a Items {
        <Items as ::protobuf::Message>::default_instance()
    }
}

impl Items {
    pub fn new() -> Items {
        ::std::default::Default::default()
    }

    // .protocol.Items.ItemType type = 1;


    pub fn get_field_type(&self) -> Items_ItemType {
        self.field_type
    }
    pub fn clear_field_type(&mut self) {
        self.field_type = Items_ItemType::ERR;
    }

    // Param is passed by value, moved
    pub fn set_field_type(&mut self, v: Items_ItemType) {
        self.field_type = v;
    }

    // repeated .protocol.Block blocks = 2;


    pub fn get_blocks(&self) -> &[Block] {
        &self.blocks
    }
    pub fn clear_blocks(&mut self) {
        self.blocks.clear();
    }

    // Param is passed by value, moved
    pub fn set_blocks(&mut self, v: ::protobuf::RepeatedField<Block>) {
        self.blocks = v;
    }

    // Mutable pointer to the field.
    pub fn mut_blocks(&mut self) -> &mut ::protobuf::RepeatedField<Block> {
        &mut self.blocks
    }

    // Take field
    pub fn take_blocks(&mut self) -> ::protobuf::RepeatedField<Block> {
        ::std::mem::replace(&mut self.blocks, ::protobuf::RepeatedField::new())
    }

    // repeated .protocol.BlockHeader block_headers = 3;


    pub fn get_block_headers(&self) -> &[BlockHeader] {
        &self.block_headers
    }
    pub fn clear_block_headers(&mut self) {
        self.block_headers.clear();
    }

    // Param is passed by value, moved
    pub fn set_block_headers(&mut self, v: ::protobuf::RepeatedField<BlockHeader>) {
        self.block_headers = v;
    }

    // Mutable pointer to the field.
    pub fn mut_block_headers(&mut self) -> &mut ::protobuf::RepeatedField<BlockHeader> {
        &mut self.block_headers
    }

    // Take field
    pub fn take_block_headers(&mut self) -> ::protobuf::RepeatedField<BlockHeader> {
        ::std::mem::replace(&mut self.block_headers, ::protobuf::RepeatedField::new())
    }

    // repeated .protocol.Transaction transactions = 4;


    pub fn get_transactions(&self) -> &[Transaction] {
        &self.transactions
    }
    pub fn clear_transactions(&mut self) {
        self.transactions.clear();
    }

    // Param is passed by value, moved
    pub fn set_transactions(&mut self, v: ::protobuf::RepeatedField<Transaction>) {
        self.transactions = v;
    }

    // Mutable pointer to the field.
    pub fn mut_transactions(&mut self) -> &mut ::protobuf::RepeatedField<Transaction> {
        &mut self.transactions
    }

    // Take field
    pub fn take_transactions(&mut self) -> ::protobuf::RepeatedField<Transaction> {
        ::std::mem::replace(&mut self.transactions, ::protobuf::RepeatedField::new())
    }
}

impl ::protobuf::Message for Items {
    fn is_initialized(&self) -> bool {
        for v in &self.blocks {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.block_headers {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.transactions {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_proto3_enum_with_unknown_fields_into(wire_type, is, &mut self.field_type, 1, &mut self.unknown_fields)?
                },
                2 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.blocks)?;
                },
                3 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.block_headers)?;
                },
                4 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.transactions)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.field_type != Items_ItemType::ERR {
            my_size += ::protobuf::rt::enum_size(1, self.field_type);
        }
        for value in &self.blocks {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        for value in &self.block_headers {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        for value in &self.transactions {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if self.field_type != Items_ItemType::ERR {
            os.write_enum(1, self.field_type.value())?;
        }
        for v in &self.blocks {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        for v in &self.block_headers {
            os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        for v in &self.transactions {
            os.write_tag(4, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> Items {
        Items::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeEnum<Items_ItemType>>(
                    "type",
                    |m: &Items| { &m.field_type },
                    |m: &mut Items| { &mut m.field_type },
                ));
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Block>>(
                    "blocks",
                    |m: &Items| { &m.blocks },
                    |m: &mut Items| { &mut m.blocks },
                ));
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<BlockHeader>>(
                    "block_headers",
                    |m: &Items| { &m.block_headers },
                    |m: &mut Items| { &mut m.block_headers },
                ));
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Transaction>>(
                    "transactions",
                    |m: &Items| { &m.transactions },
                    |m: &mut Items| { &mut m.transactions },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<Items>(
                    "Items",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static Items {
        static mut instance: ::protobuf::lazy::Lazy<Items> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const Items,
        };
        unsafe {
            instance.get(Items::new)
        }
    }
}

impl ::protobuf::Clear for Items {
    fn clear(&mut self) {
        self.field_type = Items_ItemType::ERR;
        self.blocks.clear();
        self.block_headers.clear();
        self.transactions.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for Items {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Items {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(Clone,PartialEq,Eq,Debug,Hash)]
pub enum Items_ItemType {
    ERR = 0,
    TRX = 1,
    BLOCK = 2,
    BLOCKHEADER = 3,
}

impl ::protobuf::ProtobufEnum for Items_ItemType {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<Items_ItemType> {
        match value {
            0 => ::std::option::Option::Some(Items_ItemType::ERR),
            1 => ::std::option::Option::Some(Items_ItemType::TRX),
            2 => ::std::option::Option::Some(Items_ItemType::BLOCK),
            3 => ::std::option::Option::Some(Items_ItemType::BLOCKHEADER),
            _ => ::std::option::Option::None
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [Items_ItemType] = &[
            Items_ItemType::ERR,
            Items_ItemType::TRX,
            Items_ItemType::BLOCK,
            Items_ItemType::BLOCKHEADER,
        ];
        values
    }

    fn enum_descriptor_static() -> &'static ::protobuf::reflect::EnumDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::EnumDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                ::protobuf::reflect::EnumDescriptor::new("Items_ItemType", file_descriptor_proto())
            })
        }
    }
}

impl ::std::marker::Copy for Items_ItemType {
}

impl ::std::default::Default for Items_ItemType {
    fn default() -> Self {
        Items_ItemType::ERR
    }
}

impl ::protobuf::reflect::ProtobufValue for Items_ItemType {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Enum(self.descriptor())
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct DynamicProperties {
    // message fields
    pub last_solidity_block_num: i64,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a DynamicProperties {
    fn default() -> &'a DynamicProperties {
        <DynamicProperties as ::protobuf::Message>::default_instance()
    }
}

impl DynamicProperties {
    pub fn new() -> DynamicProperties {
        ::std::default::Default::default()
    }

    // int64 last_solidity_block_num = 1;


    pub fn get_last_solidity_block_num(&self) -> i64 {
        self.last_solidity_block_num
    }
    pub fn clear_last_solidity_block_num(&mut self) {
        self.last_solidity_block_num = 0;
    }

    // Param is passed by value, moved
    pub fn set_last_solidity_block_num(&mut self, v: i64) {
        self.last_solidity_block_num = v;
    }
}

impl ::protobuf::Message for DynamicProperties {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.last_solidity_block_num = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.last_solidity_block_num != 0 {
            my_size += ::protobuf::rt::value_size(1, self.last_solidity_block_num, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if self.last_solidity_block_num != 0 {
            os.write_int64(1, self.last_solidity_block_num)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> DynamicProperties {
        DynamicProperties::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                    "last_solidity_block_num",
                    |m: &DynamicProperties| { &m.last_solidity_block_num },
                    |m: &mut DynamicProperties| { &mut m.last_solidity_block_num },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<DynamicProperties>(
                    "DynamicProperties",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static DynamicProperties {
        static mut instance: ::protobuf::lazy::Lazy<DynamicProperties> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const DynamicProperties,
        };
        unsafe {
            instance.get(DynamicProperties::new)
        }
    }
}

impl ::protobuf::Clear for DynamicProperties {
    fn clear(&mut self) {
        self.last_solidity_block_num = 0;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for DynamicProperties {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for DynamicProperties {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct DisconnectMessage {
    // message fields
    pub reason: ReasonCode,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a DisconnectMessage {
    fn default() -> &'a DisconnectMessage {
        <DisconnectMessage as ::protobuf::Message>::default_instance()
    }
}

impl DisconnectMessage {
    pub fn new() -> DisconnectMessage {
        ::std::default::Default::default()
    }

    // .protocol.ReasonCode reason = 1;


    pub fn get_reason(&self) -> ReasonCode {
        self.reason
    }
    pub fn clear_reason(&mut self) {
        self.reason = ReasonCode::REQUESTED;
    }

    // Param is passed by value, moved
    pub fn set_reason(&mut self, v: ReasonCode) {
        self.reason = v;
    }
}

impl ::protobuf::Message for DisconnectMessage {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_proto3_enum_with_unknown_fields_into(wire_type, is, &mut self.reason, 1, &mut self.unknown_fields)?
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.reason != ReasonCode::REQUESTED {
            my_size += ::protobuf::rt::enum_size(1, self.reason);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if self.reason != ReasonCode::REQUESTED {
            os.write_enum(1, self.reason.value())?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> DisconnectMessage {
        DisconnectMessage::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeEnum<ReasonCode>>(
                    "reason",
                    |m: &DisconnectMessage| { &m.reason },
                    |m: &mut DisconnectMessage| { &mut m.reason },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<DisconnectMessage>(
                    "DisconnectMessage",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static DisconnectMessage {
        static mut instance: ::protobuf::lazy::Lazy<DisconnectMessage> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const DisconnectMessage,
        };
        unsafe {
            instance.get(DisconnectMessage::new)
        }
    }
}

impl ::protobuf::Clear for DisconnectMessage {
    fn clear(&mut self) {
        self.reason = ReasonCode::REQUESTED;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for DisconnectMessage {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for DisconnectMessage {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct HelloMessage {
    // message fields
    pub from: ::protobuf::SingularPtrField<super::Discover::Endpoint>,
    pub version: i32,
    pub timestamp: i64,
    pub genesisBlockId: ::protobuf::SingularPtrField<HelloMessage_BlockId>,
    pub solidBlockId: ::protobuf::SingularPtrField<HelloMessage_BlockId>,
    pub headBlockId: ::protobuf::SingularPtrField<HelloMessage_BlockId>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a HelloMessage {
    fn default() -> &'a HelloMessage {
        <HelloMessage as ::protobuf::Message>::default_instance()
    }
}

impl HelloMessage {
    pub fn new() -> HelloMessage {
        ::std::default::Default::default()
    }

    // .protocol.Endpoint from = 1;


    pub fn get_from(&self) -> &super::Discover::Endpoint {
        self.from.as_ref().unwrap_or_else(|| super::Discover::Endpoint::default_instance())
    }
    pub fn clear_from(&mut self) {
        self.from.clear();
    }

    pub fn has_from(&self) -> bool {
        self.from.is_some()
    }

    // Param is passed by value, moved
    pub fn set_from(&mut self, v: super::Discover::Endpoint) {
        self.from = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_from(&mut self) -> &mut super::Discover::Endpoint {
        if self.from.is_none() {
            self.from.set_default();
        }
        self.from.as_mut().unwrap()
    }

    // Take field
    pub fn take_from(&mut self) -> super::Discover::Endpoint {
        self.from.take().unwrap_or_else(|| super::Discover::Endpoint::new())
    }

    // int32 version = 2;


    pub fn get_version(&self) -> i32 {
        self.version
    }
    pub fn clear_version(&mut self) {
        self.version = 0;
    }

    // Param is passed by value, moved
    pub fn set_version(&mut self, v: i32) {
        self.version = v;
    }

    // int64 timestamp = 3;


    pub fn get_timestamp(&self) -> i64 {
        self.timestamp
    }
    pub fn clear_timestamp(&mut self) {
        self.timestamp = 0;
    }

    // Param is passed by value, moved
    pub fn set_timestamp(&mut self, v: i64) {
        self.timestamp = v;
    }

    // .protocol.HelloMessage.BlockId genesisBlockId = 4;


    pub fn get_genesisBlockId(&self) -> &HelloMessage_BlockId {
        self.genesisBlockId.as_ref().unwrap_or_else(|| HelloMessage_BlockId::default_instance())
    }
    pub fn clear_genesisBlockId(&mut self) {
        self.genesisBlockId.clear();
    }

    pub fn has_genesisBlockId(&self) -> bool {
        self.genesisBlockId.is_some()
    }

    // Param is passed by value, moved
    pub fn set_genesisBlockId(&mut self, v: HelloMessage_BlockId) {
        self.genesisBlockId = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_genesisBlockId(&mut self) -> &mut HelloMessage_BlockId {
        if self.genesisBlockId.is_none() {
            self.genesisBlockId.set_default();
        }
        self.genesisBlockId.as_mut().unwrap()
    }

    // Take field
    pub fn take_genesisBlockId(&mut self) -> HelloMessage_BlockId {
        self.genesisBlockId.take().unwrap_or_else(|| HelloMessage_BlockId::new())
    }

    // .protocol.HelloMessage.BlockId solidBlockId = 5;


    pub fn get_solidBlockId(&self) -> &HelloMessage_BlockId {
        self.solidBlockId.as_ref().unwrap_or_else(|| HelloMessage_BlockId::default_instance())
    }
    pub fn clear_solidBlockId(&mut self) {
        self.solidBlockId.clear();
    }

    pub fn has_solidBlockId(&self) -> bool {
        self.solidBlockId.is_some()
    }

    // Param is passed by value, moved
    pub fn set_solidBlockId(&mut self, v: HelloMessage_BlockId) {
        self.solidBlockId = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_solidBlockId(&mut self) -> &mut HelloMessage_BlockId {
        if self.solidBlockId.is_none() {
            self.solidBlockId.set_default();
        }
        self.solidBlockId.as_mut().unwrap()
    }

    // Take field
    pub fn take_solidBlockId(&mut self) -> HelloMessage_BlockId {
        self.solidBlockId.take().unwrap_or_else(|| HelloMessage_BlockId::new())
    }

    // .protocol.HelloMessage.BlockId headBlockId = 6;


    pub fn get_headBlockId(&self) -> &HelloMessage_BlockId {
        self.headBlockId.as_ref().unwrap_or_else(|| HelloMessage_BlockId::default_instance())
    }
    pub fn clear_headBlockId(&mut self) {
        self.headBlockId.clear();
    }

    pub fn has_headBlockId(&self) -> bool {
        self.headBlockId.is_some()
    }

    // Param is passed by value, moved
    pub fn set_headBlockId(&mut self, v: HelloMessage_BlockId) {
        self.headBlockId = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_headBlockId(&mut self) -> &mut HelloMessage_BlockId {
        if self.headBlockId.is_none() {
            self.headBlockId.set_default();
        }
        self.headBlockId.as_mut().unwrap()
    }

    // Take field
    pub fn take_headBlockId(&mut self) -> HelloMessage_BlockId {
        self.headBlockId.take().unwrap_or_else(|| HelloMessage_BlockId::new())
    }
}

impl ::protobuf::Message for HelloMessage {
    fn is_initialized(&self) -> bool {
        for v in &self.from {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.genesisBlockId {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.solidBlockId {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.headBlockId {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.from)?;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.version = tmp;
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.timestamp = tmp;
                },
                4 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.genesisBlockId)?;
                },
                5 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.solidBlockId)?;
                },
                6 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.headBlockId)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.from.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if self.version != 0 {
            my_size += ::protobuf::rt::value_size(2, self.version, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.timestamp != 0 {
            my_size += ::protobuf::rt::value_size(3, self.timestamp, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(ref v) = self.genesisBlockId.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.solidBlockId.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.headBlockId.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.from.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if self.version != 0 {
            os.write_int32(2, self.version)?;
        }
        if self.timestamp != 0 {
            os.write_int64(3, self.timestamp)?;
        }
        if let Some(ref v) = self.genesisBlockId.as_ref() {
            os.write_tag(4, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.solidBlockId.as_ref() {
            os.write_tag(5, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.headBlockId.as_ref() {
            os.write_tag(6, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> HelloMessage {
        HelloMessage::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::Discover::Endpoint>>(
                    "from",
                    |m: &HelloMessage| { &m.from },
                    |m: &mut HelloMessage| { &mut m.from },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                    "version",
                    |m: &HelloMessage| { &m.version },
                    |m: &mut HelloMessage| { &mut m.version },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                    "timestamp",
                    |m: &HelloMessage| { &m.timestamp },
                    |m: &mut HelloMessage| { &mut m.timestamp },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<HelloMessage_BlockId>>(
                    "genesisBlockId",
                    |m: &HelloMessage| { &m.genesisBlockId },
                    |m: &mut HelloMessage| { &mut m.genesisBlockId },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<HelloMessage_BlockId>>(
                    "solidBlockId",
                    |m: &HelloMessage| { &m.solidBlockId },
                    |m: &mut HelloMessage| { &mut m.solidBlockId },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<HelloMessage_BlockId>>(
                    "headBlockId",
                    |m: &HelloMessage| { &m.headBlockId },
                    |m: &mut HelloMessage| { &mut m.headBlockId },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<HelloMessage>(
                    "HelloMessage",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static HelloMessage {
        static mut instance: ::protobuf::lazy::Lazy<HelloMessage> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const HelloMessage,
        };
        unsafe {
            instance.get(HelloMessage::new)
        }
    }
}

impl ::protobuf::Clear for HelloMessage {
    fn clear(&mut self) {
        self.from.clear();
        self.version = 0;
        self.timestamp = 0;
        self.genesisBlockId.clear();
        self.solidBlockId.clear();
        self.headBlockId.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for HelloMessage {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for HelloMessage {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct HelloMessage_BlockId {
    // message fields
    pub hash: ::std::vec::Vec<u8>,
    pub number: i64,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a HelloMessage_BlockId {
    fn default() -> &'a HelloMessage_BlockId {
        <HelloMessage_BlockId as ::protobuf::Message>::default_instance()
    }
}

impl HelloMessage_BlockId {
    pub fn new() -> HelloMessage_BlockId {
        ::std::default::Default::default()
    }

    // bytes hash = 1;


    pub fn get_hash(&self) -> &[u8] {
        &self.hash
    }
    pub fn clear_hash(&mut self) {
        self.hash.clear();
    }

    // Param is passed by value, moved
    pub fn set_hash(&mut self, v: ::std::vec::Vec<u8>) {
        self.hash = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_hash(&mut self) -> &mut ::std::vec::Vec<u8> {
        &mut self.hash
    }

    // Take field
    pub fn take_hash(&mut self) -> ::std::vec::Vec<u8> {
        ::std::mem::replace(&mut self.hash, ::std::vec::Vec::new())
    }

    // int64 number = 2;


    pub fn get_number(&self) -> i64 {
        self.number
    }
    pub fn clear_number(&mut self) {
        self.number = 0;
    }

    // Param is passed by value, moved
    pub fn set_number(&mut self, v: i64) {
        self.number = v;
    }
}

impl ::protobuf::Message for HelloMessage_BlockId {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_bytes_into(wire_type, is, &mut self.hash)?;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.number = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.hash.is_empty() {
            my_size += ::protobuf::rt::bytes_size(1, &self.hash);
        }
        if self.number != 0 {
            my_size += ::protobuf::rt::value_size(2, self.number, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if !self.hash.is_empty() {
            os.write_bytes(1, &self.hash)?;
        }
        if self.number != 0 {
            os.write_int64(2, self.number)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> HelloMessage_BlockId {
        HelloMessage_BlockId::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                    "hash",
                    |m: &HelloMessage_BlockId| { &m.hash },
                    |m: &mut HelloMessage_BlockId| { &mut m.hash },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                    "number",
                    |m: &HelloMessage_BlockId| { &m.number },
                    |m: &mut HelloMessage_BlockId| { &mut m.number },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<HelloMessage_BlockId>(
                    "HelloMessage_BlockId",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static HelloMessage_BlockId {
        static mut instance: ::protobuf::lazy::Lazy<HelloMessage_BlockId> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const HelloMessage_BlockId,
        };
        unsafe {
            instance.get(HelloMessage_BlockId::new)
        }
    }
}

impl ::protobuf::Clear for HelloMessage_BlockId {
    fn clear(&mut self) {
        self.hash.clear();
        self.number = 0;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for HelloMessage_BlockId {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for HelloMessage_BlockId {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct SmartContract {
    // message fields
    pub origin_address: ::std::vec::Vec<u8>,
    pub contract_address: ::std::vec::Vec<u8>,
    pub abi: ::protobuf::SingularPtrField<SmartContract_ABI>,
    pub bytecode: ::std::vec::Vec<u8>,
    pub call_value: i64,
    pub consume_user_resource_percent: i64,
    pub name: ::std::string::String,
    pub origin_energy_limit: i64,
    pub code_hash: ::std::vec::Vec<u8>,
    pub trx_hash: ::std::vec::Vec<u8>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a SmartContract {
    fn default() -> &'a SmartContract {
        <SmartContract as ::protobuf::Message>::default_instance()
    }
}

impl SmartContract {
    pub fn new() -> SmartContract {
        ::std::default::Default::default()
    }

    // bytes origin_address = 1;


    pub fn get_origin_address(&self) -> &[u8] {
        &self.origin_address
    }
    pub fn clear_origin_address(&mut self) {
        self.origin_address.clear();
    }

    // Param is passed by value, moved
    pub fn set_origin_address(&mut self, v: ::std::vec::Vec<u8>) {
        self.origin_address = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_origin_address(&mut self) -> &mut ::std::vec::Vec<u8> {
        &mut self.origin_address
    }

    // Take field
    pub fn take_origin_address(&mut self) -> ::std::vec::Vec<u8> {
        ::std::mem::replace(&mut self.origin_address, ::std::vec::Vec::new())
    }

    // bytes contract_address = 2;


    pub fn get_contract_address(&self) -> &[u8] {
        &self.contract_address
    }
    pub fn clear_contract_address(&mut self) {
        self.contract_address.clear();
    }

    // Param is passed by value, moved
    pub fn set_contract_address(&mut self, v: ::std::vec::Vec<u8>) {
        self.contract_address = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_contract_address(&mut self) -> &mut ::std::vec::Vec<u8> {
        &mut self.contract_address
    }

    // Take field
    pub fn take_contract_address(&mut self) -> ::std::vec::Vec<u8> {
        ::std::mem::replace(&mut self.contract_address, ::std::vec::Vec::new())
    }

    // .protocol.SmartContract.ABI abi = 3;


    pub fn get_abi(&self) -> &SmartContract_ABI {
        self.abi.as_ref().unwrap_or_else(|| SmartContract_ABI::default_instance())
    }
    pub fn clear_abi(&mut self) {
        self.abi.clear();
    }

    pub fn has_abi(&self) -> bool {
        self.abi.is_some()
    }

    // Param is passed by value, moved
    pub fn set_abi(&mut self, v: SmartContract_ABI) {
        self.abi = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_abi(&mut self) -> &mut SmartContract_ABI {
        if self.abi.is_none() {
            self.abi.set_default();
        }
        self.abi.as_mut().unwrap()
    }

    // Take field
    pub fn take_abi(&mut self) -> SmartContract_ABI {
        self.abi.take().unwrap_or_else(|| SmartContract_ABI::new())
    }

    // bytes bytecode = 4;


    pub fn get_bytecode(&self) -> &[u8] {
        &self.bytecode
    }
    pub fn clear_bytecode(&mut self) {
        self.bytecode.clear();
    }

    // Param is passed by value, moved
    pub fn set_bytecode(&mut self, v: ::std::vec::Vec<u8>) {
        self.bytecode = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_bytecode(&mut self) -> &mut ::std::vec::Vec<u8> {
        &mut self.bytecode
    }

    // Take field
    pub fn take_bytecode(&mut self) -> ::std::vec::Vec<u8> {
        ::std::mem::replace(&mut self.bytecode, ::std::vec::Vec::new())
    }

    // int64 call_value = 5;


    pub fn get_call_value(&self) -> i64 {
        self.call_value
    }
    pub fn clear_call_value(&mut self) {
        self.call_value = 0;
    }

    // Param is passed by value, moved
    pub fn set_call_value(&mut self, v: i64) {
        self.call_value = v;
    }

    // int64 consume_user_resource_percent = 6;


    pub fn get_consume_user_resource_percent(&self) -> i64 {
        self.consume_user_resource_percent
    }
    pub fn clear_consume_user_resource_percent(&mut self) {
        self.consume_user_resource_percent = 0;
    }

    // Param is passed by value, moved
    pub fn set_consume_user_resource_percent(&mut self, v: i64) {
        self.consume_user_resource_percent = v;
    }

    // string name = 7;


    pub fn get_name(&self) -> &str {
        &self.name
    }
    pub fn clear_name(&mut self) {
        self.name.clear();
    }

    // Param is passed by value, moved
    pub fn set_name(&mut self, v: ::std::string::String) {
        self.name = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_name(&mut self) -> &mut ::std::string::String {
        &mut self.name
    }

    // Take field
    pub fn take_name(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.name, ::std::string::String::new())
    }

    // int64 origin_energy_limit = 8;


    pub fn get_origin_energy_limit(&self) -> i64 {
        self.origin_energy_limit
    }
    pub fn clear_origin_energy_limit(&mut self) {
        self.origin_energy_limit = 0;
    }

    // Param is passed by value, moved
    pub fn set_origin_energy_limit(&mut self, v: i64) {
        self.origin_energy_limit = v;
    }

    // bytes code_hash = 9;


    pub fn get_code_hash(&self) -> &[u8] {
        &self.code_hash
    }
    pub fn clear_code_hash(&mut self) {
        self.code_hash.clear();
    }

    // Param is passed by value, moved
    pub fn set_code_hash(&mut self, v: ::std::vec::Vec<u8>) {
        self.code_hash = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_code_hash(&mut self) -> &mut ::std::vec::Vec<u8> {
        &mut self.code_hash
    }

    // Take field
    pub fn take_code_hash(&mut self) -> ::std::vec::Vec<u8> {
        ::std::mem::replace(&mut self.code_hash, ::std::vec::Vec::new())
    }

    // bytes trx_hash = 10;


    pub fn get_trx_hash(&self) -> &[u8] {
        &self.trx_hash
    }
    pub fn clear_trx_hash(&mut self) {
        self.trx_hash.clear();
    }

    // Param is passed by value, moved
    pub fn set_trx_hash(&mut self, v: ::std::vec::Vec<u8>) {
        self.trx_hash = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_trx_hash(&mut self) -> &mut ::std::vec::Vec<u8> {
        &mut self.trx_hash
    }

    // Take field
    pub fn take_trx_hash(&mut self) -> ::std::vec::Vec<u8> {
        ::std::mem::replace(&mut self.trx_hash, ::std::vec::Vec::new())
    }
}

impl ::protobuf::Message for SmartContract {
    fn is_initialized(&self) -> bool {
        for v in &self.abi {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_bytes_into(wire_type, is, &mut self.origin_address)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_bytes_into(wire_type, is, &mut self.contract_address)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.abi)?;
                },
                4 => {
                    ::protobuf::rt::read_singular_proto3_bytes_into(wire_type, is, &mut self.bytecode)?;
                },
                5 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.call_value = tmp;
                },
                6 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.consume_user_resource_percent = tmp;
                },
                7 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.name)?;
                },
                8 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.origin_energy_limit = tmp;
                },
                9 => {
                    ::protobuf::rt::read_singular_proto3_bytes_into(wire_type, is, &mut self.code_hash)?;
                },
                10 => {
                    ::protobuf::rt::read_singular_proto3_bytes_into(wire_type, is, &mut self.trx_hash)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.origin_address.is_empty() {
            my_size += ::protobuf::rt::bytes_size(1, &self.origin_address);
        }
        if !self.contract_address.is_empty() {
            my_size += ::protobuf::rt::bytes_size(2, &self.contract_address);
        }
        if let Some(ref v) = self.abi.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if !self.bytecode.is_empty() {
            my_size += ::protobuf::rt::bytes_size(4, &self.bytecode);
        }
        if self.call_value != 0 {
            my_size += ::protobuf::rt::value_size(5, self.call_value, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.consume_user_resource_percent != 0 {
            my_size += ::protobuf::rt::value_size(6, self.consume_user_resource_percent, ::protobuf::wire_format::WireTypeVarint);
        }
        if !self.name.is_empty() {
            my_size += ::protobuf::rt::string_size(7, &self.name);
        }
        if self.origin_energy_limit != 0 {
            my_size += ::protobuf::rt::value_size(8, self.origin_energy_limit, ::protobuf::wire_format::WireTypeVarint);
        }
        if !self.code_hash.is_empty() {
            my_size += ::protobuf::rt::bytes_size(9, &self.code_hash);
        }
        if !self.trx_hash.is_empty() {
            my_size += ::protobuf::rt::bytes_size(10, &self.trx_hash);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if !self.origin_address.is_empty() {
            os.write_bytes(1, &self.origin_address)?;
        }
        if !self.contract_address.is_empty() {
            os.write_bytes(2, &self.contract_address)?;
        }
        if let Some(ref v) = self.abi.as_ref() {
            os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if !self.bytecode.is_empty() {
            os.write_bytes(4, &self.bytecode)?;
        }
        if self.call_value != 0 {
            os.write_int64(5, self.call_value)?;
        }
        if self.consume_user_resource_percent != 0 {
            os.write_int64(6, self.consume_user_resource_percent)?;
        }
        if !self.name.is_empty() {
            os.write_string(7, &self.name)?;
        }
        if self.origin_energy_limit != 0 {
            os.write_int64(8, self.origin_energy_limit)?;
        }
        if !self.code_hash.is_empty() {
            os.write_bytes(9, &self.code_hash)?;
        }
        if !self.trx_hash.is_empty() {
            os.write_bytes(10, &self.trx_hash)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> SmartContract {
        SmartContract::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                    "origin_address",
                    |m: &SmartContract| { &m.origin_address },
                    |m: &mut SmartContract| { &mut m.origin_address },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                    "contract_address",
                    |m: &SmartContract| { &m.contract_address },
                    |m: &mut SmartContract| { &mut m.contract_address },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<SmartContract_ABI>>(
                    "abi",
                    |m: &SmartContract| { &m.abi },
                    |m: &mut SmartContract| { &mut m.abi },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                    "bytecode",
                    |m: &SmartContract| { &m.bytecode },
                    |m: &mut SmartContract| { &mut m.bytecode },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                    "call_value",
                    |m: &SmartContract| { &m.call_value },
                    |m: &mut SmartContract| { &mut m.call_value },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                    "consume_user_resource_percent",
                    |m: &SmartContract| { &m.consume_user_resource_percent },
                    |m: &mut SmartContract| { &mut m.consume_user_resource_percent },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "name",
                    |m: &SmartContract| { &m.name },
                    |m: &mut SmartContract| { &mut m.name },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                    "origin_energy_limit",
                    |m: &SmartContract| { &m.origin_energy_limit },
                    |m: &mut SmartContract| { &mut m.origin_energy_limit },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                    "code_hash",
                    |m: &SmartContract| { &m.code_hash },
                    |m: &mut SmartContract| { &mut m.code_hash },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                    "trx_hash",
                    |m: &SmartContract| { &m.trx_hash },
                    |m: &mut SmartContract| { &mut m.trx_hash },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<SmartContract>(
                    "SmartContract",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static SmartContract {
        static mut instance: ::protobuf::lazy::Lazy<SmartContract> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const SmartContract,
        };
        unsafe {
            instance.get(SmartContract::new)
        }
    }
}

impl ::protobuf::Clear for SmartContract {
    fn clear(&mut self) {
        self.origin_address.clear();
        self.contract_address.clear();
        self.abi.clear();
        self.bytecode.clear();
        self.call_value = 0;
        self.consume_user_resource_percent = 0;
        self.name.clear();
        self.origin_energy_limit = 0;
        self.code_hash.clear();
        self.trx_hash.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for SmartContract {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for SmartContract {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct SmartContract_ABI {
    // message fields
    pub entrys: ::protobuf::RepeatedField<SmartContract_ABI_Entry>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a SmartContract_ABI {
    fn default() -> &'a SmartContract_ABI {
        <SmartContract_ABI as ::protobuf::Message>::default_instance()
    }
}

impl SmartContract_ABI {
    pub fn new() -> SmartContract_ABI {
        ::std::default::Default::default()
    }

    // repeated .protocol.SmartContract.ABI.Entry entrys = 1;


    pub fn get_entrys(&self) -> &[SmartContract_ABI_Entry] {
        &self.entrys
    }
    pub fn clear_entrys(&mut self) {
        self.entrys.clear();
    }

    // Param is passed by value, moved
    pub fn set_entrys(&mut self, v: ::protobuf::RepeatedField<SmartContract_ABI_Entry>) {
        self.entrys = v;
    }

    // Mutable pointer to the field.
    pub fn mut_entrys(&mut self) -> &mut ::protobuf::RepeatedField<SmartContract_ABI_Entry> {
        &mut self.entrys
    }

    // Take field
    pub fn take_entrys(&mut self) -> ::protobuf::RepeatedField<SmartContract_ABI_Entry> {
        ::std::mem::replace(&mut self.entrys, ::protobuf::RepeatedField::new())
    }
}

impl ::protobuf::Message for SmartContract_ABI {
    fn is_initialized(&self) -> bool {
        for v in &self.entrys {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.entrys)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in &self.entrys {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        for v in &self.entrys {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> SmartContract_ABI {
        SmartContract_ABI::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<SmartContract_ABI_Entry>>(
                    "entrys",
                    |m: &SmartContract_ABI| { &m.entrys },
                    |m: &mut SmartContract_ABI| { &mut m.entrys },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<SmartContract_ABI>(
                    "SmartContract_ABI",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static SmartContract_ABI {
        static mut instance: ::protobuf::lazy::Lazy<SmartContract_ABI> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const SmartContract_ABI,
        };
        unsafe {
            instance.get(SmartContract_ABI::new)
        }
    }
}

impl ::protobuf::Clear for SmartContract_ABI {
    fn clear(&mut self) {
        self.entrys.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for SmartContract_ABI {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for SmartContract_ABI {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct SmartContract_ABI_Entry {
    // message fields
    pub anonymous: bool,
    pub constant: bool,
    pub name: ::std::string::String,
    pub inputs: ::protobuf::RepeatedField<SmartContract_ABI_Entry_Param>,
    pub outputs: ::protobuf::RepeatedField<SmartContract_ABI_Entry_Param>,
    pub field_type: SmartContract_ABI_Entry_EntryType,
    pub payable: bool,
    pub stateMutability: SmartContract_ABI_Entry_StateMutabilityType,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a SmartContract_ABI_Entry {
    fn default() -> &'a SmartContract_ABI_Entry {
        <SmartContract_ABI_Entry as ::protobuf::Message>::default_instance()
    }
}

impl SmartContract_ABI_Entry {
    pub fn new() -> SmartContract_ABI_Entry {
        ::std::default::Default::default()
    }

    // bool anonymous = 1;


    pub fn get_anonymous(&self) -> bool {
        self.anonymous
    }
    pub fn clear_anonymous(&mut self) {
        self.anonymous = false;
    }

    // Param is passed by value, moved
    pub fn set_anonymous(&mut self, v: bool) {
        self.anonymous = v;
    }

    // bool constant = 2;


    pub fn get_constant(&self) -> bool {
        self.constant
    }
    pub fn clear_constant(&mut self) {
        self.constant = false;
    }

    // Param is passed by value, moved
    pub fn set_constant(&mut self, v: bool) {
        self.constant = v;
    }

    // string name = 3;


    pub fn get_name(&self) -> &str {
        &self.name
    }
    pub fn clear_name(&mut self) {
        self.name.clear();
    }

    // Param is passed by value, moved
    pub fn set_name(&mut self, v: ::std::string::String) {
        self.name = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_name(&mut self) -> &mut ::std::string::String {
        &mut self.name
    }

    // Take field
    pub fn take_name(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.name, ::std::string::String::new())
    }

    // repeated .protocol.SmartContract.ABI.Entry.Param inputs = 4;


    pub fn get_inputs(&self) -> &[SmartContract_ABI_Entry_Param] {
        &self.inputs
    }
    pub fn clear_inputs(&mut self) {
        self.inputs.clear();
    }

    // Param is passed by value, moved
    pub fn set_inputs(&mut self, v: ::protobuf::RepeatedField<SmartContract_ABI_Entry_Param>) {
        self.inputs = v;
    }

    // Mutable pointer to the field.
    pub fn mut_inputs(&mut self) -> &mut ::protobuf::RepeatedField<SmartContract_ABI_Entry_Param> {
        &mut self.inputs
    }

    // Take field
    pub fn take_inputs(&mut self) -> ::protobuf::RepeatedField<SmartContract_ABI_Entry_Param> {
        ::std::mem::replace(&mut self.inputs, ::protobuf::RepeatedField::new())
    }

    // repeated .protocol.SmartContract.ABI.Entry.Param outputs = 5;


    pub fn get_outputs(&self) -> &[SmartContract_ABI_Entry_Param] {
        &self.outputs
    }
    pub fn clear_outputs(&mut self) {
        self.outputs.clear();
    }

    // Param is passed by value, moved
    pub fn set_outputs(&mut self, v: ::protobuf::RepeatedField<SmartContract_ABI_Entry_Param>) {
        self.outputs = v;
    }

    // Mutable pointer to the field.
    pub fn mut_outputs(&mut self) -> &mut ::protobuf::RepeatedField<SmartContract_ABI_Entry_Param> {
        &mut self.outputs
    }

    // Take field
    pub fn take_outputs(&mut self) -> ::protobuf::RepeatedField<SmartContract_ABI_Entry_Param> {
        ::std::mem::replace(&mut self.outputs, ::protobuf::RepeatedField::new())
    }

    // .protocol.SmartContract.ABI.Entry.EntryType type = 6;


    pub fn get_field_type(&self) -> SmartContract_ABI_Entry_EntryType {
        self.field_type
    }
    pub fn clear_field_type(&mut self) {
        self.field_type = SmartContract_ABI_Entry_EntryType::UnknownEntryType;
    }

    // Param is passed by value, moved
    pub fn set_field_type(&mut self, v: SmartContract_ABI_Entry_EntryType) {
        self.field_type = v;
    }

    // bool payable = 7;


    pub fn get_payable(&self) -> bool {
        self.payable
    }
    pub fn clear_payable(&mut self) {
        self.payable = false;
    }

    // Param is passed by value, moved
    pub fn set_payable(&mut self, v: bool) {
        self.payable = v;
    }

    // .protocol.SmartContract.ABI.Entry.StateMutabilityType stateMutability = 8;


    pub fn get_stateMutability(&self) -> SmartContract_ABI_Entry_StateMutabilityType {
        self.stateMutability
    }
    pub fn clear_stateMutability(&mut self) {
        self.stateMutability = SmartContract_ABI_Entry_StateMutabilityType::UnknownMutabilityType;
    }

    // Param is passed by value, moved
    pub fn set_stateMutability(&mut self, v: SmartContract_ABI_Entry_StateMutabilityType) {
        self.stateMutability = v;
    }
}

impl ::protobuf::Message for SmartContract_ABI_Entry {
    fn is_initialized(&self) -> bool {
        for v in &self.inputs {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.outputs {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.anonymous = tmp;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.constant = tmp;
                },
                3 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.name)?;
                },
                4 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.inputs)?;
                },
                5 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.outputs)?;
                },
                6 => {
                    ::protobuf::rt::read_proto3_enum_with_unknown_fields_into(wire_type, is, &mut self.field_type, 6, &mut self.unknown_fields)?
                },
                7 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.payable = tmp;
                },
                8 => {
                    ::protobuf::rt::read_proto3_enum_with_unknown_fields_into(wire_type, is, &mut self.stateMutability, 8, &mut self.unknown_fields)?
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.anonymous != false {
            my_size += 2;
        }
        if self.constant != false {
            my_size += 2;
        }
        if !self.name.is_empty() {
            my_size += ::protobuf::rt::string_size(3, &self.name);
        }
        for value in &self.inputs {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        for value in &self.outputs {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        if self.field_type != SmartContract_ABI_Entry_EntryType::UnknownEntryType {
            my_size += ::protobuf::rt::enum_size(6, self.field_type);
        }
        if self.payable != false {
            my_size += 2;
        }
        if self.stateMutability != SmartContract_ABI_Entry_StateMutabilityType::UnknownMutabilityType {
            my_size += ::protobuf::rt::enum_size(8, self.stateMutability);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if self.anonymous != false {
            os.write_bool(1, self.anonymous)?;
        }
        if self.constant != false {
            os.write_bool(2, self.constant)?;
        }
        if !self.name.is_empty() {
            os.write_string(3, &self.name)?;
        }
        for v in &self.inputs {
            os.write_tag(4, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        for v in &self.outputs {
            os.write_tag(5, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        if self.field_type != SmartContract_ABI_Entry_EntryType::UnknownEntryType {
            os.write_enum(6, self.field_type.value())?;
        }
        if self.payable != false {
            os.write_bool(7, self.payable)?;
        }
        if self.stateMutability != SmartContract_ABI_Entry_StateMutabilityType::UnknownMutabilityType {
            os.write_enum(8, self.stateMutability.value())?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> SmartContract_ABI_Entry {
        SmartContract_ABI_Entry::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                    "anonymous",
                    |m: &SmartContract_ABI_Entry| { &m.anonymous },
                    |m: &mut SmartContract_ABI_Entry| { &mut m.anonymous },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                    "constant",
                    |m: &SmartContract_ABI_Entry| { &m.constant },
                    |m: &mut SmartContract_ABI_Entry| { &mut m.constant },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "name",
                    |m: &SmartContract_ABI_Entry| { &m.name },
                    |m: &mut SmartContract_ABI_Entry| { &mut m.name },
                ));
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<SmartContract_ABI_Entry_Param>>(
                    "inputs",
                    |m: &SmartContract_ABI_Entry| { &m.inputs },
                    |m: &mut SmartContract_ABI_Entry| { &mut m.inputs },
                ));
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<SmartContract_ABI_Entry_Param>>(
                    "outputs",
                    |m: &SmartContract_ABI_Entry| { &m.outputs },
                    |m: &mut SmartContract_ABI_Entry| { &mut m.outputs },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeEnum<SmartContract_ABI_Entry_EntryType>>(
                    "type",
                    |m: &SmartContract_ABI_Entry| { &m.field_type },
                    |m: &mut SmartContract_ABI_Entry| { &mut m.field_type },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                    "payable",
                    |m: &SmartContract_ABI_Entry| { &m.payable },
                    |m: &mut SmartContract_ABI_Entry| { &mut m.payable },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeEnum<SmartContract_ABI_Entry_StateMutabilityType>>(
                    "stateMutability",
                    |m: &SmartContract_ABI_Entry| { &m.stateMutability },
                    |m: &mut SmartContract_ABI_Entry| { &mut m.stateMutability },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<SmartContract_ABI_Entry>(
                    "SmartContract_ABI_Entry",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static SmartContract_ABI_Entry {
        static mut instance: ::protobuf::lazy::Lazy<SmartContract_ABI_Entry> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const SmartContract_ABI_Entry,
        };
        unsafe {
            instance.get(SmartContract_ABI_Entry::new)
        }
    }
}

impl ::protobuf::Clear for SmartContract_ABI_Entry {
    fn clear(&mut self) {
        self.anonymous = false;
        self.constant = false;
        self.name.clear();
        self.inputs.clear();
        self.outputs.clear();
        self.field_type = SmartContract_ABI_Entry_EntryType::UnknownEntryType;
        self.payable = false;
        self.stateMutability = SmartContract_ABI_Entry_StateMutabilityType::UnknownMutabilityType;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for SmartContract_ABI_Entry {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for SmartContract_ABI_Entry {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct SmartContract_ABI_Entry_Param {
    // message fields
    pub indexed: bool,
    pub name: ::std::string::String,
    pub field_type: ::std::string::String,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a SmartContract_ABI_Entry_Param {
    fn default() -> &'a SmartContract_ABI_Entry_Param {
        <SmartContract_ABI_Entry_Param as ::protobuf::Message>::default_instance()
    }
}

impl SmartContract_ABI_Entry_Param {
    pub fn new() -> SmartContract_ABI_Entry_Param {
        ::std::default::Default::default()
    }

    // bool indexed = 1;


    pub fn get_indexed(&self) -> bool {
        self.indexed
    }
    pub fn clear_indexed(&mut self) {
        self.indexed = false;
    }

    // Param is passed by value, moved
    pub fn set_indexed(&mut self, v: bool) {
        self.indexed = v;
    }

    // string name = 2;


    pub fn get_name(&self) -> &str {
        &self.name
    }
    pub fn clear_name(&mut self) {
        self.name.clear();
    }

    // Param is passed by value, moved
    pub fn set_name(&mut self, v: ::std::string::String) {
        self.name = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_name(&mut self) -> &mut ::std::string::String {
        &mut self.name
    }

    // Take field
    pub fn take_name(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.name, ::std::string::String::new())
    }

    // string type = 3;


    pub fn get_field_type(&self) -> &str {
        &self.field_type
    }
    pub fn clear_field_type(&mut self) {
        self.field_type.clear();
    }

    // Param is passed by value, moved
    pub fn set_field_type(&mut self, v: ::std::string::String) {
        self.field_type = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_field_type(&mut self) -> &mut ::std::string::String {
        &mut self.field_type
    }

    // Take field
    pub fn take_field_type(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.field_type, ::std::string::String::new())
    }
}

impl ::protobuf::Message for SmartContract_ABI_Entry_Param {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.indexed = tmp;
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.name)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.field_type)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.indexed != false {
            my_size += 2;
        }
        if !self.name.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.name);
        }
        if !self.field_type.is_empty() {
            my_size += ::protobuf::rt::string_size(3, &self.field_type);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if self.indexed != false {
            os.write_bool(1, self.indexed)?;
        }
        if !self.name.is_empty() {
            os.write_string(2, &self.name)?;
        }
        if !self.field_type.is_empty() {
            os.write_string(3, &self.field_type)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> SmartContract_ABI_Entry_Param {
        SmartContract_ABI_Entry_Param::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                    "indexed",
                    |m: &SmartContract_ABI_Entry_Param| { &m.indexed },
                    |m: &mut SmartContract_ABI_Entry_Param| { &mut m.indexed },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "name",
                    |m: &SmartContract_ABI_Entry_Param| { &m.name },
                    |m: &mut SmartContract_ABI_Entry_Param| { &mut m.name },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "type",
                    |m: &SmartContract_ABI_Entry_Param| { &m.field_type },
                    |m: &mut SmartContract_ABI_Entry_Param| { &mut m.field_type },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<SmartContract_ABI_Entry_Param>(
                    "SmartContract_ABI_Entry_Param",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static SmartContract_ABI_Entry_Param {
        static mut instance: ::protobuf::lazy::Lazy<SmartContract_ABI_Entry_Param> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const SmartContract_ABI_Entry_Param,
        };
        unsafe {
            instance.get(SmartContract_ABI_Entry_Param::new)
        }
    }
}

impl ::protobuf::Clear for SmartContract_ABI_Entry_Param {
    fn clear(&mut self) {
        self.indexed = false;
        self.name.clear();
        self.field_type.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for SmartContract_ABI_Entry_Param {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for SmartContract_ABI_Entry_Param {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(Clone,PartialEq,Eq,Debug,Hash)]
pub enum SmartContract_ABI_Entry_EntryType {
    UnknownEntryType = 0,
    Constructor = 1,
    Function = 2,
    Event = 3,
    Fallback = 4,
}

impl ::protobuf::ProtobufEnum for SmartContract_ABI_Entry_EntryType {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<SmartContract_ABI_Entry_EntryType> {
        match value {
            0 => ::std::option::Option::Some(SmartContract_ABI_Entry_EntryType::UnknownEntryType),
            1 => ::std::option::Option::Some(SmartContract_ABI_Entry_EntryType::Constructor),
            2 => ::std::option::Option::Some(SmartContract_ABI_Entry_EntryType::Function),
            3 => ::std::option::Option::Some(SmartContract_ABI_Entry_EntryType::Event),
            4 => ::std::option::Option::Some(SmartContract_ABI_Entry_EntryType::Fallback),
            _ => ::std::option::Option::None
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [SmartContract_ABI_Entry_EntryType] = &[
            SmartContract_ABI_Entry_EntryType::UnknownEntryType,
            SmartContract_ABI_Entry_EntryType::Constructor,
            SmartContract_ABI_Entry_EntryType::Function,
            SmartContract_ABI_Entry_EntryType::Event,
            SmartContract_ABI_Entry_EntryType::Fallback,
        ];
        values
    }

    fn enum_descriptor_static() -> &'static ::protobuf::reflect::EnumDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::EnumDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                ::protobuf::reflect::EnumDescriptor::new("SmartContract_ABI_Entry_EntryType", file_descriptor_proto())
            })
        }
    }
}

impl ::std::marker::Copy for SmartContract_ABI_Entry_EntryType {
}

impl ::std::default::Default for SmartContract_ABI_Entry_EntryType {
    fn default() -> Self {
        SmartContract_ABI_Entry_EntryType::UnknownEntryType
    }
}

impl ::protobuf::reflect::ProtobufValue for SmartContract_ABI_Entry_EntryType {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Enum(self.descriptor())
    }
}

#[derive(Clone,PartialEq,Eq,Debug,Hash)]
pub enum SmartContract_ABI_Entry_StateMutabilityType {
    UnknownMutabilityType = 0,
    Pure = 1,
    View = 2,
    Nonpayable = 3,
    Payable = 4,
}

impl ::protobuf::ProtobufEnum for SmartContract_ABI_Entry_StateMutabilityType {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<SmartContract_ABI_Entry_StateMutabilityType> {
        match value {
            0 => ::std::option::Option::Some(SmartContract_ABI_Entry_StateMutabilityType::UnknownMutabilityType),
            1 => ::std::option::Option::Some(SmartContract_ABI_Entry_StateMutabilityType::Pure),
            2 => ::std::option::Option::Some(SmartContract_ABI_Entry_StateMutabilityType::View),
            3 => ::std::option::Option::Some(SmartContract_ABI_Entry_StateMutabilityType::Nonpayable),
            4 => ::std::option::Option::Some(SmartContract_ABI_Entry_StateMutabilityType::Payable),
            _ => ::std::option::Option::None
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [SmartContract_ABI_Entry_StateMutabilityType] = &[
            SmartContract_ABI_Entry_StateMutabilityType::UnknownMutabilityType,
            SmartContract_ABI_Entry_StateMutabilityType::Pure,
            SmartContract_ABI_Entry_StateMutabilityType::View,
            SmartContract_ABI_Entry_StateMutabilityType::Nonpayable,
            SmartContract_ABI_Entry_StateMutabilityType::Payable,
        ];
        values
    }

    fn enum_descriptor_static() -> &'static ::protobuf::reflect::EnumDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::EnumDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                ::protobuf::reflect::EnumDescriptor::new("SmartContract_ABI_Entry_StateMutabilityType", file_descriptor_proto())
            })
        }
    }
}

impl ::std::marker::Copy for SmartContract_ABI_Entry_StateMutabilityType {
}

impl ::std::default::Default for SmartContract_ABI_Entry_StateMutabilityType {
    fn default() -> Self {
        SmartContract_ABI_Entry_StateMutabilityType::UnknownMutabilityType
    }
}

impl ::protobuf::reflect::ProtobufValue for SmartContract_ABI_Entry_StateMutabilityType {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Enum(self.descriptor())
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct InternalTransaction {
    // message fields
    pub hash: ::std::vec::Vec<u8>,
    pub caller_address: ::std::vec::Vec<u8>,
    pub transferTo_address: ::std::vec::Vec<u8>,
    pub callValueInfo: ::protobuf::RepeatedField<InternalTransaction_CallValueInfo>,
    pub note: ::std::vec::Vec<u8>,
    pub rejected: bool,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a InternalTransaction {
    fn default() -> &'a InternalTransaction {
        <InternalTransaction as ::protobuf::Message>::default_instance()
    }
}

impl InternalTransaction {
    pub fn new() -> InternalTransaction {
        ::std::default::Default::default()
    }

    // bytes hash = 1;


    pub fn get_hash(&self) -> &[u8] {
        &self.hash
    }
    pub fn clear_hash(&mut self) {
        self.hash.clear();
    }

    // Param is passed by value, moved
    pub fn set_hash(&mut self, v: ::std::vec::Vec<u8>) {
        self.hash = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_hash(&mut self) -> &mut ::std::vec::Vec<u8> {
        &mut self.hash
    }

    // Take field
    pub fn take_hash(&mut self) -> ::std::vec::Vec<u8> {
        ::std::mem::replace(&mut self.hash, ::std::vec::Vec::new())
    }

    // bytes caller_address = 2;


    pub fn get_caller_address(&self) -> &[u8] {
        &self.caller_address
    }
    pub fn clear_caller_address(&mut self) {
        self.caller_address.clear();
    }

    // Param is passed by value, moved
    pub fn set_caller_address(&mut self, v: ::std::vec::Vec<u8>) {
        self.caller_address = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_caller_address(&mut self) -> &mut ::std::vec::Vec<u8> {
        &mut self.caller_address
    }

    // Take field
    pub fn take_caller_address(&mut self) -> ::std::vec::Vec<u8> {
        ::std::mem::replace(&mut self.caller_address, ::std::vec::Vec::new())
    }

    // bytes transferTo_address = 3;


    pub fn get_transferTo_address(&self) -> &[u8] {
        &self.transferTo_address
    }
    pub fn clear_transferTo_address(&mut self) {
        self.transferTo_address.clear();
    }

    // Param is passed by value, moved
    pub fn set_transferTo_address(&mut self, v: ::std::vec::Vec<u8>) {
        self.transferTo_address = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_transferTo_address(&mut self) -> &mut ::std::vec::Vec<u8> {
        &mut self.transferTo_address
    }

    // Take field
    pub fn take_transferTo_address(&mut self) -> ::std::vec::Vec<u8> {
        ::std::mem::replace(&mut self.transferTo_address, ::std::vec::Vec::new())
    }

    // repeated .protocol.InternalTransaction.CallValueInfo callValueInfo = 4;


    pub fn get_callValueInfo(&self) -> &[InternalTransaction_CallValueInfo] {
        &self.callValueInfo
    }
    pub fn clear_callValueInfo(&mut self) {
        self.callValueInfo.clear();
    }

    // Param is passed by value, moved
    pub fn set_callValueInfo(&mut self, v: ::protobuf::RepeatedField<InternalTransaction_CallValueInfo>) {
        self.callValueInfo = v;
    }

    // Mutable pointer to the field.
    pub fn mut_callValueInfo(&mut self) -> &mut ::protobuf::RepeatedField<InternalTransaction_CallValueInfo> {
        &mut self.callValueInfo
    }

    // Take field
    pub fn take_callValueInfo(&mut self) -> ::protobuf::RepeatedField<InternalTransaction_CallValueInfo> {
        ::std::mem::replace(&mut self.callValueInfo, ::protobuf::RepeatedField::new())
    }

    // bytes note = 5;


    pub fn get_note(&self) -> &[u8] {
        &self.note
    }
    pub fn clear_note(&mut self) {
        self.note.clear();
    }

    // Param is passed by value, moved
    pub fn set_note(&mut self, v: ::std::vec::Vec<u8>) {
        self.note = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_note(&mut self) -> &mut ::std::vec::Vec<u8> {
        &mut self.note
    }

    // Take field
    pub fn take_note(&mut self) -> ::std::vec::Vec<u8> {
        ::std::mem::replace(&mut self.note, ::std::vec::Vec::new())
    }

    // bool rejected = 6;


    pub fn get_rejected(&self) -> bool {
        self.rejected
    }
    pub fn clear_rejected(&mut self) {
        self.rejected = false;
    }

    // Param is passed by value, moved
    pub fn set_rejected(&mut self, v: bool) {
        self.rejected = v;
    }
}

impl ::protobuf::Message for InternalTransaction {
    fn is_initialized(&self) -> bool {
        for v in &self.callValueInfo {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_bytes_into(wire_type, is, &mut self.hash)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_bytes_into(wire_type, is, &mut self.caller_address)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_proto3_bytes_into(wire_type, is, &mut self.transferTo_address)?;
                },
                4 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.callValueInfo)?;
                },
                5 => {
                    ::protobuf::rt::read_singular_proto3_bytes_into(wire_type, is, &mut self.note)?;
                },
                6 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.rejected = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.hash.is_empty() {
            my_size += ::protobuf::rt::bytes_size(1, &self.hash);
        }
        if !self.caller_address.is_empty() {
            my_size += ::protobuf::rt::bytes_size(2, &self.caller_address);
        }
        if !self.transferTo_address.is_empty() {
            my_size += ::protobuf::rt::bytes_size(3, &self.transferTo_address);
        }
        for value in &self.callValueInfo {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        if !self.note.is_empty() {
            my_size += ::protobuf::rt::bytes_size(5, &self.note);
        }
        if self.rejected != false {
            my_size += 2;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if !self.hash.is_empty() {
            os.write_bytes(1, &self.hash)?;
        }
        if !self.caller_address.is_empty() {
            os.write_bytes(2, &self.caller_address)?;
        }
        if !self.transferTo_address.is_empty() {
            os.write_bytes(3, &self.transferTo_address)?;
        }
        for v in &self.callValueInfo {
            os.write_tag(4, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        if !self.note.is_empty() {
            os.write_bytes(5, &self.note)?;
        }
        if self.rejected != false {
            os.write_bool(6, self.rejected)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> InternalTransaction {
        InternalTransaction::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                    "hash",
                    |m: &InternalTransaction| { &m.hash },
                    |m: &mut InternalTransaction| { &mut m.hash },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                    "caller_address",
                    |m: &InternalTransaction| { &m.caller_address },
                    |m: &mut InternalTransaction| { &mut m.caller_address },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                    "transferTo_address",
                    |m: &InternalTransaction| { &m.transferTo_address },
                    |m: &mut InternalTransaction| { &mut m.transferTo_address },
                ));
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<InternalTransaction_CallValueInfo>>(
                    "callValueInfo",
                    |m: &InternalTransaction| { &m.callValueInfo },
                    |m: &mut InternalTransaction| { &mut m.callValueInfo },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                    "note",
                    |m: &InternalTransaction| { &m.note },
                    |m: &mut InternalTransaction| { &mut m.note },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                    "rejected",
                    |m: &InternalTransaction| { &m.rejected },
                    |m: &mut InternalTransaction| { &mut m.rejected },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<InternalTransaction>(
                    "InternalTransaction",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static InternalTransaction {
        static mut instance: ::protobuf::lazy::Lazy<InternalTransaction> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const InternalTransaction,
        };
        unsafe {
            instance.get(InternalTransaction::new)
        }
    }
}

impl ::protobuf::Clear for InternalTransaction {
    fn clear(&mut self) {
        self.hash.clear();
        self.caller_address.clear();
        self.transferTo_address.clear();
        self.callValueInfo.clear();
        self.note.clear();
        self.rejected = false;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for InternalTransaction {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for InternalTransaction {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct InternalTransaction_CallValueInfo {
    // message fields
    pub callValue: i64,
    pub tokenId: ::std::string::String,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a InternalTransaction_CallValueInfo {
    fn default() -> &'a InternalTransaction_CallValueInfo {
        <InternalTransaction_CallValueInfo as ::protobuf::Message>::default_instance()
    }
}

impl InternalTransaction_CallValueInfo {
    pub fn new() -> InternalTransaction_CallValueInfo {
        ::std::default::Default::default()
    }

    // int64 callValue = 1;


    pub fn get_callValue(&self) -> i64 {
        self.callValue
    }
    pub fn clear_callValue(&mut self) {
        self.callValue = 0;
    }

    // Param is passed by value, moved
    pub fn set_callValue(&mut self, v: i64) {
        self.callValue = v;
    }

    // string tokenId = 2;


    pub fn get_tokenId(&self) -> &str {
        &self.tokenId
    }
    pub fn clear_tokenId(&mut self) {
        self.tokenId.clear();
    }

    // Param is passed by value, moved
    pub fn set_tokenId(&mut self, v: ::std::string::String) {
        self.tokenId = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_tokenId(&mut self) -> &mut ::std::string::String {
        &mut self.tokenId
    }

    // Take field
    pub fn take_tokenId(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.tokenId, ::std::string::String::new())
    }
}

impl ::protobuf::Message for InternalTransaction_CallValueInfo {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.callValue = tmp;
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.tokenId)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.callValue != 0 {
            my_size += ::protobuf::rt::value_size(1, self.callValue, ::protobuf::wire_format::WireTypeVarint);
        }
        if !self.tokenId.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.tokenId);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if self.callValue != 0 {
            os.write_int64(1, self.callValue)?;
        }
        if !self.tokenId.is_empty() {
            os.write_string(2, &self.tokenId)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> InternalTransaction_CallValueInfo {
        InternalTransaction_CallValueInfo::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                    "callValue",
                    |m: &InternalTransaction_CallValueInfo| { &m.callValue },
                    |m: &mut InternalTransaction_CallValueInfo| { &mut m.callValue },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "tokenId",
                    |m: &InternalTransaction_CallValueInfo| { &m.tokenId },
                    |m: &mut InternalTransaction_CallValueInfo| { &mut m.tokenId },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<InternalTransaction_CallValueInfo>(
                    "InternalTransaction_CallValueInfo",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static InternalTransaction_CallValueInfo {
        static mut instance: ::protobuf::lazy::Lazy<InternalTransaction_CallValueInfo> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const InternalTransaction_CallValueInfo,
        };
        unsafe {
            instance.get(InternalTransaction_CallValueInfo::new)
        }
    }
}

impl ::protobuf::Clear for InternalTransaction_CallValueInfo {
    fn clear(&mut self) {
        self.callValue = 0;
        self.tokenId.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for InternalTransaction_CallValueInfo {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for InternalTransaction_CallValueInfo {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct DelegatedResourceAccountIndex {
    // message fields
    pub account: ::std::vec::Vec<u8>,
    pub fromAccounts: ::protobuf::RepeatedField<::std::vec::Vec<u8>>,
    pub toAccounts: ::protobuf::RepeatedField<::std::vec::Vec<u8>>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a DelegatedResourceAccountIndex {
    fn default() -> &'a DelegatedResourceAccountIndex {
        <DelegatedResourceAccountIndex as ::protobuf::Message>::default_instance()
    }
}

impl DelegatedResourceAccountIndex {
    pub fn new() -> DelegatedResourceAccountIndex {
        ::std::default::Default::default()
    }

    // bytes account = 1;


    pub fn get_account(&self) -> &[u8] {
        &self.account
    }
    pub fn clear_account(&mut self) {
        self.account.clear();
    }

    // Param is passed by value, moved
    pub fn set_account(&mut self, v: ::std::vec::Vec<u8>) {
        self.account = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_account(&mut self) -> &mut ::std::vec::Vec<u8> {
        &mut self.account
    }

    // Take field
    pub fn take_account(&mut self) -> ::std::vec::Vec<u8> {
        ::std::mem::replace(&mut self.account, ::std::vec::Vec::new())
    }

    // repeated bytes fromAccounts = 2;


    pub fn get_fromAccounts(&self) -> &[::std::vec::Vec<u8>] {
        &self.fromAccounts
    }
    pub fn clear_fromAccounts(&mut self) {
        self.fromAccounts.clear();
    }

    // Param is passed by value, moved
    pub fn set_fromAccounts(&mut self, v: ::protobuf::RepeatedField<::std::vec::Vec<u8>>) {
        self.fromAccounts = v;
    }

    // Mutable pointer to the field.
    pub fn mut_fromAccounts(&mut self) -> &mut ::protobuf::RepeatedField<::std::vec::Vec<u8>> {
        &mut self.fromAccounts
    }

    // Take field
    pub fn take_fromAccounts(&mut self) -> ::protobuf::RepeatedField<::std::vec::Vec<u8>> {
        ::std::mem::replace(&mut self.fromAccounts, ::protobuf::RepeatedField::new())
    }

    // repeated bytes toAccounts = 3;


    pub fn get_toAccounts(&self) -> &[::std::vec::Vec<u8>] {
        &self.toAccounts
    }
    pub fn clear_toAccounts(&mut self) {
        self.toAccounts.clear();
    }

    // Param is passed by value, moved
    pub fn set_toAccounts(&mut self, v: ::protobuf::RepeatedField<::std::vec::Vec<u8>>) {
        self.toAccounts = v;
    }

    // Mutable pointer to the field.
    pub fn mut_toAccounts(&mut self) -> &mut ::protobuf::RepeatedField<::std::vec::Vec<u8>> {
        &mut self.toAccounts
    }

    // Take field
    pub fn take_toAccounts(&mut self) -> ::protobuf::RepeatedField<::std::vec::Vec<u8>> {
        ::std::mem::replace(&mut self.toAccounts, ::protobuf::RepeatedField::new())
    }
}

impl ::protobuf::Message for DelegatedResourceAccountIndex {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_bytes_into(wire_type, is, &mut self.account)?;
                },
                2 => {
                    ::protobuf::rt::read_repeated_bytes_into(wire_type, is, &mut self.fromAccounts)?;
                },
                3 => {
                    ::protobuf::rt::read_repeated_bytes_into(wire_type, is, &mut self.toAccounts)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.account.is_empty() {
            my_size += ::protobuf::rt::bytes_size(1, &self.account);
        }
        for value in &self.fromAccounts {
            my_size += ::protobuf::rt::bytes_size(2, &value);
        };
        for value in &self.toAccounts {
            my_size += ::protobuf::rt::bytes_size(3, &value);
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if !self.account.is_empty() {
            os.write_bytes(1, &self.account)?;
        }
        for v in &self.fromAccounts {
            os.write_bytes(2, &v)?;
        };
        for v in &self.toAccounts {
            os.write_bytes(3, &v)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> DelegatedResourceAccountIndex {
        DelegatedResourceAccountIndex::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                    "account",
                    |m: &DelegatedResourceAccountIndex| { &m.account },
                    |m: &mut DelegatedResourceAccountIndex| { &mut m.account },
                ));
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                    "fromAccounts",
                    |m: &DelegatedResourceAccountIndex| { &m.fromAccounts },
                    |m: &mut DelegatedResourceAccountIndex| { &mut m.fromAccounts },
                ));
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                    "toAccounts",
                    |m: &DelegatedResourceAccountIndex| { &m.toAccounts },
                    |m: &mut DelegatedResourceAccountIndex| { &mut m.toAccounts },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<DelegatedResourceAccountIndex>(
                    "DelegatedResourceAccountIndex",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static DelegatedResourceAccountIndex {
        static mut instance: ::protobuf::lazy::Lazy<DelegatedResourceAccountIndex> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const DelegatedResourceAccountIndex,
        };
        unsafe {
            instance.get(DelegatedResourceAccountIndex::new)
        }
    }
}

impl ::protobuf::Clear for DelegatedResourceAccountIndex {
    fn clear(&mut self) {
        self.account.clear();
        self.fromAccounts.clear();
        self.toAccounts.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for DelegatedResourceAccountIndex {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for DelegatedResourceAccountIndex {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct NodeInfo {
    // message fields
    pub beginSyncNum: i64,
    pub block: ::std::string::String,
    pub solidityBlock: ::std::string::String,
    pub currentConnectCount: i32,
    pub activeConnectCount: i32,
    pub passiveConnectCount: i32,
    pub totalFlow: i64,
    pub peerInfoList: ::protobuf::RepeatedField<NodeInfo_PeerInfo>,
    pub configNodeInfo: ::protobuf::SingularPtrField<NodeInfo_ConfigNodeInfo>,
    pub machineInfo: ::protobuf::SingularPtrField<NodeInfo_MachineInfo>,
    pub cheatWitnessInfoMap: ::std::collections::HashMap<::std::string::String, ::std::string::String>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a NodeInfo {
    fn default() -> &'a NodeInfo {
        <NodeInfo as ::protobuf::Message>::default_instance()
    }
}

impl NodeInfo {
    pub fn new() -> NodeInfo {
        ::std::default::Default::default()
    }

    // int64 beginSyncNum = 1;


    pub fn get_beginSyncNum(&self) -> i64 {
        self.beginSyncNum
    }
    pub fn clear_beginSyncNum(&mut self) {
        self.beginSyncNum = 0;
    }

    // Param is passed by value, moved
    pub fn set_beginSyncNum(&mut self, v: i64) {
        self.beginSyncNum = v;
    }

    // string block = 2;


    pub fn get_block(&self) -> &str {
        &self.block
    }
    pub fn clear_block(&mut self) {
        self.block.clear();
    }

    // Param is passed by value, moved
    pub fn set_block(&mut self, v: ::std::string::String) {
        self.block = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_block(&mut self) -> &mut ::std::string::String {
        &mut self.block
    }

    // Take field
    pub fn take_block(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.block, ::std::string::String::new())
    }

    // string solidityBlock = 3;


    pub fn get_solidityBlock(&self) -> &str {
        &self.solidityBlock
    }
    pub fn clear_solidityBlock(&mut self) {
        self.solidityBlock.clear();
    }

    // Param is passed by value, moved
    pub fn set_solidityBlock(&mut self, v: ::std::string::String) {
        self.solidityBlock = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_solidityBlock(&mut self) -> &mut ::std::string::String {
        &mut self.solidityBlock
    }

    // Take field
    pub fn take_solidityBlock(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.solidityBlock, ::std::string::String::new())
    }

    // int32 currentConnectCount = 4;


    pub fn get_currentConnectCount(&self) -> i32 {
        self.currentConnectCount
    }
    pub fn clear_currentConnectCount(&mut self) {
        self.currentConnectCount = 0;
    }

    // Param is passed by value, moved
    pub fn set_currentConnectCount(&mut self, v: i32) {
        self.currentConnectCount = v;
    }

    // int32 activeConnectCount = 5;


    pub fn get_activeConnectCount(&self) -> i32 {
        self.activeConnectCount
    }
    pub fn clear_activeConnectCount(&mut self) {
        self.activeConnectCount = 0;
    }

    // Param is passed by value, moved
    pub fn set_activeConnectCount(&mut self, v: i32) {
        self.activeConnectCount = v;
    }

    // int32 passiveConnectCount = 6;


    pub fn get_passiveConnectCount(&self) -> i32 {
        self.passiveConnectCount
    }
    pub fn clear_passiveConnectCount(&mut self) {
        self.passiveConnectCount = 0;
    }

    // Param is passed by value, moved
    pub fn set_passiveConnectCount(&mut self, v: i32) {
        self.passiveConnectCount = v;
    }

    // int64 totalFlow = 7;


    pub fn get_totalFlow(&self) -> i64 {
        self.totalFlow
    }
    pub fn clear_totalFlow(&mut self) {
        self.totalFlow = 0;
    }

    // Param is passed by value, moved
    pub fn set_totalFlow(&mut self, v: i64) {
        self.totalFlow = v;
    }

    // repeated .protocol.NodeInfo.PeerInfo peerInfoList = 8;


    pub fn get_peerInfoList(&self) -> &[NodeInfo_PeerInfo] {
        &self.peerInfoList
    }
    pub fn clear_peerInfoList(&mut self) {
        self.peerInfoList.clear();
    }

    // Param is passed by value, moved
    pub fn set_peerInfoList(&mut self, v: ::protobuf::RepeatedField<NodeInfo_PeerInfo>) {
        self.peerInfoList = v;
    }

    // Mutable pointer to the field.
    pub fn mut_peerInfoList(&mut self) -> &mut ::protobuf::RepeatedField<NodeInfo_PeerInfo> {
        &mut self.peerInfoList
    }

    // Take field
    pub fn take_peerInfoList(&mut self) -> ::protobuf::RepeatedField<NodeInfo_PeerInfo> {
        ::std::mem::replace(&mut self.peerInfoList, ::protobuf::RepeatedField::new())
    }

    // .protocol.NodeInfo.ConfigNodeInfo configNodeInfo = 9;


    pub fn get_configNodeInfo(&self) -> &NodeInfo_ConfigNodeInfo {
        self.configNodeInfo.as_ref().unwrap_or_else(|| NodeInfo_ConfigNodeInfo::default_instance())
    }
    pub fn clear_configNodeInfo(&mut self) {
        self.configNodeInfo.clear();
    }

    pub fn has_configNodeInfo(&self) -> bool {
        self.configNodeInfo.is_some()
    }

    // Param is passed by value, moved
    pub fn set_configNodeInfo(&mut self, v: NodeInfo_ConfigNodeInfo) {
        self.configNodeInfo = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_configNodeInfo(&mut self) -> &mut NodeInfo_ConfigNodeInfo {
        if self.configNodeInfo.is_none() {
            self.configNodeInfo.set_default();
        }
        self.configNodeInfo.as_mut().unwrap()
    }

    // Take field
    pub fn take_configNodeInfo(&mut self) -> NodeInfo_ConfigNodeInfo {
        self.configNodeInfo.take().unwrap_or_else(|| NodeInfo_ConfigNodeInfo::new())
    }

    // .protocol.NodeInfo.MachineInfo machineInfo = 10;


    pub fn get_machineInfo(&self) -> &NodeInfo_MachineInfo {
        self.machineInfo.as_ref().unwrap_or_else(|| NodeInfo_MachineInfo::default_instance())
    }
    pub fn clear_machineInfo(&mut self) {
        self.machineInfo.clear();
    }

    pub fn has_machineInfo(&self) -> bool {
        self.machineInfo.is_some()
    }

    // Param is passed by value, moved
    pub fn set_machineInfo(&mut self, v: NodeInfo_MachineInfo) {
        self.machineInfo = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_machineInfo(&mut self) -> &mut NodeInfo_MachineInfo {
        if self.machineInfo.is_none() {
            self.machineInfo.set_default();
        }
        self.machineInfo.as_mut().unwrap()
    }

    // Take field
    pub fn take_machineInfo(&mut self) -> NodeInfo_MachineInfo {
        self.machineInfo.take().unwrap_or_else(|| NodeInfo_MachineInfo::new())
    }

    // repeated .protocol.NodeInfo.CheatWitnessInfoMapEntry cheatWitnessInfoMap = 11;


    pub fn get_cheatWitnessInfoMap(&self) -> &::std::collections::HashMap<::std::string::String, ::std::string::String> {
        &self.cheatWitnessInfoMap
    }
    pub fn clear_cheatWitnessInfoMap(&mut self) {
        self.cheatWitnessInfoMap.clear();
    }

    // Param is passed by value, moved
    pub fn set_cheatWitnessInfoMap(&mut self, v: ::std::collections::HashMap<::std::string::String, ::std::string::String>) {
        self.cheatWitnessInfoMap = v;
    }

    // Mutable pointer to the field.
    pub fn mut_cheatWitnessInfoMap(&mut self) -> &mut ::std::collections::HashMap<::std::string::String, ::std::string::String> {
        &mut self.cheatWitnessInfoMap
    }

    // Take field
    pub fn take_cheatWitnessInfoMap(&mut self) -> ::std::collections::HashMap<::std::string::String, ::std::string::String> {
        ::std::mem::replace(&mut self.cheatWitnessInfoMap, ::std::collections::HashMap::new())
    }
}

impl ::protobuf::Message for NodeInfo {
    fn is_initialized(&self) -> bool {
        for v in &self.peerInfoList {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.configNodeInfo {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.machineInfo {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.beginSyncNum = tmp;
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.block)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.solidityBlock)?;
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.currentConnectCount = tmp;
                },
                5 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.activeConnectCount = tmp;
                },
                6 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.passiveConnectCount = tmp;
                },
                7 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.totalFlow = tmp;
                },
                8 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.peerInfoList)?;
                },
                9 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.configNodeInfo)?;
                },
                10 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.machineInfo)?;
                },
                11 => {
                    ::protobuf::rt::read_map_into::<::protobuf::types::ProtobufTypeString, ::protobuf::types::ProtobufTypeString>(wire_type, is, &mut self.cheatWitnessInfoMap)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.beginSyncNum != 0 {
            my_size += ::protobuf::rt::value_size(1, self.beginSyncNum, ::protobuf::wire_format::WireTypeVarint);
        }
        if !self.block.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.block);
        }
        if !self.solidityBlock.is_empty() {
            my_size += ::protobuf::rt::string_size(3, &self.solidityBlock);
        }
        if self.currentConnectCount != 0 {
            my_size += ::protobuf::rt::value_size(4, self.currentConnectCount, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.activeConnectCount != 0 {
            my_size += ::protobuf::rt::value_size(5, self.activeConnectCount, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.passiveConnectCount != 0 {
            my_size += ::protobuf::rt::value_size(6, self.passiveConnectCount, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.totalFlow != 0 {
            my_size += ::protobuf::rt::value_size(7, self.totalFlow, ::protobuf::wire_format::WireTypeVarint);
        }
        for value in &self.peerInfoList {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        if let Some(ref v) = self.configNodeInfo.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.machineInfo.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::compute_map_size::<::protobuf::types::ProtobufTypeString, ::protobuf::types::ProtobufTypeString>(11, &self.cheatWitnessInfoMap);
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if self.beginSyncNum != 0 {
            os.write_int64(1, self.beginSyncNum)?;
        }
        if !self.block.is_empty() {
            os.write_string(2, &self.block)?;
        }
        if !self.solidityBlock.is_empty() {
            os.write_string(3, &self.solidityBlock)?;
        }
        if self.currentConnectCount != 0 {
            os.write_int32(4, self.currentConnectCount)?;
        }
        if self.activeConnectCount != 0 {
            os.write_int32(5, self.activeConnectCount)?;
        }
        if self.passiveConnectCount != 0 {
            os.write_int32(6, self.passiveConnectCount)?;
        }
        if self.totalFlow != 0 {
            os.write_int64(7, self.totalFlow)?;
        }
        for v in &self.peerInfoList {
            os.write_tag(8, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        if let Some(ref v) = self.configNodeInfo.as_ref() {
            os.write_tag(9, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.machineInfo.as_ref() {
            os.write_tag(10, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        ::protobuf::rt::write_map_with_cached_sizes::<::protobuf::types::ProtobufTypeString, ::protobuf::types::ProtobufTypeString>(11, &self.cheatWitnessInfoMap, os)?;
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> NodeInfo {
        NodeInfo::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                    "beginSyncNum",
                    |m: &NodeInfo| { &m.beginSyncNum },
                    |m: &mut NodeInfo| { &mut m.beginSyncNum },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "block",
                    |m: &NodeInfo| { &m.block },
                    |m: &mut NodeInfo| { &mut m.block },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "solidityBlock",
                    |m: &NodeInfo| { &m.solidityBlock },
                    |m: &mut NodeInfo| { &mut m.solidityBlock },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                    "currentConnectCount",
                    |m: &NodeInfo| { &m.currentConnectCount },
                    |m: &mut NodeInfo| { &mut m.currentConnectCount },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                    "activeConnectCount",
                    |m: &NodeInfo| { &m.activeConnectCount },
                    |m: &mut NodeInfo| { &mut m.activeConnectCount },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                    "passiveConnectCount",
                    |m: &NodeInfo| { &m.passiveConnectCount },
                    |m: &mut NodeInfo| { &mut m.passiveConnectCount },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                    "totalFlow",
                    |m: &NodeInfo| { &m.totalFlow },
                    |m: &mut NodeInfo| { &mut m.totalFlow },
                ));
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<NodeInfo_PeerInfo>>(
                    "peerInfoList",
                    |m: &NodeInfo| { &m.peerInfoList },
                    |m: &mut NodeInfo| { &mut m.peerInfoList },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<NodeInfo_ConfigNodeInfo>>(
                    "configNodeInfo",
                    |m: &NodeInfo| { &m.configNodeInfo },
                    |m: &mut NodeInfo| { &mut m.configNodeInfo },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<NodeInfo_MachineInfo>>(
                    "machineInfo",
                    |m: &NodeInfo| { &m.machineInfo },
                    |m: &mut NodeInfo| { &mut m.machineInfo },
                ));
                fields.push(::protobuf::reflect::accessor::make_map_accessor::<_, ::protobuf::types::ProtobufTypeString, ::protobuf::types::ProtobufTypeString>(
                    "cheatWitnessInfoMap",
                    |m: &NodeInfo| { &m.cheatWitnessInfoMap },
                    |m: &mut NodeInfo| { &mut m.cheatWitnessInfoMap },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<NodeInfo>(
                    "NodeInfo",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static NodeInfo {
        static mut instance: ::protobuf::lazy::Lazy<NodeInfo> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const NodeInfo,
        };
        unsafe {
            instance.get(NodeInfo::new)
        }
    }
}

impl ::protobuf::Clear for NodeInfo {
    fn clear(&mut self) {
        self.beginSyncNum = 0;
        self.block.clear();
        self.solidityBlock.clear();
        self.currentConnectCount = 0;
        self.activeConnectCount = 0;
        self.passiveConnectCount = 0;
        self.totalFlow = 0;
        self.peerInfoList.clear();
        self.configNodeInfo.clear();
        self.machineInfo.clear();
        self.cheatWitnessInfoMap.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for NodeInfo {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for NodeInfo {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct NodeInfo_PeerInfo {
    // message fields
    pub lastSyncBlock: ::std::string::String,
    pub remainNum: i64,
    pub lastBlockUpdateTime: i64,
    pub syncFlag: bool,
    pub headBlockTimeWeBothHave: i64,
    pub needSyncFromPeer: bool,
    pub needSyncFromUs: bool,
    pub host: ::std::string::String,
    pub port: i32,
    pub nodeId: ::std::string::String,
    pub connectTime: i64,
    pub avgLatency: f64,
    pub syncToFetchSize: i32,
    pub syncToFetchSizePeekNum: i64,
    pub syncBlockRequestedSize: i32,
    pub unFetchSynNum: i64,
    pub blockInPorcSize: i32,
    pub headBlockWeBothHave: ::std::string::String,
    pub isActive: bool,
    pub score: i32,
    pub nodeCount: i32,
    pub inFlow: i64,
    pub disconnectTimes: i32,
    pub localDisconnectReason: ::std::string::String,
    pub remoteDisconnectReason: ::std::string::String,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a NodeInfo_PeerInfo {
    fn default() -> &'a NodeInfo_PeerInfo {
        <NodeInfo_PeerInfo as ::protobuf::Message>::default_instance()
    }
}

impl NodeInfo_PeerInfo {
    pub fn new() -> NodeInfo_PeerInfo {
        ::std::default::Default::default()
    }

    // string lastSyncBlock = 1;


    pub fn get_lastSyncBlock(&self) -> &str {
        &self.lastSyncBlock
    }
    pub fn clear_lastSyncBlock(&mut self) {
        self.lastSyncBlock.clear();
    }

    // Param is passed by value, moved
    pub fn set_lastSyncBlock(&mut self, v: ::std::string::String) {
        self.lastSyncBlock = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_lastSyncBlock(&mut self) -> &mut ::std::string::String {
        &mut self.lastSyncBlock
    }

    // Take field
    pub fn take_lastSyncBlock(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.lastSyncBlock, ::std::string::String::new())
    }

    // int64 remainNum = 2;


    pub fn get_remainNum(&self) -> i64 {
        self.remainNum
    }
    pub fn clear_remainNum(&mut self) {
        self.remainNum = 0;
    }

    // Param is passed by value, moved
    pub fn set_remainNum(&mut self, v: i64) {
        self.remainNum = v;
    }

    // int64 lastBlockUpdateTime = 3;


    pub fn get_lastBlockUpdateTime(&self) -> i64 {
        self.lastBlockUpdateTime
    }
    pub fn clear_lastBlockUpdateTime(&mut self) {
        self.lastBlockUpdateTime = 0;
    }

    // Param is passed by value, moved
    pub fn set_lastBlockUpdateTime(&mut self, v: i64) {
        self.lastBlockUpdateTime = v;
    }

    // bool syncFlag = 4;


    pub fn get_syncFlag(&self) -> bool {
        self.syncFlag
    }
    pub fn clear_syncFlag(&mut self) {
        self.syncFlag = false;
    }

    // Param is passed by value, moved
    pub fn set_syncFlag(&mut self, v: bool) {
        self.syncFlag = v;
    }

    // int64 headBlockTimeWeBothHave = 5;


    pub fn get_headBlockTimeWeBothHave(&self) -> i64 {
        self.headBlockTimeWeBothHave
    }
    pub fn clear_headBlockTimeWeBothHave(&mut self) {
        self.headBlockTimeWeBothHave = 0;
    }

    // Param is passed by value, moved
    pub fn set_headBlockTimeWeBothHave(&mut self, v: i64) {
        self.headBlockTimeWeBothHave = v;
    }

    // bool needSyncFromPeer = 6;


    pub fn get_needSyncFromPeer(&self) -> bool {
        self.needSyncFromPeer
    }
    pub fn clear_needSyncFromPeer(&mut self) {
        self.needSyncFromPeer = false;
    }

    // Param is passed by value, moved
    pub fn set_needSyncFromPeer(&mut self, v: bool) {
        self.needSyncFromPeer = v;
    }

    // bool needSyncFromUs = 7;


    pub fn get_needSyncFromUs(&self) -> bool {
        self.needSyncFromUs
    }
    pub fn clear_needSyncFromUs(&mut self) {
        self.needSyncFromUs = false;
    }

    // Param is passed by value, moved
    pub fn set_needSyncFromUs(&mut self, v: bool) {
        self.needSyncFromUs = v;
    }

    // string host = 8;


    pub fn get_host(&self) -> &str {
        &self.host
    }
    pub fn clear_host(&mut self) {
        self.host.clear();
    }

    // Param is passed by value, moved
    pub fn set_host(&mut self, v: ::std::string::String) {
        self.host = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_host(&mut self) -> &mut ::std::string::String {
        &mut self.host
    }

    // Take field
    pub fn take_host(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.host, ::std::string::String::new())
    }

    // int32 port = 9;


    pub fn get_port(&self) -> i32 {
        self.port
    }
    pub fn clear_port(&mut self) {
        self.port = 0;
    }

    // Param is passed by value, moved
    pub fn set_port(&mut self, v: i32) {
        self.port = v;
    }

    // string nodeId = 10;


    pub fn get_nodeId(&self) -> &str {
        &self.nodeId
    }
    pub fn clear_nodeId(&mut self) {
        self.nodeId.clear();
    }

    // Param is passed by value, moved
    pub fn set_nodeId(&mut self, v: ::std::string::String) {
        self.nodeId = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_nodeId(&mut self) -> &mut ::std::string::String {
        &mut self.nodeId
    }

    // Take field
    pub fn take_nodeId(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.nodeId, ::std::string::String::new())
    }

    // int64 connectTime = 11;


    pub fn get_connectTime(&self) -> i64 {
        self.connectTime
    }
    pub fn clear_connectTime(&mut self) {
        self.connectTime = 0;
    }

    // Param is passed by value, moved
    pub fn set_connectTime(&mut self, v: i64) {
        self.connectTime = v;
    }

    // double avgLatency = 12;


    pub fn get_avgLatency(&self) -> f64 {
        self.avgLatency
    }
    pub fn clear_avgLatency(&mut self) {
        self.avgLatency = 0.;
    }

    // Param is passed by value, moved
    pub fn set_avgLatency(&mut self, v: f64) {
        self.avgLatency = v;
    }

    // int32 syncToFetchSize = 13;


    pub fn get_syncToFetchSize(&self) -> i32 {
        self.syncToFetchSize
    }
    pub fn clear_syncToFetchSize(&mut self) {
        self.syncToFetchSize = 0;
    }

    // Param is passed by value, moved
    pub fn set_syncToFetchSize(&mut self, v: i32) {
        self.syncToFetchSize = v;
    }

    // int64 syncToFetchSizePeekNum = 14;


    pub fn get_syncToFetchSizePeekNum(&self) -> i64 {
        self.syncToFetchSizePeekNum
    }
    pub fn clear_syncToFetchSizePeekNum(&mut self) {
        self.syncToFetchSizePeekNum = 0;
    }

    // Param is passed by value, moved
    pub fn set_syncToFetchSizePeekNum(&mut self, v: i64) {
        self.syncToFetchSizePeekNum = v;
    }

    // int32 syncBlockRequestedSize = 15;


    pub fn get_syncBlockRequestedSize(&self) -> i32 {
        self.syncBlockRequestedSize
    }
    pub fn clear_syncBlockRequestedSize(&mut self) {
        self.syncBlockRequestedSize = 0;
    }

    // Param is passed by value, moved
    pub fn set_syncBlockRequestedSize(&mut self, v: i32) {
        self.syncBlockRequestedSize = v;
    }

    // int64 unFetchSynNum = 16;


    pub fn get_unFetchSynNum(&self) -> i64 {
        self.unFetchSynNum
    }
    pub fn clear_unFetchSynNum(&mut self) {
        self.unFetchSynNum = 0;
    }

    // Param is passed by value, moved
    pub fn set_unFetchSynNum(&mut self, v: i64) {
        self.unFetchSynNum = v;
    }

    // int32 blockInPorcSize = 17;


    pub fn get_blockInPorcSize(&self) -> i32 {
        self.blockInPorcSize
    }
    pub fn clear_blockInPorcSize(&mut self) {
        self.blockInPorcSize = 0;
    }

    // Param is passed by value, moved
    pub fn set_blockInPorcSize(&mut self, v: i32) {
        self.blockInPorcSize = v;
    }

    // string headBlockWeBothHave = 18;


    pub fn get_headBlockWeBothHave(&self) -> &str {
        &self.headBlockWeBothHave
    }
    pub fn clear_headBlockWeBothHave(&mut self) {
        self.headBlockWeBothHave.clear();
    }

    // Param is passed by value, moved
    pub fn set_headBlockWeBothHave(&mut self, v: ::std::string::String) {
        self.headBlockWeBothHave = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_headBlockWeBothHave(&mut self) -> &mut ::std::string::String {
        &mut self.headBlockWeBothHave
    }

    // Take field
    pub fn take_headBlockWeBothHave(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.headBlockWeBothHave, ::std::string::String::new())
    }

    // bool isActive = 19;


    pub fn get_isActive(&self) -> bool {
        self.isActive
    }
    pub fn clear_isActive(&mut self) {
        self.isActive = false;
    }

    // Param is passed by value, moved
    pub fn set_isActive(&mut self, v: bool) {
        self.isActive = v;
    }

    // int32 score = 20;


    pub fn get_score(&self) -> i32 {
        self.score
    }
    pub fn clear_score(&mut self) {
        self.score = 0;
    }

    // Param is passed by value, moved
    pub fn set_score(&mut self, v: i32) {
        self.score = v;
    }

    // int32 nodeCount = 21;


    pub fn get_nodeCount(&self) -> i32 {
        self.nodeCount
    }
    pub fn clear_nodeCount(&mut self) {
        self.nodeCount = 0;
    }

    // Param is passed by value, moved
    pub fn set_nodeCount(&mut self, v: i32) {
        self.nodeCount = v;
    }

    // int64 inFlow = 22;


    pub fn get_inFlow(&self) -> i64 {
        self.inFlow
    }
    pub fn clear_inFlow(&mut self) {
        self.inFlow = 0;
    }

    // Param is passed by value, moved
    pub fn set_inFlow(&mut self, v: i64) {
        self.inFlow = v;
    }

    // int32 disconnectTimes = 23;


    pub fn get_disconnectTimes(&self) -> i32 {
        self.disconnectTimes
    }
    pub fn clear_disconnectTimes(&mut self) {
        self.disconnectTimes = 0;
    }

    // Param is passed by value, moved
    pub fn set_disconnectTimes(&mut self, v: i32) {
        self.disconnectTimes = v;
    }

    // string localDisconnectReason = 24;


    pub fn get_localDisconnectReason(&self) -> &str {
        &self.localDisconnectReason
    }
    pub fn clear_localDisconnectReason(&mut self) {
        self.localDisconnectReason.clear();
    }

    // Param is passed by value, moved
    pub fn set_localDisconnectReason(&mut self, v: ::std::string::String) {
        self.localDisconnectReason = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_localDisconnectReason(&mut self) -> &mut ::std::string::String {
        &mut self.localDisconnectReason
    }

    // Take field
    pub fn take_localDisconnectReason(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.localDisconnectReason, ::std::string::String::new())
    }

    // string remoteDisconnectReason = 25;


    pub fn get_remoteDisconnectReason(&self) -> &str {
        &self.remoteDisconnectReason
    }
    pub fn clear_remoteDisconnectReason(&mut self) {
        self.remoteDisconnectReason.clear();
    }

    // Param is passed by value, moved
    pub fn set_remoteDisconnectReason(&mut self, v: ::std::string::String) {
        self.remoteDisconnectReason = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_remoteDisconnectReason(&mut self) -> &mut ::std::string::String {
        &mut self.remoteDisconnectReason
    }

    // Take field
    pub fn take_remoteDisconnectReason(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.remoteDisconnectReason, ::std::string::String::new())
    }
}

impl ::protobuf::Message for NodeInfo_PeerInfo {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.lastSyncBlock)?;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.remainNum = tmp;
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.lastBlockUpdateTime = tmp;
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.syncFlag = tmp;
                },
                5 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.headBlockTimeWeBothHave = tmp;
                },
                6 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.needSyncFromPeer = tmp;
                },
                7 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.needSyncFromUs = tmp;
                },
                8 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.host)?;
                },
                9 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.port = tmp;
                },
                10 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.nodeId)?;
                },
                11 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.connectTime = tmp;
                },
                12 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed64 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_double()?;
                    self.avgLatency = tmp;
                },
                13 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.syncToFetchSize = tmp;
                },
                14 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.syncToFetchSizePeekNum = tmp;
                },
                15 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.syncBlockRequestedSize = tmp;
                },
                16 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.unFetchSynNum = tmp;
                },
                17 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.blockInPorcSize = tmp;
                },
                18 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.headBlockWeBothHave)?;
                },
                19 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.isActive = tmp;
                },
                20 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.score = tmp;
                },
                21 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.nodeCount = tmp;
                },
                22 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.inFlow = tmp;
                },
                23 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.disconnectTimes = tmp;
                },
                24 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.localDisconnectReason)?;
                },
                25 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.remoteDisconnectReason)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.lastSyncBlock.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.lastSyncBlock);
        }
        if self.remainNum != 0 {
            my_size += ::protobuf::rt::value_size(2, self.remainNum, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.lastBlockUpdateTime != 0 {
            my_size += ::protobuf::rt::value_size(3, self.lastBlockUpdateTime, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.syncFlag != false {
            my_size += 2;
        }
        if self.headBlockTimeWeBothHave != 0 {
            my_size += ::protobuf::rt::value_size(5, self.headBlockTimeWeBothHave, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.needSyncFromPeer != false {
            my_size += 2;
        }
        if self.needSyncFromUs != false {
            my_size += 2;
        }
        if !self.host.is_empty() {
            my_size += ::protobuf::rt::string_size(8, &self.host);
        }
        if self.port != 0 {
            my_size += ::protobuf::rt::value_size(9, self.port, ::protobuf::wire_format::WireTypeVarint);
        }
        if !self.nodeId.is_empty() {
            my_size += ::protobuf::rt::string_size(10, &self.nodeId);
        }
        if self.connectTime != 0 {
            my_size += ::protobuf::rt::value_size(11, self.connectTime, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.avgLatency != 0. {
            my_size += 9;
        }
        if self.syncToFetchSize != 0 {
            my_size += ::protobuf::rt::value_size(13, self.syncToFetchSize, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.syncToFetchSizePeekNum != 0 {
            my_size += ::protobuf::rt::value_size(14, self.syncToFetchSizePeekNum, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.syncBlockRequestedSize != 0 {
            my_size += ::protobuf::rt::value_size(15, self.syncBlockRequestedSize, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.unFetchSynNum != 0 {
            my_size += ::protobuf::rt::value_size(16, self.unFetchSynNum, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.blockInPorcSize != 0 {
            my_size += ::protobuf::rt::value_size(17, self.blockInPorcSize, ::protobuf::wire_format::WireTypeVarint);
        }
        if !self.headBlockWeBothHave.is_empty() {
            my_size += ::protobuf::rt::string_size(18, &self.headBlockWeBothHave);
        }
        if self.isActive != false {
            my_size += 3;
        }
        if self.score != 0 {
            my_size += ::protobuf::rt::value_size(20, self.score, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.nodeCount != 0 {
            my_size += ::protobuf::rt::value_size(21, self.nodeCount, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.inFlow != 0 {
            my_size += ::protobuf::rt::value_size(22, self.inFlow, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.disconnectTimes != 0 {
            my_size += ::protobuf::rt::value_size(23, self.disconnectTimes, ::protobuf::wire_format::WireTypeVarint);
        }
        if !self.localDisconnectReason.is_empty() {
            my_size += ::protobuf::rt::string_size(24, &self.localDisconnectReason);
        }
        if !self.remoteDisconnectReason.is_empty() {
            my_size += ::protobuf::rt::string_size(25, &self.remoteDisconnectReason);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if !self.lastSyncBlock.is_empty() {
            os.write_string(1, &self.lastSyncBlock)?;
        }
        if self.remainNum != 0 {
            os.write_int64(2, self.remainNum)?;
        }
        if self.lastBlockUpdateTime != 0 {
            os.write_int64(3, self.lastBlockUpdateTime)?;
        }
        if self.syncFlag != false {
            os.write_bool(4, self.syncFlag)?;
        }
        if self.headBlockTimeWeBothHave != 0 {
            os.write_int64(5, self.headBlockTimeWeBothHave)?;
        }
        if self.needSyncFromPeer != false {
            os.write_bool(6, self.needSyncFromPeer)?;
        }
        if self.needSyncFromUs != false {
            os.write_bool(7, self.needSyncFromUs)?;
        }
        if !self.host.is_empty() {
            os.write_string(8, &self.host)?;
        }
        if self.port != 0 {
            os.write_int32(9, self.port)?;
        }
        if !self.nodeId.is_empty() {
            os.write_string(10, &self.nodeId)?;
        }
        if self.connectTime != 0 {
            os.write_int64(11, self.connectTime)?;
        }
        if self.avgLatency != 0. {
            os.write_double(12, self.avgLatency)?;
        }
        if self.syncToFetchSize != 0 {
            os.write_int32(13, self.syncToFetchSize)?;
        }
        if self.syncToFetchSizePeekNum != 0 {
            os.write_int64(14, self.syncToFetchSizePeekNum)?;
        }
        if self.syncBlockRequestedSize != 0 {
            os.write_int32(15, self.syncBlockRequestedSize)?;
        }
        if self.unFetchSynNum != 0 {
            os.write_int64(16, self.unFetchSynNum)?;
        }
        if self.blockInPorcSize != 0 {
            os.write_int32(17, self.blockInPorcSize)?;
        }
        if !self.headBlockWeBothHave.is_empty() {
            os.write_string(18, &self.headBlockWeBothHave)?;
        }
        if self.isActive != false {
            os.write_bool(19, self.isActive)?;
        }
        if self.score != 0 {
            os.write_int32(20, self.score)?;
        }
        if self.nodeCount != 0 {
            os.write_int32(21, self.nodeCount)?;
        }
        if self.inFlow != 0 {
            os.write_int64(22, self.inFlow)?;
        }
        if self.disconnectTimes != 0 {
            os.write_int32(23, self.disconnectTimes)?;
        }
        if !self.localDisconnectReason.is_empty() {
            os.write_string(24, &self.localDisconnectReason)?;
        }
        if !self.remoteDisconnectReason.is_empty() {
            os.write_string(25, &self.remoteDisconnectReason)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> NodeInfo_PeerInfo {
        NodeInfo_PeerInfo::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "lastSyncBlock",
                    |m: &NodeInfo_PeerInfo| { &m.lastSyncBlock },
                    |m: &mut NodeInfo_PeerInfo| { &mut m.lastSyncBlock },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                    "remainNum",
                    |m: &NodeInfo_PeerInfo| { &m.remainNum },
                    |m: &mut NodeInfo_PeerInfo| { &mut m.remainNum },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                    "lastBlockUpdateTime",
                    |m: &NodeInfo_PeerInfo| { &m.lastBlockUpdateTime },
                    |m: &mut NodeInfo_PeerInfo| { &mut m.lastBlockUpdateTime },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                    "syncFlag",
                    |m: &NodeInfo_PeerInfo| { &m.syncFlag },
                    |m: &mut NodeInfo_PeerInfo| { &mut m.syncFlag },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                    "headBlockTimeWeBothHave",
                    |m: &NodeInfo_PeerInfo| { &m.headBlockTimeWeBothHave },
                    |m: &mut NodeInfo_PeerInfo| { &mut m.headBlockTimeWeBothHave },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                    "needSyncFromPeer",
                    |m: &NodeInfo_PeerInfo| { &m.needSyncFromPeer },
                    |m: &mut NodeInfo_PeerInfo| { &mut m.needSyncFromPeer },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                    "needSyncFromUs",
                    |m: &NodeInfo_PeerInfo| { &m.needSyncFromUs },
                    |m: &mut NodeInfo_PeerInfo| { &mut m.needSyncFromUs },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "host",
                    |m: &NodeInfo_PeerInfo| { &m.host },
                    |m: &mut NodeInfo_PeerInfo| { &mut m.host },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                    "port",
                    |m: &NodeInfo_PeerInfo| { &m.port },
                    |m: &mut NodeInfo_PeerInfo| { &mut m.port },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "nodeId",
                    |m: &NodeInfo_PeerInfo| { &m.nodeId },
                    |m: &mut NodeInfo_PeerInfo| { &mut m.nodeId },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                    "connectTime",
                    |m: &NodeInfo_PeerInfo| { &m.connectTime },
                    |m: &mut NodeInfo_PeerInfo| { &mut m.connectTime },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeDouble>(
                    "avgLatency",
                    |m: &NodeInfo_PeerInfo| { &m.avgLatency },
                    |m: &mut NodeInfo_PeerInfo| { &mut m.avgLatency },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                    "syncToFetchSize",
                    |m: &NodeInfo_PeerInfo| { &m.syncToFetchSize },
                    |m: &mut NodeInfo_PeerInfo| { &mut m.syncToFetchSize },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                    "syncToFetchSizePeekNum",
                    |m: &NodeInfo_PeerInfo| { &m.syncToFetchSizePeekNum },
                    |m: &mut NodeInfo_PeerInfo| { &mut m.syncToFetchSizePeekNum },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                    "syncBlockRequestedSize",
                    |m: &NodeInfo_PeerInfo| { &m.syncBlockRequestedSize },
                    |m: &mut NodeInfo_PeerInfo| { &mut m.syncBlockRequestedSize },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                    "unFetchSynNum",
                    |m: &NodeInfo_PeerInfo| { &m.unFetchSynNum },
                    |m: &mut NodeInfo_PeerInfo| { &mut m.unFetchSynNum },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                    "blockInPorcSize",
                    |m: &NodeInfo_PeerInfo| { &m.blockInPorcSize },
                    |m: &mut NodeInfo_PeerInfo| { &mut m.blockInPorcSize },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "headBlockWeBothHave",
                    |m: &NodeInfo_PeerInfo| { &m.headBlockWeBothHave },
                    |m: &mut NodeInfo_PeerInfo| { &mut m.headBlockWeBothHave },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                    "isActive",
                    |m: &NodeInfo_PeerInfo| { &m.isActive },
                    |m: &mut NodeInfo_PeerInfo| { &mut m.isActive },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                    "score",
                    |m: &NodeInfo_PeerInfo| { &m.score },
                    |m: &mut NodeInfo_PeerInfo| { &mut m.score },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                    "nodeCount",
                    |m: &NodeInfo_PeerInfo| { &m.nodeCount },
                    |m: &mut NodeInfo_PeerInfo| { &mut m.nodeCount },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                    "inFlow",
                    |m: &NodeInfo_PeerInfo| { &m.inFlow },
                    |m: &mut NodeInfo_PeerInfo| { &mut m.inFlow },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                    "disconnectTimes",
                    |m: &NodeInfo_PeerInfo| { &m.disconnectTimes },
                    |m: &mut NodeInfo_PeerInfo| { &mut m.disconnectTimes },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "localDisconnectReason",
                    |m: &NodeInfo_PeerInfo| { &m.localDisconnectReason },
                    |m: &mut NodeInfo_PeerInfo| { &mut m.localDisconnectReason },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "remoteDisconnectReason",
                    |m: &NodeInfo_PeerInfo| { &m.remoteDisconnectReason },
                    |m: &mut NodeInfo_PeerInfo| { &mut m.remoteDisconnectReason },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<NodeInfo_PeerInfo>(
                    "NodeInfo_PeerInfo",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static NodeInfo_PeerInfo {
        static mut instance: ::protobuf::lazy::Lazy<NodeInfo_PeerInfo> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const NodeInfo_PeerInfo,
        };
        unsafe {
            instance.get(NodeInfo_PeerInfo::new)
        }
    }
}

impl ::protobuf::Clear for NodeInfo_PeerInfo {
    fn clear(&mut self) {
        self.lastSyncBlock.clear();
        self.remainNum = 0;
        self.lastBlockUpdateTime = 0;
        self.syncFlag = false;
        self.headBlockTimeWeBothHave = 0;
        self.needSyncFromPeer = false;
        self.needSyncFromUs = false;
        self.host.clear();
        self.port = 0;
        self.nodeId.clear();
        self.connectTime = 0;
        self.avgLatency = 0.;
        self.syncToFetchSize = 0;
        self.syncToFetchSizePeekNum = 0;
        self.syncBlockRequestedSize = 0;
        self.unFetchSynNum = 0;
        self.blockInPorcSize = 0;
        self.headBlockWeBothHave.clear();
        self.isActive = false;
        self.score = 0;
        self.nodeCount = 0;
        self.inFlow = 0;
        self.disconnectTimes = 0;
        self.localDisconnectReason.clear();
        self.remoteDisconnectReason.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for NodeInfo_PeerInfo {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for NodeInfo_PeerInfo {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct NodeInfo_ConfigNodeInfo {
    // message fields
    pub codeVersion: ::std::string::String,
    pub p2pVersion: ::std::string::String,
    pub listenPort: i32,
    pub discoverEnable: bool,
    pub activeNodeSize: i32,
    pub passiveNodeSize: i32,
    pub sendNodeSize: i32,
    pub maxConnectCount: i32,
    pub sameIpMaxConnectCount: i32,
    pub backupListenPort: i32,
    pub backupMemberSize: i32,
    pub backupPriority: i32,
    pub dbVersion: i32,
    pub minParticipationRate: i32,
    pub supportConstant: bool,
    pub minTimeRatio: f64,
    pub maxTimeRatio: f64,
    pub allowCreationOfContracts: i64,
    pub allowAdaptiveEnergy: i64,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a NodeInfo_ConfigNodeInfo {
    fn default() -> &'a NodeInfo_ConfigNodeInfo {
        <NodeInfo_ConfigNodeInfo as ::protobuf::Message>::default_instance()
    }
}

impl NodeInfo_ConfigNodeInfo {
    pub fn new() -> NodeInfo_ConfigNodeInfo {
        ::std::default::Default::default()
    }

    // string codeVersion = 1;


    pub fn get_codeVersion(&self) -> &str {
        &self.codeVersion
    }
    pub fn clear_codeVersion(&mut self) {
        self.codeVersion.clear();
    }

    // Param is passed by value, moved
    pub fn set_codeVersion(&mut self, v: ::std::string::String) {
        self.codeVersion = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_codeVersion(&mut self) -> &mut ::std::string::String {
        &mut self.codeVersion
    }

    // Take field
    pub fn take_codeVersion(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.codeVersion, ::std::string::String::new())
    }

    // string p2pVersion = 2;


    pub fn get_p2pVersion(&self) -> &str {
        &self.p2pVersion
    }
    pub fn clear_p2pVersion(&mut self) {
        self.p2pVersion.clear();
    }

    // Param is passed by value, moved
    pub fn set_p2pVersion(&mut self, v: ::std::string::String) {
        self.p2pVersion = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_p2pVersion(&mut self) -> &mut ::std::string::String {
        &mut self.p2pVersion
    }

    // Take field
    pub fn take_p2pVersion(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.p2pVersion, ::std::string::String::new())
    }

    // int32 listenPort = 3;


    pub fn get_listenPort(&self) -> i32 {
        self.listenPort
    }
    pub fn clear_listenPort(&mut self) {
        self.listenPort = 0;
    }

    // Param is passed by value, moved
    pub fn set_listenPort(&mut self, v: i32) {
        self.listenPort = v;
    }

    // bool discoverEnable = 4;


    pub fn get_discoverEnable(&self) -> bool {
        self.discoverEnable
    }
    pub fn clear_discoverEnable(&mut self) {
        self.discoverEnable = false;
    }

    // Param is passed by value, moved
    pub fn set_discoverEnable(&mut self, v: bool) {
        self.discoverEnable = v;
    }

    // int32 activeNodeSize = 5;


    pub fn get_activeNodeSize(&self) -> i32 {
        self.activeNodeSize
    }
    pub fn clear_activeNodeSize(&mut self) {
        self.activeNodeSize = 0;
    }

    // Param is passed by value, moved
    pub fn set_activeNodeSize(&mut self, v: i32) {
        self.activeNodeSize = v;
    }

    // int32 passiveNodeSize = 6;


    pub fn get_passiveNodeSize(&self) -> i32 {
        self.passiveNodeSize
    }
    pub fn clear_passiveNodeSize(&mut self) {
        self.passiveNodeSize = 0;
    }

    // Param is passed by value, moved
    pub fn set_passiveNodeSize(&mut self, v: i32) {
        self.passiveNodeSize = v;
    }

    // int32 sendNodeSize = 7;


    pub fn get_sendNodeSize(&self) -> i32 {
        self.sendNodeSize
    }
    pub fn clear_sendNodeSize(&mut self) {
        self.sendNodeSize = 0;
    }

    // Param is passed by value, moved
    pub fn set_sendNodeSize(&mut self, v: i32) {
        self.sendNodeSize = v;
    }

    // int32 maxConnectCount = 8;


    pub fn get_maxConnectCount(&self) -> i32 {
        self.maxConnectCount
    }
    pub fn clear_maxConnectCount(&mut self) {
        self.maxConnectCount = 0;
    }

    // Param is passed by value, moved
    pub fn set_maxConnectCount(&mut self, v: i32) {
        self.maxConnectCount = v;
    }

    // int32 sameIpMaxConnectCount = 9;


    pub fn get_sameIpMaxConnectCount(&self) -> i32 {
        self.sameIpMaxConnectCount
    }
    pub fn clear_sameIpMaxConnectCount(&mut self) {
        self.sameIpMaxConnectCount = 0;
    }

    // Param is passed by value, moved
    pub fn set_sameIpMaxConnectCount(&mut self, v: i32) {
        self.sameIpMaxConnectCount = v;
    }

    // int32 backupListenPort = 10;


    pub fn get_backupListenPort(&self) -> i32 {
        self.backupListenPort
    }
    pub fn clear_backupListenPort(&mut self) {
        self.backupListenPort = 0;
    }

    // Param is passed by value, moved
    pub fn set_backupListenPort(&mut self, v: i32) {
        self.backupListenPort = v;
    }

    // int32 backupMemberSize = 11;


    pub fn get_backupMemberSize(&self) -> i32 {
        self.backupMemberSize
    }
    pub fn clear_backupMemberSize(&mut self) {
        self.backupMemberSize = 0;
    }

    // Param is passed by value, moved
    pub fn set_backupMemberSize(&mut self, v: i32) {
        self.backupMemberSize = v;
    }

    // int32 backupPriority = 12;


    pub fn get_backupPriority(&self) -> i32 {
        self.backupPriority
    }
    pub fn clear_backupPriority(&mut self) {
        self.backupPriority = 0;
    }

    // Param is passed by value, moved
    pub fn set_backupPriority(&mut self, v: i32) {
        self.backupPriority = v;
    }

    // int32 dbVersion = 13;


    pub fn get_dbVersion(&self) -> i32 {
        self.dbVersion
    }
    pub fn clear_dbVersion(&mut self) {
        self.dbVersion = 0;
    }

    // Param is passed by value, moved
    pub fn set_dbVersion(&mut self, v: i32) {
        self.dbVersion = v;
    }

    // int32 minParticipationRate = 14;


    pub fn get_minParticipationRate(&self) -> i32 {
        self.minParticipationRate
    }
    pub fn clear_minParticipationRate(&mut self) {
        self.minParticipationRate = 0;
    }

    // Param is passed by value, moved
    pub fn set_minParticipationRate(&mut self, v: i32) {
        self.minParticipationRate = v;
    }

    // bool supportConstant = 15;


    pub fn get_supportConstant(&self) -> bool {
        self.supportConstant
    }
    pub fn clear_supportConstant(&mut self) {
        self.supportConstant = false;
    }

    // Param is passed by value, moved
    pub fn set_supportConstant(&mut self, v: bool) {
        self.supportConstant = v;
    }

    // double minTimeRatio = 16;


    pub fn get_minTimeRatio(&self) -> f64 {
        self.minTimeRatio
    }
    pub fn clear_minTimeRatio(&mut self) {
        self.minTimeRatio = 0.;
    }

    // Param is passed by value, moved
    pub fn set_minTimeRatio(&mut self, v: f64) {
        self.minTimeRatio = v;
    }

    // double maxTimeRatio = 17;


    pub fn get_maxTimeRatio(&self) -> f64 {
        self.maxTimeRatio
    }
    pub fn clear_maxTimeRatio(&mut self) {
        self.maxTimeRatio = 0.;
    }

    // Param is passed by value, moved
    pub fn set_maxTimeRatio(&mut self, v: f64) {
        self.maxTimeRatio = v;
    }

    // int64 allowCreationOfContracts = 18;


    pub fn get_allowCreationOfContracts(&self) -> i64 {
        self.allowCreationOfContracts
    }
    pub fn clear_allowCreationOfContracts(&mut self) {
        self.allowCreationOfContracts = 0;
    }

    // Param is passed by value, moved
    pub fn set_allowCreationOfContracts(&mut self, v: i64) {
        self.allowCreationOfContracts = v;
    }

    // int64 allowAdaptiveEnergy = 19;


    pub fn get_allowAdaptiveEnergy(&self) -> i64 {
        self.allowAdaptiveEnergy
    }
    pub fn clear_allowAdaptiveEnergy(&mut self) {
        self.allowAdaptiveEnergy = 0;
    }

    // Param is passed by value, moved
    pub fn set_allowAdaptiveEnergy(&mut self, v: i64) {
        self.allowAdaptiveEnergy = v;
    }
}

impl ::protobuf::Message for NodeInfo_ConfigNodeInfo {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.codeVersion)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.p2pVersion)?;
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.listenPort = tmp;
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.discoverEnable = tmp;
                },
                5 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.activeNodeSize = tmp;
                },
                6 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.passiveNodeSize = tmp;
                },
                7 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.sendNodeSize = tmp;
                },
                8 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.maxConnectCount = tmp;
                },
                9 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.sameIpMaxConnectCount = tmp;
                },
                10 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.backupListenPort = tmp;
                },
                11 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.backupMemberSize = tmp;
                },
                12 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.backupPriority = tmp;
                },
                13 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.dbVersion = tmp;
                },
                14 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.minParticipationRate = tmp;
                },
                15 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.supportConstant = tmp;
                },
                16 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed64 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_double()?;
                    self.minTimeRatio = tmp;
                },
                17 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed64 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_double()?;
                    self.maxTimeRatio = tmp;
                },
                18 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.allowCreationOfContracts = tmp;
                },
                19 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.allowAdaptiveEnergy = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.codeVersion.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.codeVersion);
        }
        if !self.p2pVersion.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.p2pVersion);
        }
        if self.listenPort != 0 {
            my_size += ::protobuf::rt::value_size(3, self.listenPort, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.discoverEnable != false {
            my_size += 2;
        }
        if self.activeNodeSize != 0 {
            my_size += ::protobuf::rt::value_size(5, self.activeNodeSize, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.passiveNodeSize != 0 {
            my_size += ::protobuf::rt::value_size(6, self.passiveNodeSize, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.sendNodeSize != 0 {
            my_size += ::protobuf::rt::value_size(7, self.sendNodeSize, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.maxConnectCount != 0 {
            my_size += ::protobuf::rt::value_size(8, self.maxConnectCount, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.sameIpMaxConnectCount != 0 {
            my_size += ::protobuf::rt::value_size(9, self.sameIpMaxConnectCount, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.backupListenPort != 0 {
            my_size += ::protobuf::rt::value_size(10, self.backupListenPort, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.backupMemberSize != 0 {
            my_size += ::protobuf::rt::value_size(11, self.backupMemberSize, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.backupPriority != 0 {
            my_size += ::protobuf::rt::value_size(12, self.backupPriority, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.dbVersion != 0 {
            my_size += ::protobuf::rt::value_size(13, self.dbVersion, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.minParticipationRate != 0 {
            my_size += ::protobuf::rt::value_size(14, self.minParticipationRate, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.supportConstant != false {
            my_size += 2;
        }
        if self.minTimeRatio != 0. {
            my_size += 10;
        }
        if self.maxTimeRatio != 0. {
            my_size += 10;
        }
        if self.allowCreationOfContracts != 0 {
            my_size += ::protobuf::rt::value_size(18, self.allowCreationOfContracts, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.allowAdaptiveEnergy != 0 {
            my_size += ::protobuf::rt::value_size(19, self.allowAdaptiveEnergy, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if !self.codeVersion.is_empty() {
            os.write_string(1, &self.codeVersion)?;
        }
        if !self.p2pVersion.is_empty() {
            os.write_string(2, &self.p2pVersion)?;
        }
        if self.listenPort != 0 {
            os.write_int32(3, self.listenPort)?;
        }
        if self.discoverEnable != false {
            os.write_bool(4, self.discoverEnable)?;
        }
        if self.activeNodeSize != 0 {
            os.write_int32(5, self.activeNodeSize)?;
        }
        if self.passiveNodeSize != 0 {
            os.write_int32(6, self.passiveNodeSize)?;
        }
        if self.sendNodeSize != 0 {
            os.write_int32(7, self.sendNodeSize)?;
        }
        if self.maxConnectCount != 0 {
            os.write_int32(8, self.maxConnectCount)?;
        }
        if self.sameIpMaxConnectCount != 0 {
            os.write_int32(9, self.sameIpMaxConnectCount)?;
        }
        if self.backupListenPort != 0 {
            os.write_int32(10, self.backupListenPort)?;
        }
        if self.backupMemberSize != 0 {
            os.write_int32(11, self.backupMemberSize)?;
        }
        if self.backupPriority != 0 {
            os.write_int32(12, self.backupPriority)?;
        }
        if self.dbVersion != 0 {
            os.write_int32(13, self.dbVersion)?;
        }
        if self.minParticipationRate != 0 {
            os.write_int32(14, self.minParticipationRate)?;
        }
        if self.supportConstant != false {
            os.write_bool(15, self.supportConstant)?;
        }
        if self.minTimeRatio != 0. {
            os.write_double(16, self.minTimeRatio)?;
        }
        if self.maxTimeRatio != 0. {
            os.write_double(17, self.maxTimeRatio)?;
        }
        if self.allowCreationOfContracts != 0 {
            os.write_int64(18, self.allowCreationOfContracts)?;
        }
        if self.allowAdaptiveEnergy != 0 {
            os.write_int64(19, self.allowAdaptiveEnergy)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> NodeInfo_ConfigNodeInfo {
        NodeInfo_ConfigNodeInfo::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "codeVersion",
                    |m: &NodeInfo_ConfigNodeInfo| { &m.codeVersion },
                    |m: &mut NodeInfo_ConfigNodeInfo| { &mut m.codeVersion },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "p2pVersion",
                    |m: &NodeInfo_ConfigNodeInfo| { &m.p2pVersion },
                    |m: &mut NodeInfo_ConfigNodeInfo| { &mut m.p2pVersion },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                    "listenPort",
                    |m: &NodeInfo_ConfigNodeInfo| { &m.listenPort },
                    |m: &mut NodeInfo_ConfigNodeInfo| { &mut m.listenPort },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                    "discoverEnable",
                    |m: &NodeInfo_ConfigNodeInfo| { &m.discoverEnable },
                    |m: &mut NodeInfo_ConfigNodeInfo| { &mut m.discoverEnable },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                    "activeNodeSize",
                    |m: &NodeInfo_ConfigNodeInfo| { &m.activeNodeSize },
                    |m: &mut NodeInfo_ConfigNodeInfo| { &mut m.activeNodeSize },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                    "passiveNodeSize",
                    |m: &NodeInfo_ConfigNodeInfo| { &m.passiveNodeSize },
                    |m: &mut NodeInfo_ConfigNodeInfo| { &mut m.passiveNodeSize },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                    "sendNodeSize",
                    |m: &NodeInfo_ConfigNodeInfo| { &m.sendNodeSize },
                    |m: &mut NodeInfo_ConfigNodeInfo| { &mut m.sendNodeSize },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                    "maxConnectCount",
                    |m: &NodeInfo_ConfigNodeInfo| { &m.maxConnectCount },
                    |m: &mut NodeInfo_ConfigNodeInfo| { &mut m.maxConnectCount },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                    "sameIpMaxConnectCount",
                    |m: &NodeInfo_ConfigNodeInfo| { &m.sameIpMaxConnectCount },
                    |m: &mut NodeInfo_ConfigNodeInfo| { &mut m.sameIpMaxConnectCount },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                    "backupListenPort",
                    |m: &NodeInfo_ConfigNodeInfo| { &m.backupListenPort },
                    |m: &mut NodeInfo_ConfigNodeInfo| { &mut m.backupListenPort },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                    "backupMemberSize",
                    |m: &NodeInfo_ConfigNodeInfo| { &m.backupMemberSize },
                    |m: &mut NodeInfo_ConfigNodeInfo| { &mut m.backupMemberSize },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                    "backupPriority",
                    |m: &NodeInfo_ConfigNodeInfo| { &m.backupPriority },
                    |m: &mut NodeInfo_ConfigNodeInfo| { &mut m.backupPriority },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                    "dbVersion",
                    |m: &NodeInfo_ConfigNodeInfo| { &m.dbVersion },
                    |m: &mut NodeInfo_ConfigNodeInfo| { &mut m.dbVersion },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                    "minParticipationRate",
                    |m: &NodeInfo_ConfigNodeInfo| { &m.minParticipationRate },
                    |m: &mut NodeInfo_ConfigNodeInfo| { &mut m.minParticipationRate },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                    "supportConstant",
                    |m: &NodeInfo_ConfigNodeInfo| { &m.supportConstant },
                    |m: &mut NodeInfo_ConfigNodeInfo| { &mut m.supportConstant },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeDouble>(
                    "minTimeRatio",
                    |m: &NodeInfo_ConfigNodeInfo| { &m.minTimeRatio },
                    |m: &mut NodeInfo_ConfigNodeInfo| { &mut m.minTimeRatio },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeDouble>(
                    "maxTimeRatio",
                    |m: &NodeInfo_ConfigNodeInfo| { &m.maxTimeRatio },
                    |m: &mut NodeInfo_ConfigNodeInfo| { &mut m.maxTimeRatio },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                    "allowCreationOfContracts",
                    |m: &NodeInfo_ConfigNodeInfo| { &m.allowCreationOfContracts },
                    |m: &mut NodeInfo_ConfigNodeInfo| { &mut m.allowCreationOfContracts },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                    "allowAdaptiveEnergy",
                    |m: &NodeInfo_ConfigNodeInfo| { &m.allowAdaptiveEnergy },
                    |m: &mut NodeInfo_ConfigNodeInfo| { &mut m.allowAdaptiveEnergy },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<NodeInfo_ConfigNodeInfo>(
                    "NodeInfo_ConfigNodeInfo",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static NodeInfo_ConfigNodeInfo {
        static mut instance: ::protobuf::lazy::Lazy<NodeInfo_ConfigNodeInfo> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const NodeInfo_ConfigNodeInfo,
        };
        unsafe {
            instance.get(NodeInfo_ConfigNodeInfo::new)
        }
    }
}

impl ::protobuf::Clear for NodeInfo_ConfigNodeInfo {
    fn clear(&mut self) {
        self.codeVersion.clear();
        self.p2pVersion.clear();
        self.listenPort = 0;
        self.discoverEnable = false;
        self.activeNodeSize = 0;
        self.passiveNodeSize = 0;
        self.sendNodeSize = 0;
        self.maxConnectCount = 0;
        self.sameIpMaxConnectCount = 0;
        self.backupListenPort = 0;
        self.backupMemberSize = 0;
        self.backupPriority = 0;
        self.dbVersion = 0;
        self.minParticipationRate = 0;
        self.supportConstant = false;
        self.minTimeRatio = 0.;
        self.maxTimeRatio = 0.;
        self.allowCreationOfContracts = 0;
        self.allowAdaptiveEnergy = 0;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for NodeInfo_ConfigNodeInfo {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for NodeInfo_ConfigNodeInfo {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct NodeInfo_MachineInfo {
    // message fields
    pub threadCount: i32,
    pub deadLockThreadCount: i32,
    pub cpuCount: i32,
    pub totalMemory: i64,
    pub freeMemory: i64,
    pub cpuRate: f64,
    pub javaVersion: ::std::string::String,
    pub osName: ::std::string::String,
    pub jvmTotalMemoery: i64,
    pub jvmFreeMemory: i64,
    pub processCpuRate: f64,
    pub memoryDescInfoList: ::protobuf::RepeatedField<NodeInfo_MachineInfo_MemoryDescInfo>,
    pub deadLockThreadInfoList: ::protobuf::RepeatedField<NodeInfo_MachineInfo_DeadLockThreadInfo>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a NodeInfo_MachineInfo {
    fn default() -> &'a NodeInfo_MachineInfo {
        <NodeInfo_MachineInfo as ::protobuf::Message>::default_instance()
    }
}

impl NodeInfo_MachineInfo {
    pub fn new() -> NodeInfo_MachineInfo {
        ::std::default::Default::default()
    }

    // int32 threadCount = 1;


    pub fn get_threadCount(&self) -> i32 {
        self.threadCount
    }
    pub fn clear_threadCount(&mut self) {
        self.threadCount = 0;
    }

    // Param is passed by value, moved
    pub fn set_threadCount(&mut self, v: i32) {
        self.threadCount = v;
    }

    // int32 deadLockThreadCount = 2;


    pub fn get_deadLockThreadCount(&self) -> i32 {
        self.deadLockThreadCount
    }
    pub fn clear_deadLockThreadCount(&mut self) {
        self.deadLockThreadCount = 0;
    }

    // Param is passed by value, moved
    pub fn set_deadLockThreadCount(&mut self, v: i32) {
        self.deadLockThreadCount = v;
    }

    // int32 cpuCount = 3;


    pub fn get_cpuCount(&self) -> i32 {
        self.cpuCount
    }
    pub fn clear_cpuCount(&mut self) {
        self.cpuCount = 0;
    }

    // Param is passed by value, moved
    pub fn set_cpuCount(&mut self, v: i32) {
        self.cpuCount = v;
    }

    // int64 totalMemory = 4;


    pub fn get_totalMemory(&self) -> i64 {
        self.totalMemory
    }
    pub fn clear_totalMemory(&mut self) {
        self.totalMemory = 0;
    }

    // Param is passed by value, moved
    pub fn set_totalMemory(&mut self, v: i64) {
        self.totalMemory = v;
    }

    // int64 freeMemory = 5;


    pub fn get_freeMemory(&self) -> i64 {
        self.freeMemory
    }
    pub fn clear_freeMemory(&mut self) {
        self.freeMemory = 0;
    }

    // Param is passed by value, moved
    pub fn set_freeMemory(&mut self, v: i64) {
        self.freeMemory = v;
    }

    // double cpuRate = 6;


    pub fn get_cpuRate(&self) -> f64 {
        self.cpuRate
    }
    pub fn clear_cpuRate(&mut self) {
        self.cpuRate = 0.;
    }

    // Param is passed by value, moved
    pub fn set_cpuRate(&mut self, v: f64) {
        self.cpuRate = v;
    }

    // string javaVersion = 7;


    pub fn get_javaVersion(&self) -> &str {
        &self.javaVersion
    }
    pub fn clear_javaVersion(&mut self) {
        self.javaVersion.clear();
    }

    // Param is passed by value, moved
    pub fn set_javaVersion(&mut self, v: ::std::string::String) {
        self.javaVersion = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_javaVersion(&mut self) -> &mut ::std::string::String {
        &mut self.javaVersion
    }

    // Take field
    pub fn take_javaVersion(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.javaVersion, ::std::string::String::new())
    }

    // string osName = 8;


    pub fn get_osName(&self) -> &str {
        &self.osName
    }
    pub fn clear_osName(&mut self) {
        self.osName.clear();
    }

    // Param is passed by value, moved
    pub fn set_osName(&mut self, v: ::std::string::String) {
        self.osName = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_osName(&mut self) -> &mut ::std::string::String {
        &mut self.osName
    }

    // Take field
    pub fn take_osName(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.osName, ::std::string::String::new())
    }

    // int64 jvmTotalMemoery = 9;


    pub fn get_jvmTotalMemoery(&self) -> i64 {
        self.jvmTotalMemoery
    }
    pub fn clear_jvmTotalMemoery(&mut self) {
        self.jvmTotalMemoery = 0;
    }

    // Param is passed by value, moved
    pub fn set_jvmTotalMemoery(&mut self, v: i64) {
        self.jvmTotalMemoery = v;
    }

    // int64 jvmFreeMemory = 10;


    pub fn get_jvmFreeMemory(&self) -> i64 {
        self.jvmFreeMemory
    }
    pub fn clear_jvmFreeMemory(&mut self) {
        self.jvmFreeMemory = 0;
    }

    // Param is passed by value, moved
    pub fn set_jvmFreeMemory(&mut self, v: i64) {
        self.jvmFreeMemory = v;
    }

    // double processCpuRate = 11;


    pub fn get_processCpuRate(&self) -> f64 {
        self.processCpuRate
    }
    pub fn clear_processCpuRate(&mut self) {
        self.processCpuRate = 0.;
    }

    // Param is passed by value, moved
    pub fn set_processCpuRate(&mut self, v: f64) {
        self.processCpuRate = v;
    }

    // repeated .protocol.NodeInfo.MachineInfo.MemoryDescInfo memoryDescInfoList = 12;


    pub fn get_memoryDescInfoList(&self) -> &[NodeInfo_MachineInfo_MemoryDescInfo] {
        &self.memoryDescInfoList
    }
    pub fn clear_memoryDescInfoList(&mut self) {
        self.memoryDescInfoList.clear();
    }

    // Param is passed by value, moved
    pub fn set_memoryDescInfoList(&mut self, v: ::protobuf::RepeatedField<NodeInfo_MachineInfo_MemoryDescInfo>) {
        self.memoryDescInfoList = v;
    }

    // Mutable pointer to the field.
    pub fn mut_memoryDescInfoList(&mut self) -> &mut ::protobuf::RepeatedField<NodeInfo_MachineInfo_MemoryDescInfo> {
        &mut self.memoryDescInfoList
    }

    // Take field
    pub fn take_memoryDescInfoList(&mut self) -> ::protobuf::RepeatedField<NodeInfo_MachineInfo_MemoryDescInfo> {
        ::std::mem::replace(&mut self.memoryDescInfoList, ::protobuf::RepeatedField::new())
    }

    // repeated .protocol.NodeInfo.MachineInfo.DeadLockThreadInfo deadLockThreadInfoList = 13;


    pub fn get_deadLockThreadInfoList(&self) -> &[NodeInfo_MachineInfo_DeadLockThreadInfo] {
        &self.deadLockThreadInfoList
    }
    pub fn clear_deadLockThreadInfoList(&mut self) {
        self.deadLockThreadInfoList.clear();
    }

    // Param is passed by value, moved
    pub fn set_deadLockThreadInfoList(&mut self, v: ::protobuf::RepeatedField<NodeInfo_MachineInfo_DeadLockThreadInfo>) {
        self.deadLockThreadInfoList = v;
    }

    // Mutable pointer to the field.
    pub fn mut_deadLockThreadInfoList(&mut self) -> &mut ::protobuf::RepeatedField<NodeInfo_MachineInfo_DeadLockThreadInfo> {
        &mut self.deadLockThreadInfoList
    }

    // Take field
    pub fn take_deadLockThreadInfoList(&mut self) -> ::protobuf::RepeatedField<NodeInfo_MachineInfo_DeadLockThreadInfo> {
        ::std::mem::replace(&mut self.deadLockThreadInfoList, ::protobuf::RepeatedField::new())
    }
}

impl ::protobuf::Message for NodeInfo_MachineInfo {
    fn is_initialized(&self) -> bool {
        for v in &self.memoryDescInfoList {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.deadLockThreadInfoList {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.threadCount = tmp;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.deadLockThreadCount = tmp;
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.cpuCount = tmp;
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.totalMemory = tmp;
                },
                5 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.freeMemory = tmp;
                },
                6 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed64 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_double()?;
                    self.cpuRate = tmp;
                },
                7 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.javaVersion)?;
                },
                8 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.osName)?;
                },
                9 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.jvmTotalMemoery = tmp;
                },
                10 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.jvmFreeMemory = tmp;
                },
                11 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed64 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_double()?;
                    self.processCpuRate = tmp;
                },
                12 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.memoryDescInfoList)?;
                },
                13 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.deadLockThreadInfoList)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.threadCount != 0 {
            my_size += ::protobuf::rt::value_size(1, self.threadCount, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.deadLockThreadCount != 0 {
            my_size += ::protobuf::rt::value_size(2, self.deadLockThreadCount, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.cpuCount != 0 {
            my_size += ::protobuf::rt::value_size(3, self.cpuCount, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.totalMemory != 0 {
            my_size += ::protobuf::rt::value_size(4, self.totalMemory, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.freeMemory != 0 {
            my_size += ::protobuf::rt::value_size(5, self.freeMemory, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.cpuRate != 0. {
            my_size += 9;
        }
        if !self.javaVersion.is_empty() {
            my_size += ::protobuf::rt::string_size(7, &self.javaVersion);
        }
        if !self.osName.is_empty() {
            my_size += ::protobuf::rt::string_size(8, &self.osName);
        }
        if self.jvmTotalMemoery != 0 {
            my_size += ::protobuf::rt::value_size(9, self.jvmTotalMemoery, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.jvmFreeMemory != 0 {
            my_size += ::protobuf::rt::value_size(10, self.jvmFreeMemory, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.processCpuRate != 0. {
            my_size += 9;
        }
        for value in &self.memoryDescInfoList {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        for value in &self.deadLockThreadInfoList {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if self.threadCount != 0 {
            os.write_int32(1, self.threadCount)?;
        }
        if self.deadLockThreadCount != 0 {
            os.write_int32(2, self.deadLockThreadCount)?;
        }
        if self.cpuCount != 0 {
            os.write_int32(3, self.cpuCount)?;
        }
        if self.totalMemory != 0 {
            os.write_int64(4, self.totalMemory)?;
        }
        if self.freeMemory != 0 {
            os.write_int64(5, self.freeMemory)?;
        }
        if self.cpuRate != 0. {
            os.write_double(6, self.cpuRate)?;
        }
        if !self.javaVersion.is_empty() {
            os.write_string(7, &self.javaVersion)?;
        }
        if !self.osName.is_empty() {
            os.write_string(8, &self.osName)?;
        }
        if self.jvmTotalMemoery != 0 {
            os.write_int64(9, self.jvmTotalMemoery)?;
        }
        if self.jvmFreeMemory != 0 {
            os.write_int64(10, self.jvmFreeMemory)?;
        }
        if self.processCpuRate != 0. {
            os.write_double(11, self.processCpuRate)?;
        }
        for v in &self.memoryDescInfoList {
            os.write_tag(12, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        for v in &self.deadLockThreadInfoList {
            os.write_tag(13, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> NodeInfo_MachineInfo {
        NodeInfo_MachineInfo::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                    "threadCount",
                    |m: &NodeInfo_MachineInfo| { &m.threadCount },
                    |m: &mut NodeInfo_MachineInfo| { &mut m.threadCount },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                    "deadLockThreadCount",
                    |m: &NodeInfo_MachineInfo| { &m.deadLockThreadCount },
                    |m: &mut NodeInfo_MachineInfo| { &mut m.deadLockThreadCount },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                    "cpuCount",
                    |m: &NodeInfo_MachineInfo| { &m.cpuCount },
                    |m: &mut NodeInfo_MachineInfo| { &mut m.cpuCount },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                    "totalMemory",
                    |m: &NodeInfo_MachineInfo| { &m.totalMemory },
                    |m: &mut NodeInfo_MachineInfo| { &mut m.totalMemory },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                    "freeMemory",
                    |m: &NodeInfo_MachineInfo| { &m.freeMemory },
                    |m: &mut NodeInfo_MachineInfo| { &mut m.freeMemory },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeDouble>(
                    "cpuRate",
                    |m: &NodeInfo_MachineInfo| { &m.cpuRate },
                    |m: &mut NodeInfo_MachineInfo| { &mut m.cpuRate },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "javaVersion",
                    |m: &NodeInfo_MachineInfo| { &m.javaVersion },
                    |m: &mut NodeInfo_MachineInfo| { &mut m.javaVersion },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "osName",
                    |m: &NodeInfo_MachineInfo| { &m.osName },
                    |m: &mut NodeInfo_MachineInfo| { &mut m.osName },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                    "jvmTotalMemoery",
                    |m: &NodeInfo_MachineInfo| { &m.jvmTotalMemoery },
                    |m: &mut NodeInfo_MachineInfo| { &mut m.jvmTotalMemoery },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                    "jvmFreeMemory",
                    |m: &NodeInfo_MachineInfo| { &m.jvmFreeMemory },
                    |m: &mut NodeInfo_MachineInfo| { &mut m.jvmFreeMemory },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeDouble>(
                    "processCpuRate",
                    |m: &NodeInfo_MachineInfo| { &m.processCpuRate },
                    |m: &mut NodeInfo_MachineInfo| { &mut m.processCpuRate },
                ));
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<NodeInfo_MachineInfo_MemoryDescInfo>>(
                    "memoryDescInfoList",
                    |m: &NodeInfo_MachineInfo| { &m.memoryDescInfoList },
                    |m: &mut NodeInfo_MachineInfo| { &mut m.memoryDescInfoList },
                ));
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<NodeInfo_MachineInfo_DeadLockThreadInfo>>(
                    "deadLockThreadInfoList",
                    |m: &NodeInfo_MachineInfo| { &m.deadLockThreadInfoList },
                    |m: &mut NodeInfo_MachineInfo| { &mut m.deadLockThreadInfoList },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<NodeInfo_MachineInfo>(
                    "NodeInfo_MachineInfo",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static NodeInfo_MachineInfo {
        static mut instance: ::protobuf::lazy::Lazy<NodeInfo_MachineInfo> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const NodeInfo_MachineInfo,
        };
        unsafe {
            instance.get(NodeInfo_MachineInfo::new)
        }
    }
}

impl ::protobuf::Clear for NodeInfo_MachineInfo {
    fn clear(&mut self) {
        self.threadCount = 0;
        self.deadLockThreadCount = 0;
        self.cpuCount = 0;
        self.totalMemory = 0;
        self.freeMemory = 0;
        self.cpuRate = 0.;
        self.javaVersion.clear();
        self.osName.clear();
        self.jvmTotalMemoery = 0;
        self.jvmFreeMemory = 0;
        self.processCpuRate = 0.;
        self.memoryDescInfoList.clear();
        self.deadLockThreadInfoList.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for NodeInfo_MachineInfo {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for NodeInfo_MachineInfo {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct NodeInfo_MachineInfo_MemoryDescInfo {
    // message fields
    pub name: ::std::string::String,
    pub initSize: i64,
    pub useSize: i64,
    pub maxSize: i64,
    pub useRate: f64,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a NodeInfo_MachineInfo_MemoryDescInfo {
    fn default() -> &'a NodeInfo_MachineInfo_MemoryDescInfo {
        <NodeInfo_MachineInfo_MemoryDescInfo as ::protobuf::Message>::default_instance()
    }
}

impl NodeInfo_MachineInfo_MemoryDescInfo {
    pub fn new() -> NodeInfo_MachineInfo_MemoryDescInfo {
        ::std::default::Default::default()
    }

    // string name = 1;


    pub fn get_name(&self) -> &str {
        &self.name
    }
    pub fn clear_name(&mut self) {
        self.name.clear();
    }

    // Param is passed by value, moved
    pub fn set_name(&mut self, v: ::std::string::String) {
        self.name = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_name(&mut self) -> &mut ::std::string::String {
        &mut self.name
    }

    // Take field
    pub fn take_name(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.name, ::std::string::String::new())
    }

    // int64 initSize = 2;


    pub fn get_initSize(&self) -> i64 {
        self.initSize
    }
    pub fn clear_initSize(&mut self) {
        self.initSize = 0;
    }

    // Param is passed by value, moved
    pub fn set_initSize(&mut self, v: i64) {
        self.initSize = v;
    }

    // int64 useSize = 3;


    pub fn get_useSize(&self) -> i64 {
        self.useSize
    }
    pub fn clear_useSize(&mut self) {
        self.useSize = 0;
    }

    // Param is passed by value, moved
    pub fn set_useSize(&mut self, v: i64) {
        self.useSize = v;
    }

    // int64 maxSize = 4;


    pub fn get_maxSize(&self) -> i64 {
        self.maxSize
    }
    pub fn clear_maxSize(&mut self) {
        self.maxSize = 0;
    }

    // Param is passed by value, moved
    pub fn set_maxSize(&mut self, v: i64) {
        self.maxSize = v;
    }

    // double useRate = 5;


    pub fn get_useRate(&self) -> f64 {
        self.useRate
    }
    pub fn clear_useRate(&mut self) {
        self.useRate = 0.;
    }

    // Param is passed by value, moved
    pub fn set_useRate(&mut self, v: f64) {
        self.useRate = v;
    }
}

impl ::protobuf::Message for NodeInfo_MachineInfo_MemoryDescInfo {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.name)?;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.initSize = tmp;
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.useSize = tmp;
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.maxSize = tmp;
                },
                5 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed64 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_double()?;
                    self.useRate = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.name.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.name);
        }
        if self.initSize != 0 {
            my_size += ::protobuf::rt::value_size(2, self.initSize, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.useSize != 0 {
            my_size += ::protobuf::rt::value_size(3, self.useSize, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.maxSize != 0 {
            my_size += ::protobuf::rt::value_size(4, self.maxSize, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.useRate != 0. {
            my_size += 9;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if !self.name.is_empty() {
            os.write_string(1, &self.name)?;
        }
        if self.initSize != 0 {
            os.write_int64(2, self.initSize)?;
        }
        if self.useSize != 0 {
            os.write_int64(3, self.useSize)?;
        }
        if self.maxSize != 0 {
            os.write_int64(4, self.maxSize)?;
        }
        if self.useRate != 0. {
            os.write_double(5, self.useRate)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> NodeInfo_MachineInfo_MemoryDescInfo {
        NodeInfo_MachineInfo_MemoryDescInfo::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "name",
                    |m: &NodeInfo_MachineInfo_MemoryDescInfo| { &m.name },
                    |m: &mut NodeInfo_MachineInfo_MemoryDescInfo| { &mut m.name },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                    "initSize",
                    |m: &NodeInfo_MachineInfo_MemoryDescInfo| { &m.initSize },
                    |m: &mut NodeInfo_MachineInfo_MemoryDescInfo| { &mut m.initSize },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                    "useSize",
                    |m: &NodeInfo_MachineInfo_MemoryDescInfo| { &m.useSize },
                    |m: &mut NodeInfo_MachineInfo_MemoryDescInfo| { &mut m.useSize },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                    "maxSize",
                    |m: &NodeInfo_MachineInfo_MemoryDescInfo| { &m.maxSize },
                    |m: &mut NodeInfo_MachineInfo_MemoryDescInfo| { &mut m.maxSize },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeDouble>(
                    "useRate",
                    |m: &NodeInfo_MachineInfo_MemoryDescInfo| { &m.useRate },
                    |m: &mut NodeInfo_MachineInfo_MemoryDescInfo| { &mut m.useRate },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<NodeInfo_MachineInfo_MemoryDescInfo>(
                    "NodeInfo_MachineInfo_MemoryDescInfo",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static NodeInfo_MachineInfo_MemoryDescInfo {
        static mut instance: ::protobuf::lazy::Lazy<NodeInfo_MachineInfo_MemoryDescInfo> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const NodeInfo_MachineInfo_MemoryDescInfo,
        };
        unsafe {
            instance.get(NodeInfo_MachineInfo_MemoryDescInfo::new)
        }
    }
}

impl ::protobuf::Clear for NodeInfo_MachineInfo_MemoryDescInfo {
    fn clear(&mut self) {
        self.name.clear();
        self.initSize = 0;
        self.useSize = 0;
        self.maxSize = 0;
        self.useRate = 0.;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for NodeInfo_MachineInfo_MemoryDescInfo {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for NodeInfo_MachineInfo_MemoryDescInfo {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct NodeInfo_MachineInfo_DeadLockThreadInfo {
    // message fields
    pub name: ::std::string::String,
    pub lockName: ::std::string::String,
    pub lockOwner: ::std::string::String,
    pub state: ::std::string::String,
    pub blockTime: i64,
    pub waitTime: i64,
    pub stackTrace: ::std::string::String,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a NodeInfo_MachineInfo_DeadLockThreadInfo {
    fn default() -> &'a NodeInfo_MachineInfo_DeadLockThreadInfo {
        <NodeInfo_MachineInfo_DeadLockThreadInfo as ::protobuf::Message>::default_instance()
    }
}

impl NodeInfo_MachineInfo_DeadLockThreadInfo {
    pub fn new() -> NodeInfo_MachineInfo_DeadLockThreadInfo {
        ::std::default::Default::default()
    }

    // string name = 1;


    pub fn get_name(&self) -> &str {
        &self.name
    }
    pub fn clear_name(&mut self) {
        self.name.clear();
    }

    // Param is passed by value, moved
    pub fn set_name(&mut self, v: ::std::string::String) {
        self.name = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_name(&mut self) -> &mut ::std::string::String {
        &mut self.name
    }

    // Take field
    pub fn take_name(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.name, ::std::string::String::new())
    }

    // string lockName = 2;


    pub fn get_lockName(&self) -> &str {
        &self.lockName
    }
    pub fn clear_lockName(&mut self) {
        self.lockName.clear();
    }

    // Param is passed by value, moved
    pub fn set_lockName(&mut self, v: ::std::string::String) {
        self.lockName = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_lockName(&mut self) -> &mut ::std::string::String {
        &mut self.lockName
    }

    // Take field
    pub fn take_lockName(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.lockName, ::std::string::String::new())
    }

    // string lockOwner = 3;


    pub fn get_lockOwner(&self) -> &str {
        &self.lockOwner
    }
    pub fn clear_lockOwner(&mut self) {
        self.lockOwner.clear();
    }

    // Param is passed by value, moved
    pub fn set_lockOwner(&mut self, v: ::std::string::String) {
        self.lockOwner = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_lockOwner(&mut self) -> &mut ::std::string::String {
        &mut self.lockOwner
    }

    // Take field
    pub fn take_lockOwner(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.lockOwner, ::std::string::String::new())
    }

    // string state = 4;


    pub fn get_state(&self) -> &str {
        &self.state
    }
    pub fn clear_state(&mut self) {
        self.state.clear();
    }

    // Param is passed by value, moved
    pub fn set_state(&mut self, v: ::std::string::String) {
        self.state = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_state(&mut self) -> &mut ::std::string::String {
        &mut self.state
    }

    // Take field
    pub fn take_state(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.state, ::std::string::String::new())
    }

    // int64 blockTime = 5;


    pub fn get_blockTime(&self) -> i64 {
        self.blockTime
    }
    pub fn clear_blockTime(&mut self) {
        self.blockTime = 0;
    }

    // Param is passed by value, moved
    pub fn set_blockTime(&mut self, v: i64) {
        self.blockTime = v;
    }

    // int64 waitTime = 6;


    pub fn get_waitTime(&self) -> i64 {
        self.waitTime
    }
    pub fn clear_waitTime(&mut self) {
        self.waitTime = 0;
    }

    // Param is passed by value, moved
    pub fn set_waitTime(&mut self, v: i64) {
        self.waitTime = v;
    }

    // string stackTrace = 7;


    pub fn get_stackTrace(&self) -> &str {
        &self.stackTrace
    }
    pub fn clear_stackTrace(&mut self) {
        self.stackTrace.clear();
    }

    // Param is passed by value, moved
    pub fn set_stackTrace(&mut self, v: ::std::string::String) {
        self.stackTrace = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_stackTrace(&mut self) -> &mut ::std::string::String {
        &mut self.stackTrace
    }

    // Take field
    pub fn take_stackTrace(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.stackTrace, ::std::string::String::new())
    }
}

impl ::protobuf::Message for NodeInfo_MachineInfo_DeadLockThreadInfo {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.name)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.lockName)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.lockOwner)?;
                },
                4 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.state)?;
                },
                5 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.blockTime = tmp;
                },
                6 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.waitTime = tmp;
                },
                7 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.stackTrace)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.name.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.name);
        }
        if !self.lockName.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.lockName);
        }
        if !self.lockOwner.is_empty() {
            my_size += ::protobuf::rt::string_size(3, &self.lockOwner);
        }
        if !self.state.is_empty() {
            my_size += ::protobuf::rt::string_size(4, &self.state);
        }
        if self.blockTime != 0 {
            my_size += ::protobuf::rt::value_size(5, self.blockTime, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.waitTime != 0 {
            my_size += ::protobuf::rt::value_size(6, self.waitTime, ::protobuf::wire_format::WireTypeVarint);
        }
        if !self.stackTrace.is_empty() {
            my_size += ::protobuf::rt::string_size(7, &self.stackTrace);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if !self.name.is_empty() {
            os.write_string(1, &self.name)?;
        }
        if !self.lockName.is_empty() {
            os.write_string(2, &self.lockName)?;
        }
        if !self.lockOwner.is_empty() {
            os.write_string(3, &self.lockOwner)?;
        }
        if !self.state.is_empty() {
            os.write_string(4, &self.state)?;
        }
        if self.blockTime != 0 {
            os.write_int64(5, self.blockTime)?;
        }
        if self.waitTime != 0 {
            os.write_int64(6, self.waitTime)?;
        }
        if !self.stackTrace.is_empty() {
            os.write_string(7, &self.stackTrace)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> NodeInfo_MachineInfo_DeadLockThreadInfo {
        NodeInfo_MachineInfo_DeadLockThreadInfo::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "name",
                    |m: &NodeInfo_MachineInfo_DeadLockThreadInfo| { &m.name },
                    |m: &mut NodeInfo_MachineInfo_DeadLockThreadInfo| { &mut m.name },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "lockName",
                    |m: &NodeInfo_MachineInfo_DeadLockThreadInfo| { &m.lockName },
                    |m: &mut NodeInfo_MachineInfo_DeadLockThreadInfo| { &mut m.lockName },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "lockOwner",
                    |m: &NodeInfo_MachineInfo_DeadLockThreadInfo| { &m.lockOwner },
                    |m: &mut NodeInfo_MachineInfo_DeadLockThreadInfo| { &mut m.lockOwner },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "state",
                    |m: &NodeInfo_MachineInfo_DeadLockThreadInfo| { &m.state },
                    |m: &mut NodeInfo_MachineInfo_DeadLockThreadInfo| { &mut m.state },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                    "blockTime",
                    |m: &NodeInfo_MachineInfo_DeadLockThreadInfo| { &m.blockTime },
                    |m: &mut NodeInfo_MachineInfo_DeadLockThreadInfo| { &mut m.blockTime },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                    "waitTime",
                    |m: &NodeInfo_MachineInfo_DeadLockThreadInfo| { &m.waitTime },
                    |m: &mut NodeInfo_MachineInfo_DeadLockThreadInfo| { &mut m.waitTime },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "stackTrace",
                    |m: &NodeInfo_MachineInfo_DeadLockThreadInfo| { &m.stackTrace },
                    |m: &mut NodeInfo_MachineInfo_DeadLockThreadInfo| { &mut m.stackTrace },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<NodeInfo_MachineInfo_DeadLockThreadInfo>(
                    "NodeInfo_MachineInfo_DeadLockThreadInfo",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static NodeInfo_MachineInfo_DeadLockThreadInfo {
        static mut instance: ::protobuf::lazy::Lazy<NodeInfo_MachineInfo_DeadLockThreadInfo> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const NodeInfo_MachineInfo_DeadLockThreadInfo,
        };
        unsafe {
            instance.get(NodeInfo_MachineInfo_DeadLockThreadInfo::new)
        }
    }
}

impl ::protobuf::Clear for NodeInfo_MachineInfo_DeadLockThreadInfo {
    fn clear(&mut self) {
        self.name.clear();
        self.lockName.clear();
        self.lockOwner.clear();
        self.state.clear();
        self.blockTime = 0;
        self.waitTime = 0;
        self.stackTrace.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for NodeInfo_MachineInfo_DeadLockThreadInfo {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for NodeInfo_MachineInfo_DeadLockThreadInfo {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(Clone,PartialEq,Eq,Debug,Hash)]
pub enum AccountType {
    Normal = 0,
    AssetIssue = 1,
    Contract = 2,
}

impl ::protobuf::ProtobufEnum for AccountType {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<AccountType> {
        match value {
            0 => ::std::option::Option::Some(AccountType::Normal),
            1 => ::std::option::Option::Some(AccountType::AssetIssue),
            2 => ::std::option::Option::Some(AccountType::Contract),
            _ => ::std::option::Option::None
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [AccountType] = &[
            AccountType::Normal,
            AccountType::AssetIssue,
            AccountType::Contract,
        ];
        values
    }

    fn enum_descriptor_static() -> &'static ::protobuf::reflect::EnumDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::EnumDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                ::protobuf::reflect::EnumDescriptor::new("AccountType", file_descriptor_proto())
            })
        }
    }
}

impl ::std::marker::Copy for AccountType {
}

impl ::std::default::Default for AccountType {
    fn default() -> Self {
        AccountType::Normal
    }
}

impl ::protobuf::reflect::ProtobufValue for AccountType {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Enum(self.descriptor())
    }
}

#[derive(Clone,PartialEq,Eq,Debug,Hash)]
pub enum ReasonCode {
    REQUESTED = 0,
    BAD_PROTOCOL = 2,
    TOO_MANY_PEERS = 4,
    DUPLICATE_PEER = 5,
    INCOMPATIBLE_PROTOCOL = 6,
    NULL_IDENTITY = 7,
    PEER_QUITING = 8,
    UNEXPECTED_IDENTITY = 9,
    LOCAL_IDENTITY = 10,
    PING_TIMEOUT = 11,
    USER_REASON = 16,
    RESET = 17,
    SYNC_FAIL = 18,
    FETCH_FAIL = 19,
    BAD_TX = 20,
    BAD_BLOCK = 21,
    FORKED = 22,
    UNLINKABLE = 23,
    INCOMPATIBLE_VERSION = 24,
    INCOMPATIBLE_CHAIN = 25,
    TIME_OUT = 32,
    CONNECT_FAIL = 33,
    TOO_MANY_PEERS_WITH_SAME_IP = 34,
    UNKNOWN = 255,
}

impl ::protobuf::ProtobufEnum for ReasonCode {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<ReasonCode> {
        match value {
            0 => ::std::option::Option::Some(ReasonCode::REQUESTED),
            2 => ::std::option::Option::Some(ReasonCode::BAD_PROTOCOL),
            4 => ::std::option::Option::Some(ReasonCode::TOO_MANY_PEERS),
            5 => ::std::option::Option::Some(ReasonCode::DUPLICATE_PEER),
            6 => ::std::option::Option::Some(ReasonCode::INCOMPATIBLE_PROTOCOL),
            7 => ::std::option::Option::Some(ReasonCode::NULL_IDENTITY),
            8 => ::std::option::Option::Some(ReasonCode::PEER_QUITING),
            9 => ::std::option::Option::Some(ReasonCode::UNEXPECTED_IDENTITY),
            10 => ::std::option::Option::Some(ReasonCode::LOCAL_IDENTITY),
            11 => ::std::option::Option::Some(ReasonCode::PING_TIMEOUT),
            16 => ::std::option::Option::Some(ReasonCode::USER_REASON),
            17 => ::std::option::Option::Some(ReasonCode::RESET),
            18 => ::std::option::Option::Some(ReasonCode::SYNC_FAIL),
            19 => ::std::option::Option::Some(ReasonCode::FETCH_FAIL),
            20 => ::std::option::Option::Some(ReasonCode::BAD_TX),
            21 => ::std::option::Option::Some(ReasonCode::BAD_BLOCK),
            22 => ::std::option::Option::Some(ReasonCode::FORKED),
            23 => ::std::option::Option::Some(ReasonCode::UNLINKABLE),
            24 => ::std::option::Option::Some(ReasonCode::INCOMPATIBLE_VERSION),
            25 => ::std::option::Option::Some(ReasonCode::INCOMPATIBLE_CHAIN),
            32 => ::std::option::Option::Some(ReasonCode::TIME_OUT),
            33 => ::std::option::Option::Some(ReasonCode::CONNECT_FAIL),
            34 => ::std::option::Option::Some(ReasonCode::TOO_MANY_PEERS_WITH_SAME_IP),
            255 => ::std::option::Option::Some(ReasonCode::UNKNOWN),
            _ => ::std::option::Option::None
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [ReasonCode] = &[
            ReasonCode::REQUESTED,
            ReasonCode::BAD_PROTOCOL,
            ReasonCode::TOO_MANY_PEERS,
            ReasonCode::DUPLICATE_PEER,
            ReasonCode::INCOMPATIBLE_PROTOCOL,
            ReasonCode::NULL_IDENTITY,
            ReasonCode::PEER_QUITING,
            ReasonCode::UNEXPECTED_IDENTITY,
            ReasonCode::LOCAL_IDENTITY,
            ReasonCode::PING_TIMEOUT,
            ReasonCode::USER_REASON,
            ReasonCode::RESET,
            ReasonCode::SYNC_FAIL,
            ReasonCode::FETCH_FAIL,
            ReasonCode::BAD_TX,
            ReasonCode::BAD_BLOCK,
            ReasonCode::FORKED,
            ReasonCode::UNLINKABLE,
            ReasonCode::INCOMPATIBLE_VERSION,
            ReasonCode::INCOMPATIBLE_CHAIN,
            ReasonCode::TIME_OUT,
            ReasonCode::CONNECT_FAIL,
            ReasonCode::TOO_MANY_PEERS_WITH_SAME_IP,
            ReasonCode::UNKNOWN,
        ];
        values
    }

    fn enum_descriptor_static() -> &'static ::protobuf::reflect::EnumDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::EnumDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                ::protobuf::reflect::EnumDescriptor::new("ReasonCode", file_descriptor_proto())
            })
        }
    }
}

impl ::std::marker::Copy for ReasonCode {
}

impl ::std::default::Default for ReasonCode {
    fn default() -> Self {
        ReasonCode::REQUESTED
    }
}

impl ::protobuf::reflect::ProtobufValue for ReasonCode {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Enum(self.descriptor())
    }
}

static file_descriptor_proto_data: &'static [u8] = b"\
    \n\x0fcore/Tron.proto\x12\x08protocol\x1a\x19google/protobuf/any.proto\
    \x1a\x13core/Discover.proto\"9\n\tAccountId\x12\x12\n\x04name\x18\x01\
    \x20\x01(\x0cR\x04name\x12\x18\n\x07address\x18\x02\x20\x01(\x0cR\x07add\
    ress\"H\n\x04Vote\x12!\n\x0cvote_address\x18\x01\x20\x01(\x0cR\x0bvoteAd\
    dress\x12\x1d\n\nvote_count\x18\x02\x20\x01(\x03R\tvoteCount\"\xb4\x03\n\
    \x08Proposal\x12\x1f\n\x0bproposal_id\x18\x01\x20\x01(\x03R\nproposalId\
    \x12)\n\x10proposer_address\x18\x02\x20\x01(\x0cR\x0fproposerAddress\x12\
    B\n\nparameters\x18\x03\x20\x03(\x0b2\".protocol.Proposal.ParametersEntr\
    yR\nparameters\x12'\n\x0fexpiration_time\x18\x04\x20\x01(\x03R\x0eexpira\
    tionTime\x12\x1f\n\x0bcreate_time\x18\x05\x20\x01(\x03R\ncreateTime\x12\
    \x1c\n\tapprovals\x18\x06\x20\x03(\x0cR\tapprovals\x12.\n\x05state\x18\
    \x07\x20\x01(\x0e2\x18.protocol.Proposal.StateR\x05state\x1a=\n\x0fParam\
    etersEntry\x12\x10\n\x03key\x18\x01\x20\x01(\x03R\x03key\x12\x14\n\x05va\
    lue\x18\x02\x20\x01(\x03R\x05value:\x028\x01\"A\n\x05State\x12\x0b\n\x07\
    PENDING\x10\0\x12\x0f\n\x0bDISAPPROVED\x10\x01\x12\x0c\n\x08APPROVED\x10\
    \x02\x12\x0c\n\x08CANCELED\x10\x03\"\xa5\x02\n\x08Exchange\x12\x1f\n\x0b\
    exchange_id\x18\x01\x20\x01(\x03R\nexchangeId\x12'\n\x0fcreator_address\
    \x18\x02\x20\x01(\x0cR\x0ecreatorAddress\x12\x1f\n\x0bcreate_time\x18\
    \x03\x20\x01(\x03R\ncreateTime\x12$\n\x0efirst_token_id\x18\x06\x20\x01(\
    \x0cR\x0cfirstTokenId\x12.\n\x13first_token_balance\x18\x07\x20\x01(\x03\
    R\x11firstTokenBalance\x12&\n\x0fsecond_token_id\x18\x08\x20\x01(\x0cR\r\
    secondTokenId\x120\n\x14second_token_balance\x18\t\x20\x01(\x03R\x12seco\
    ndTokenBalance\"\x9d\x01\n\x0fChainParameters\x12P\n\x0echainParameter\
    \x18\x01\x20\x03(\x0b2(.protocol.ChainParameters.ChainParameterR\x0echai\
    nParameter\x1a8\n\x0eChainParameter\x12\x10\n\x03key\x18\x01\x20\x01(\tR\
    \x03key\x12\x14\n\x05value\x18\x02\x20\x01(\x03R\x05value\"\xb0\x16\n\
    \x07Account\x12!\n\x0caccount_name\x18\x01\x20\x01(\x0cR\x0baccountName\
    \x12)\n\x04type\x18\x02\x20\x01(\x0e2\x15.protocol.AccountTypeR\x04type\
    \x12\x18\n\x07address\x18\x03\x20\x01(\x0cR\x07address\x12\x18\n\x07bala\
    nce\x18\x04\x20\x01(\x03R\x07balance\x12$\n\x05votes\x18\x05\x20\x03(\
    \x0b2\x0e.protocol.VoteR\x05votes\x122\n\x05asset\x18\x06\x20\x03(\x0b2\
    \x1c.protocol.Account.AssetEntryR\x05asset\x128\n\x07assetV2\x188\x20\
    \x03(\x0b2\x1e.protocol.Account.AssetV2EntryR\x07assetV2\x120\n\x06froze\
    n\x18\x07\x20\x03(\x0b2\x18.protocol.Account.FrozenR\x06frozen\x12\x1b\n\
    \tnet_usage\x18\x08\x20\x01(\x03R\x08netUsage\x12c\n/acquired_delegated_\
    frozen_balance_for_bandwidth\x18)\x20\x01(\x03R*acquiredDelegatedFrozenB\
    alanceForBandwidth\x12R\n&delegated_frozen_balance_for_bandwidth\x18*\
    \x20\x01(\x03R\"delegatedFrozenBalanceForBandwidth\x12\x1f\n\x0bcreate_t\
    ime\x18\t\x20\x01(\x03R\ncreateTime\x120\n\x14latest_opration_time\x18\n\
    \x20\x01(\x03R\x12latestOprationTime\x12\x1c\n\tallowance\x18\x0b\x20\
    \x01(\x03R\tallowance\x120\n\x14latest_withdraw_time\x18\x0c\x20\x01(\
    \x03R\x12latestWithdrawTime\x12\x12\n\x04code\x18\r\x20\x01(\x0cR\x04cod\
    e\x12\x1d\n\nis_witness\x18\x0e\x20\x01(\x08R\tisWitness\x12!\n\x0cis_co\
    mmittee\x18\x0f\x20\x01(\x08R\x0bisCommittee\x12=\n\rfrozen_supply\x18\
    \x10\x20\x03(\x0b2\x18.protocol.Account.FrozenR\x0cfrozenSupply\x12*\n\
    \x11asset_issued_name\x18\x11\x20\x01(\x0cR\x0fassetIssuedName\x12&\n\
    \x0fasset_issued_ID\x189\x20\x01(\x0cR\rassetIssuedID\x12n\n\x1blatest_a\
    sset_operation_time\x18\x12\x20\x03(\x0b2/.protocol.Account.LatestAssetO\
    perationTimeEntryR\x18latestAssetOperationTime\x12t\n\x1dlatest_asset_op\
    eration_timeV2\x18:\x20\x03(\x0b21.protocol.Account.LatestAssetOperation\
    TimeV2EntryR\x1alatestAssetOperationTimeV2\x12$\n\x0efree_net_usage\x18\
    \x13\x20\x01(\x03R\x0cfreeNetUsage\x12Y\n\x14free_asset_net_usage\x18\
    \x14\x20\x03(\x0b2(.protocol.Account.FreeAssetNetUsageEntryR\x11freeAsse\
    tNetUsage\x12_\n\x16free_asset_net_usageV2\x18;\x20\x03(\x0b2*.protocol.\
    Account.FreeAssetNetUsageV2EntryR\x13freeAssetNetUsageV2\x12.\n\x13lates\
    t_consume_time\x18\x15\x20\x01(\x03R\x11latestConsumeTime\x127\n\x18late\
    st_consume_free_time\x18\x16\x20\x01(\x03R\x15latestConsumeFreeTime\x12\
    \x1d\n\naccount_id\x18\x17\x20\x01(\x0cR\taccountId\x12L\n\x10account_re\
    source\x18\x1a\x20\x01(\x0b2!.protocol.Account.AccountResourceR\x0faccou\
    ntResource\x12\x1a\n\x08codeHash\x18\x1e\x20\x01(\x0cR\x08codeHash\x12?\
    \n\x10owner_permission\x18\x1f\x20\x01(\x0b2\x14.protocol.PermissionR\
    \x0fownerPermission\x12C\n\x12witness_permission\x18\x20\x20\x01(\x0b2\
    \x14.protocol.PermissionR\x11witnessPermission\x12A\n\x11active_permissi\
    on\x18!\x20\x03(\x0b2\x14.protocol.PermissionR\x10activePermission\x1aP\
    \n\x06Frozen\x12%\n\x0efrozen_balance\x18\x01\x20\x01(\x03R\rfrozenBalan\
    ce\x12\x1f\n\x0bexpire_time\x18\x02\x20\x01(\x03R\nexpireTime\x1a8\n\nAs\
    setEntry\x12\x10\n\x03key\x18\x01\x20\x01(\tR\x03key\x12\x14\n\x05value\
    \x18\x02\x20\x01(\x03R\x05value:\x028\x01\x1a:\n\x0cAssetV2Entry\x12\x10\
    \n\x03key\x18\x01\x20\x01(\tR\x03key\x12\x14\n\x05value\x18\x02\x20\x01(\
    \x03R\x05value:\x028\x01\x1aK\n\x1dLatestAssetOperationTimeEntry\x12\x10\
    \n\x03key\x18\x01\x20\x01(\tR\x03key\x12\x14\n\x05value\x18\x02\x20\x01(\
    \x03R\x05value:\x028\x01\x1aM\n\x1fLatestAssetOperationTimeV2Entry\x12\
    \x10\n\x03key\x18\x01\x20\x01(\tR\x03key\x12\x14\n\x05value\x18\x02\x20\
    \x01(\x03R\x05value:\x028\x01\x1aD\n\x16FreeAssetNetUsageEntry\x12\x10\n\
    \x03key\x18\x01\x20\x01(\tR\x03key\x12\x14\n\x05value\x18\x02\x20\x01(\
    \x03R\x05value:\x028\x01\x1aF\n\x18FreeAssetNetUsageV2Entry\x12\x10\n\
    \x03key\x18\x01\x20\x01(\tR\x03key\x12\x14\n\x05value\x18\x02\x20\x01(\
    \x03R\x05value:\x028\x01\x1a\x85\x04\n\x0fAccountResource\x12!\n\x0cener\
    gy_usage\x18\x01\x20\x01(\x03R\x0benergyUsage\x12S\n\x19frozen_balance_f\
    or_energy\x18\x02\x20\x01(\x0b2\x18.protocol.Account.FrozenR\x16frozenBa\
    lanceForEnergy\x12B\n\x1elatest_consume_time_for_energy\x18\x03\x20\x01(\
    \x03R\x1alatestConsumeTimeForEnergy\x12]\n,acquired_delegated_frozen_bal\
    ance_for_energy\x18\x04\x20\x01(\x03R'acquiredDelegatedFrozenBalanceForE\
    nergy\x12L\n#delegated_frozen_balance_for_energy\x18\x05\x20\x01(\x03R\
    \x1fdelegatedFrozenBalanceForEnergy\x12#\n\rstorage_limit\x18\x06\x20\
    \x01(\x03R\x0cstorageLimit\x12#\n\rstorage_usage\x18\x07\x20\x01(\x03R\
    \x0cstorageUsage\x12?\n\x1clatest_exchange_storage_time\x18\x08\x20\x01(\
    \x03R\x19latestExchangeStorageTime\"7\n\x03Key\x12\x18\n\x07address\x18\
    \x01\x20\x01(\x0cR\x07address\x12\x16\n\x06weight\x18\x02\x20\x01(\x03R\
    \x06weight\"\xa3\x02\n\x11DelegatedResource\x12\x12\n\x04from\x18\x01\
    \x20\x01(\x0cR\x04from\x12\x0e\n\x02to\x18\x02\x20\x01(\x0cR\x02to\x12?\
    \n\x1cfrozen_balance_for_bandwidth\x18\x03\x20\x01(\x03R\x19frozenBalanc\
    eForBandwidth\x129\n\x19frozen_balance_for_energy\x18\x04\x20\x01(\x03R\
    \x16frozenBalanceForEnergy\x129\n\x19expire_time_for_bandwidth\x18\x05\
    \x20\x01(\x03R\x16expireTimeForBandwidth\x123\n\x16expire_time_for_energ\
    y\x18\x06\x20\x01(\x03R\x13expireTimeForEnergy\"c\n\tauthority\x12-\n\
    \x07account\x18\x01\x20\x01(\x0b2\x13.protocol.AccountIdR\x07account\x12\
    '\n\x0fpermission_name\x18\x02\x20\x01(\x0cR\x0epermissionName\"\xb2\x02\
    \n\nPermission\x127\n\x04type\x18\x01\x20\x01(\x0e2#.protocol.Permission\
    .PermissionTypeR\x04type\x12\x0e\n\x02id\x18\x02\x20\x01(\x05R\x02id\x12\
    '\n\x0fpermission_name\x18\x03\x20\x01(\tR\x0epermissionName\x12\x1c\n\t\
    threshold\x18\x04\x20\x01(\x03R\tthreshold\x12\x1b\n\tparent_id\x18\x05\
    \x20\x01(\x05R\x08parentId\x12\x1e\n\noperations\x18\x06\x20\x01(\x0cR\n\
    operations\x12!\n\x04keys\x18\x07\x20\x03(\x0b2\r.protocol.KeyR\x04keys\
    \"4\n\x0ePermissionType\x12\t\n\x05Owner\x10\0\x12\x0b\n\x07Witness\x10\
    \x01\x12\n\n\x06Active\x10\x02\"\x99\x02\n\x07Witness\x12\x18\n\x07addre\
    ss\x18\x01\x20\x01(\x0cR\x07address\x12\x1c\n\tvoteCount\x18\x02\x20\x01\
    (\x03R\tvoteCount\x12\x16\n\x06pubKey\x18\x03\x20\x01(\x0cR\x06pubKey\
    \x12\x10\n\x03url\x18\x04\x20\x01(\tR\x03url\x12$\n\rtotalProduced\x18\
    \x05\x20\x01(\x03R\rtotalProduced\x12\x20\n\x0btotalMissed\x18\x06\x20\
    \x01(\x03R\x0btotalMissed\x12&\n\x0elatestBlockNum\x18\x07\x20\x01(\x03R\
    \x0elatestBlockNum\x12$\n\rlatestSlotNum\x18\x08\x20\x01(\x03R\rlatestSl\
    otNum\x12\x16\n\x06isJobs\x18\t\x20\x01(\x08R\x06isJobs\"{\n\x05Votes\
    \x12\x18\n\x07address\x18\x01\x20\x01(\x0cR\x07address\x12+\n\told_votes\
    \x18\x02\x20\x03(\x0b2\x0e.protocol.VoteR\x08oldVotes\x12+\n\tnew_votes\
    \x18\x03\x20\x03(\x0b2\x0e.protocol.VoteR\x08newVotes\"@\n\x08TXOutput\
    \x12\x14\n\x05value\x18\x01\x20\x01(\x03R\x05value\x12\x1e\n\npubKeyHash\
    \x18\x02\x20\x01(\x0cR\npubKeyHash\"\xa0\x01\n\x07TXInput\x120\n\x08raw_\
    data\x18\x01\x20\x01(\x0b2\x15.protocol.TXInput.rawR\x07rawData\x12\x1c\
    \n\tsignature\x18\x04\x20\x01(\x0cR\tsignature\x1aE\n\x03raw\x12\x12\n\
    \x04txID\x18\x01\x20\x01(\x0cR\x04txID\x12\x12\n\x04vout\x18\x02\x20\x01\
    (\x03R\x04vout\x12\x16\n\x06pubKey\x18\x03\x20\x01(\x0cR\x06pubKey\"9\n\
    \tTXOutputs\x12,\n\x07outputs\x18\x01\x20\x03(\x0b2\x12.protocol.TXOutpu\
    tR\x07outputs\"\xac\x02\n\x0fResourceReceipt\x12!\n\x0cenergy_usage\x18\
    \x01\x20\x01(\x03R\x0benergyUsage\x12\x1d\n\nenergy_fee\x18\x02\x20\x01(\
    \x03R\tenergyFee\x12.\n\x13origin_energy_usage\x18\x03\x20\x01(\x03R\x11\
    originEnergyUsage\x12,\n\x12energy_usage_total\x18\x04\x20\x01(\x03R\x10\
    energyUsageTotal\x12\x1b\n\tnet_usage\x18\x05\x20\x01(\x03R\x08netUsage\
    \x12\x17\n\x07net_fee\x18\x06\x20\x01(\x03R\x06netFee\x12C\n\x06result\
    \x18\x07\x20\x01(\x0e2+.protocol.Transaction.Result.contractResultR\x06r\
    esult\"\x8b\x13\n\x0bTransaction\x124\n\x08raw_data\x18\x01\x20\x01(\x0b\
    2\x19.protocol.Transaction.rawR\x07rawData\x12\x1c\n\tsignature\x18\x02\
    \x20\x03(\x0cR\tsignature\x12.\n\x03ret\x18\x05\x20\x03(\x0b2\x1c.protoc\
    ol.Transaction.ResultR\x03ret\x1a\xb9\x08\n\x08Contract\x12?\n\x04type\
    \x18\x01\x20\x01(\x0e2+.protocol.Transaction.Contract.ContractTypeR\x04t\
    ype\x122\n\tparameter\x18\x02\x20\x01(\x0b2\x14.google.protobuf.AnyR\tpa\
    rameter\x12\x1a\n\x08provider\x18\x03\x20\x01(\x0cR\x08provider\x12\"\n\
    \x0cContractName\x18\x04\x20\x01(\x0cR\x0cContractName\x12#\n\rPermissio\
    n_id\x18\x05\x20\x01(\x05R\x0cPermissionId\"\xd2\x06\n\x0cContractType\
    \x12\x19\n\x15AccountCreateContract\x10\0\x12\x14\n\x10TransferContract\
    \x10\x01\x12\x19\n\x15TransferAssetContract\x10\x02\x12\x15\n\x11VoteAss\
    etContract\x10\x03\x12\x17\n\x13VoteWitnessContract\x10\x04\x12\x19\n\
    \x15WitnessCreateContract\x10\x05\x12\x16\n\x12AssetIssueContract\x10\
    \x06\x12\x19\n\x15WitnessUpdateContract\x10\x08\x12!\n\x1dParticipateAss\
    etIssueContract\x10\t\x12\x19\n\x15AccountUpdateContract\x10\n\x12\x19\n\
    \x15FreezeBalanceContract\x10\x0b\x12\x1b\n\x17UnfreezeBalanceContract\
    \x10\x0c\x12\x1b\n\x17WithdrawBalanceContract\x10\r\x12\x19\n\x15Unfreez\
    eAssetContract\x10\x0e\x12\x17\n\x13UpdateAssetContract\x10\x0f\x12\x1a\
    \n\x16ProposalCreateContract\x10\x10\x12\x1b\n\x17ProposalApproveContrac\
    t\x10\x11\x12\x1a\n\x16ProposalDeleteContract\x10\x12\x12\x18\n\x14SetAc\
    countIdContract\x10\x13\x12\x12\n\x0eCustomContract\x10\x14\x12\x17\n\
    \x13CreateSmartContract\x10\x1e\x12\x18\n\x14TriggerSmartContract\x10\
    \x1f\x12\x0f\n\x0bGetContract\x10\x20\x12\x19\n\x15UpdateSettingContract\
    \x10!\x12\x1a\n\x16ExchangeCreateContract\x10)\x12\x1a\n\x16ExchangeInje\
    ctContract\x10*\x12\x1c\n\x18ExchangeWithdrawContract\x10+\x12\x1f\n\x1b\
    ExchangeTransactionContract\x10,\x12\x1d\n\x19UpdateEnergyLimitContract\
    \x10-\x12#\n\x1fAccountPermissionUpdateContract\x10.\x12\x14\n\x10ClearA\
    BIContract\x100\x1a\xd1\x06\n\x06Result\x12\x10\n\x03fee\x18\x01\x20\x01\
    (\x03R\x03fee\x123\n\x03ret\x18\x02\x20\x01(\x0e2!.protocol.Transaction.\
    Result.codeR\x03ret\x12M\n\x0bcontractRet\x18\x03\x20\x01(\x0e2+.protoco\
    l.Transaction.Result.contractResultR\x0bcontractRet\x12\"\n\x0cassetIssu\
    eID\x18\x0e\x20\x01(\tR\x0cassetIssueID\x12'\n\x0fwithdraw_amount\x18\
    \x0f\x20\x01(\x03R\x0ewithdrawAmount\x12'\n\x0funfreeze_amount\x18\x10\
    \x20\x01(\x03R\x0eunfreezeAmount\x128\n\x18exchange_received_amount\x18\
    \x12\x20\x01(\x03R\x16exchangeReceivedAmount\x12C\n\x1eexchange_inject_a\
    nother_amount\x18\x13\x20\x01(\x03R\x1bexchangeInjectAnotherAmount\x12G\
    \n\x20exchange_withdraw_another_amount\x18\x14\x20\x01(\x03R\x1dexchange\
    WithdrawAnotherAmount\x12\x1f\n\x0bexchange_id\x18\x15\x20\x01(\x03R\nex\
    changeId\"\x1e\n\x04code\x12\n\n\x06SUCESS\x10\0\x12\n\n\x06FAILED\x10\
    \x01\"\xb1\x02\n\x0econtractResult\x12\x0b\n\x07DEFAULT\x10\0\x12\x0b\n\
    \x07SUCCESS\x10\x01\x12\n\n\x06REVERT\x10\x02\x12\x18\n\x14BAD_JUMP_DEST\
    INATION\x10\x03\x12\x11\n\rOUT_OF_MEMORY\x10\x04\x12\x18\n\x14PRECOMPILE\
    D_CONTRACT\x10\x05\x12\x13\n\x0fSTACK_TOO_SMALL\x10\x06\x12\x13\n\x0fSTA\
    CK_TOO_LARGE\x10\x07\x12\x15\n\x11ILLEGAL_OPERATION\x10\x08\x12\x12\n\
    \x0eSTACK_OVERFLOW\x10\t\x12\x11\n\rOUT_OF_ENERGY\x10\n\x12\x0f\n\x0bOUT\
    _OF_TIME\x10\x0b\x12\x17\n\x13JVM_STACK_OVER_FLOW\x10\x0c\x12\x0b\n\x07U\
    NKNOWN\x10\r\x12\x13\n\x0fTRANSFER_FAILED\x10\x0e\x1a\xe7\x02\n\x03raw\
    \x12&\n\x0fref_block_bytes\x18\x01\x20\x01(\x0cR\rrefBlockBytes\x12\"\n\
    \rref_block_num\x18\x03\x20\x01(\x03R\x0brefBlockNum\x12$\n\x0eref_block\
    _hash\x18\x04\x20\x01(\x0cR\x0crefBlockHash\x12\x1e\n\nexpiration\x18\
    \x08\x20\x01(\x03R\nexpiration\x12)\n\x05auths\x18\t\x20\x03(\x0b2\x13.p\
    rotocol.authorityR\x05auths\x12\x12\n\x04data\x18\n\x20\x01(\x0cR\x04dat\
    a\x12:\n\x08contract\x18\x0b\x20\x03(\x0b2\x1e.protocol.Transaction.Cont\
    ractR\x08contract\x12\x18\n\x07scripts\x18\x0c\x20\x01(\x0cR\x07scripts\
    \x12\x1c\n\ttimestamp\x18\x0e\x20\x01(\x03R\ttimestamp\x12\x1b\n\tfee_li\
    mit\x18\x12\x20\x01(\x03R\x08feeLimit\"\xae\x07\n\x0fTransactionInfo\x12\
    \x0e\n\x02id\x18\x01\x20\x01(\x0cR\x02id\x12\x10\n\x03fee\x18\x02\x20\
    \x01(\x03R\x03fee\x12\x20\n\x0bblockNumber\x18\x03\x20\x01(\x03R\x0bbloc\
    kNumber\x12&\n\x0eblockTimeStamp\x18\x04\x20\x01(\x03R\x0eblockTimeStamp\
    \x12&\n\x0econtractResult\x18\x05\x20\x03(\x0cR\x0econtractResult\x12)\n\
    \x10contract_address\x18\x06\x20\x01(\x0cR\x0fcontractAddress\x123\n\x07\
    receipt\x18\x07\x20\x01(\x0b2\x19.protocol.ResourceReceiptR\x07receipt\
    \x12/\n\x03log\x18\x08\x20\x03(\x0b2\x1d.protocol.TransactionInfo.LogR\
    \x03log\x126\n\x06result\x18\t\x20\x01(\x0e2\x1e.protocol.TransactionInf\
    o.codeR\x06result\x12\x1e\n\nresMessage\x18\n\x20\x01(\x0cR\nresMessage\
    \x12\"\n\x0cassetIssueID\x18\x0e\x20\x01(\tR\x0cassetIssueID\x12'\n\x0fw\
    ithdraw_amount\x18\x0f\x20\x01(\x03R\x0ewithdrawAmount\x12'\n\x0funfreez\
    e_amount\x18\x10\x20\x01(\x03R\x0eunfreezeAmount\x12R\n\x15internal_tran\
    sactions\x18\x11\x20\x03(\x0b2\x1d.protocol.InternalTransactionR\x14inte\
    rnalTransactions\x128\n\x18exchange_received_amount\x18\x12\x20\x01(\x03\
    R\x16exchangeReceivedAmount\x12C\n\x1eexchange_inject_another_amount\x18\
    \x13\x20\x01(\x03R\x1bexchangeInjectAnotherAmount\x12G\n\x20exchange_wit\
    hdraw_another_amount\x18\x14\x20\x01(\x03R\x1dexchangeWithdrawAnotherAmo\
    unt\x12\x1f\n\x0bexchange_id\x18\x15\x20\x01(\x03R\nexchangeId\x1aK\n\
    \x03Log\x12\x18\n\x07address\x18\x01\x20\x01(\x0cR\x07address\x12\x16\n\
    \x06topics\x18\x02\x20\x03(\x0cR\x06topics\x12\x12\n\x04data\x18\x03\x20\
    \x01(\x0cR\x04data\"\x1e\n\x04code\x12\n\n\x06SUCESS\x10\0\x12\n\n\x06FA\
    ILED\x10\x01\"\x9f\x01\n\x0eTransactionRet\x12\x20\n\x0bblockNumber\x18\
    \x01\x20\x01(\x03R\x0bblockNumber\x12&\n\x0eblockTimeStamp\x18\x02\x20\
    \x01(\x03R\x0eblockTimeStamp\x12C\n\x0ftransactioninfo\x18\x03\x20\x03(\
    \x0b2\x19.protocol.TransactionInfoR\x0ftransactioninfo\"I\n\x0cTransacti\
    ons\x129\n\x0ctransactions\x18\x01\x20\x03(\x0b2\x15.protocol.Transactio\
    nR\x0ctransactions\"j\n\x0fTransactionSign\x127\n\x0btransaction\x18\x01\
    \x20\x01(\x0b2\x15.protocol.TransactionR\x0btransaction\x12\x1e\n\npriva\
    teKey\x18\x02\x20\x01(\x0cR\nprivateKey\"\xfc\x02\n\x0bBlockHeader\x124\
    \n\x08raw_data\x18\x01\x20\x01(\x0b2\x19.protocol.BlockHeader.rawR\x07ra\
    wData\x12+\n\x11witness_signature\x18\x02\x20\x01(\x0cR\x10witnessSignat\
    ure\x1a\x89\x02\n\x03raw\x12\x1c\n\ttimestamp\x18\x01\x20\x01(\x03R\ttim\
    estamp\x12\x1e\n\ntxTrieRoot\x18\x02\x20\x01(\x0cR\ntxTrieRoot\x12\x1e\n\
    \nparentHash\x18\x03\x20\x01(\x0cR\nparentHash\x12\x16\n\x06number\x18\
    \x07\x20\x01(\x03R\x06number\x12\x1d\n\nwitness_id\x18\x08\x20\x01(\x03R\
    \twitnessId\x12'\n\x0fwitness_address\x18\t\x20\x01(\x0cR\x0ewitnessAddr\
    ess\x12\x18\n\x07version\x18\n\x20\x01(\x05R\x07version\x12*\n\x10accoun\
    tStateRoot\x18\x0b\x20\x01(\x0cR\x10accountStateRoot\"|\n\x05Block\x129\
    \n\x0ctransactions\x18\x01\x20\x03(\x0b2\x15.protocol.TransactionR\x0ctr\
    ansactions\x128\n\x0cblock_header\x18\x02\x20\x01(\x0b2\x15.protocol.Blo\
    ckHeaderR\x0bblockHeader\"\x9a\x01\n\x0eChainInventory\x122\n\x03ids\x18\
    \x01\x20\x03(\x0b2\x20.protocol.ChainInventory.BlockIdR\x03ids\x12\x1d\n\
    \nremain_num\x18\x02\x20\x01(\x03R\tremainNum\x1a5\n\x07BlockId\x12\x12\
    \n\x04hash\x18\x01\x20\x01(\x0cR\x04hash\x12\x16\n\x06number\x18\x02\x20\
    \x01(\x03R\x06number\"\xd8\x01\n\x0eBlockInventory\x122\n\x03ids\x18\x01\
    \x20\x03(\x0b2\x20.protocol.BlockInventory.BlockIdR\x03ids\x121\n\x04typ\
    e\x18\x02\x20\x01(\x0e2\x1d.protocol.BlockInventory.TypeR\x04type\x1a5\n\
    \x07BlockId\x12\x12\n\x04hash\x18\x01\x20\x01(\x0cR\x04hash\x12\x16\n\
    \x06number\x18\x02\x20\x01(\x03R\x06number\"(\n\x04Type\x12\x08\n\x04SYN\
    C\x10\0\x12\x0b\n\x07ADVTISE\x10\x01\x12\t\n\x05FETCH\x10\x02\"y\n\tInve\
    ntory\x125\n\x04type\x18\x01\x20\x01(\x0e2!.protocol.Inventory.Inventory\
    TypeR\x04type\x12\x10\n\x03ids\x18\x02\x20\x03(\x0cR\x03ids\"#\n\rInvent\
    oryType\x12\x07\n\x03TRX\x10\0\x12\t\n\x05BLOCK\x10\x01\"\x8f\x02\n\x05I\
    tems\x12,\n\x04type\x18\x01\x20\x01(\x0e2\x18.protocol.Items.ItemTypeR\
    \x04type\x12'\n\x06blocks\x18\x02\x20\x03(\x0b2\x0f.protocol.BlockR\x06b\
    locks\x12:\n\rblock_headers\x18\x03\x20\x03(\x0b2\x15.protocol.BlockHead\
    erR\x0cblockHeaders\x129\n\x0ctransactions\x18\x04\x20\x03(\x0b2\x15.pro\
    tocol.TransactionR\x0ctransactions\"8\n\x08ItemType\x12\x07\n\x03ERR\x10\
    \0\x12\x07\n\x03TRX\x10\x01\x12\t\n\x05BLOCK\x10\x02\x12\x0f\n\x0bBLOCKH\
    EADER\x10\x03\"J\n\x11DynamicProperties\x125\n\x17last_solidity_block_nu\
    m\x18\x01\x20\x01(\x03R\x14lastSolidityBlockNum\"A\n\x11DisconnectMessag\
    e\x12,\n\x06reason\x18\x01\x20\x01(\x0e2\x14.protocol.ReasonCodeR\x06rea\
    son\"\xf3\x02\n\x0cHelloMessage\x12&\n\x04from\x18\x01\x20\x01(\x0b2\x12\
    .protocol.EndpointR\x04from\x12\x18\n\x07version\x18\x02\x20\x01(\x05R\
    \x07version\x12\x1c\n\ttimestamp\x18\x03\x20\x01(\x03R\ttimestamp\x12F\n\
    \x0egenesisBlockId\x18\x04\x20\x01(\x0b2\x1e.protocol.HelloMessage.Block\
    IdR\x0egenesisBlockId\x12B\n\x0csolidBlockId\x18\x05\x20\x01(\x0b2\x1e.p\
    rotocol.HelloMessage.BlockIdR\x0csolidBlockId\x12@\n\x0bheadBlockId\x18\
    \x06\x20\x01(\x0b2\x1e.protocol.HelloMessage.BlockIdR\x0bheadBlockId\x1a\
    5\n\x07BlockId\x12\x12\n\x04hash\x18\x01\x20\x01(\x0cR\x04hash\x12\x16\n\
    \x06number\x18\x02\x20\x01(\x03R\x06number\"\xee\x08\n\rSmartContract\
    \x12%\n\x0eorigin_address\x18\x01\x20\x01(\x0cR\roriginAddress\x12)\n\
    \x10contract_address\x18\x02\x20\x01(\x0cR\x0fcontractAddress\x12-\n\x03\
    abi\x18\x03\x20\x01(\x0b2\x1b.protocol.SmartContract.ABIR\x03abi\x12\x1a\
    \n\x08bytecode\x18\x04\x20\x01(\x0cR\x08bytecode\x12\x1d\n\ncall_value\
    \x18\x05\x20\x01(\x03R\tcallValue\x12A\n\x1dconsume_user_resource_percen\
    t\x18\x06\x20\x01(\x03R\x1aconsumeUserResourcePercent\x12\x12\n\x04name\
    \x18\x07\x20\x01(\tR\x04name\x12.\n\x13origin_energy_limit\x18\x08\x20\
    \x01(\x03R\x11originEnergyLimit\x12\x1b\n\tcode_hash\x18\t\x20\x01(\x0cR\
    \x08codeHash\x12\x19\n\x08trx_hash\x18\n\x20\x01(\x0cR\x07trxHash\x1a\
    \xe1\x05\n\x03ABI\x129\n\x06entrys\x18\x01\x20\x03(\x0b2!.protocol.Smart\
    Contract.ABI.EntryR\x06entrys\x1a\x9e\x05\n\x05Entry\x12\x1c\n\tanonymou\
    s\x18\x01\x20\x01(\x08R\tanonymous\x12\x1a\n\x08constant\x18\x02\x20\x01\
    (\x08R\x08constant\x12\x12\n\x04name\x18\x03\x20\x01(\tR\x04name\x12?\n\
    \x06inputs\x18\x04\x20\x03(\x0b2'.protocol.SmartContract.ABI.Entry.Param\
    R\x06inputs\x12A\n\x07outputs\x18\x05\x20\x03(\x0b2'.protocol.SmartContr\
    act.ABI.Entry.ParamR\x07outputs\x12?\n\x04type\x18\x06\x20\x01(\x0e2+.pr\
    otocol.SmartContract.ABI.Entry.EntryTypeR\x04type\x12\x18\n\x07payable\
    \x18\x07\x20\x01(\x08R\x07payable\x12_\n\x0fstateMutability\x18\x08\x20\
    \x01(\x0e25.protocol.SmartContract.ABI.Entry.StateMutabilityTypeR\x0fsta\
    teMutability\x1aI\n\x05Param\x12\x18\n\x07indexed\x18\x01\x20\x01(\x08R\
    \x07indexed\x12\x12\n\x04name\x18\x02\x20\x01(\tR\x04name\x12\x12\n\x04t\
    ype\x18\x03\x20\x01(\tR\x04type\"Y\n\tEntryType\x12\x14\n\x10UnknownEntr\
    yType\x10\0\x12\x0f\n\x0bConstructor\x10\x01\x12\x0c\n\x08Function\x10\
    \x02\x12\t\n\x05Event\x10\x03\x12\x0c\n\x08Fallback\x10\x04\"a\n\x13Stat\
    eMutabilityType\x12\x19\n\x15UnknownMutabilityType\x10\0\x12\x08\n\x04Pu\
    re\x10\x01\x12\x08\n\x04View\x10\x02\x12\x0e\n\nNonpayable\x10\x03\x12\
    \x0b\n\x07Payable\x10\x04\"\xcb\x02\n\x13InternalTransaction\x12\x12\n\
    \x04hash\x18\x01\x20\x01(\x0cR\x04hash\x12%\n\x0ecaller_address\x18\x02\
    \x20\x01(\x0cR\rcallerAddress\x12-\n\x12transferTo_address\x18\x03\x20\
    \x01(\x0cR\x11transferToAddress\x12Q\n\rcallValueInfo\x18\x04\x20\x03(\
    \x0b2+.protocol.InternalTransaction.CallValueInfoR\rcallValueInfo\x12\
    \x12\n\x04note\x18\x05\x20\x01(\x0cR\x04note\x12\x1a\n\x08rejected\x18\
    \x06\x20\x01(\x08R\x08rejected\x1aG\n\rCallValueInfo\x12\x1c\n\tcallValu\
    e\x18\x01\x20\x01(\x03R\tcallValue\x12\x18\n\x07tokenId\x18\x02\x20\x01(\
    \tR\x07tokenId\"}\n\x1dDelegatedResourceAccountIndex\x12\x18\n\x07accoun\
    t\x18\x01\x20\x01(\x0cR\x07account\x12\"\n\x0cfromAccounts\x18\x02\x20\
    \x03(\x0cR\x0cfromAccounts\x12\x1e\n\ntoAccounts\x18\x03\x20\x03(\x0cR\n\
    toAccounts\"\xbf\x1a\n\x08NodeInfo\x12\"\n\x0cbeginSyncNum\x18\x01\x20\
    \x01(\x03R\x0cbeginSyncNum\x12\x14\n\x05block\x18\x02\x20\x01(\tR\x05blo\
    ck\x12$\n\rsolidityBlock\x18\x03\x20\x01(\tR\rsolidityBlock\x120\n\x13cu\
    rrentConnectCount\x18\x04\x20\x01(\x05R\x13currentConnectCount\x12.\n\
    \x12activeConnectCount\x18\x05\x20\x01(\x05R\x12activeConnectCount\x120\
    \n\x13passiveConnectCount\x18\x06\x20\x01(\x05R\x13passiveConnectCount\
    \x12\x1c\n\ttotalFlow\x18\x07\x20\x01(\x03R\ttotalFlow\x12?\n\x0cpeerInf\
    oList\x18\x08\x20\x03(\x0b2\x1b.protocol.NodeInfo.PeerInfoR\x0cpeerInfoL\
    ist\x12I\n\x0econfigNodeInfo\x18\t\x20\x01(\x0b2!.protocol.NodeInfo.Conf\
    igNodeInfoR\x0econfigNodeInfo\x12@\n\x0bmachineInfo\x18\n\x20\x01(\x0b2\
    \x1e.protocol.NodeInfo.MachineInfoR\x0bmachineInfo\x12]\n\x13cheatWitnes\
    sInfoMap\x18\x0b\x20\x03(\x0b2+.protocol.NodeInfo.CheatWitnessInfoMapEnt\
    ryR\x13cheatWitnessInfoMap\x1aF\n\x18CheatWitnessInfoMapEntry\x12\x10\n\
    \x03key\x18\x01\x20\x01(\tR\x03key\x12\x14\n\x05value\x18\x02\x20\x01(\t\
    R\x05value:\x028\x01\x1a\xc8\x07\n\x08PeerInfo\x12$\n\rlastSyncBlock\x18\
    \x01\x20\x01(\tR\rlastSyncBlock\x12\x1c\n\tremainNum\x18\x02\x20\x01(\
    \x03R\tremainNum\x120\n\x13lastBlockUpdateTime\x18\x03\x20\x01(\x03R\x13\
    lastBlockUpdateTime\x12\x1a\n\x08syncFlag\x18\x04\x20\x01(\x08R\x08syncF\
    lag\x128\n\x17headBlockTimeWeBothHave\x18\x05\x20\x01(\x03R\x17headBlock\
    TimeWeBothHave\x12*\n\x10needSyncFromPeer\x18\x06\x20\x01(\x08R\x10needS\
    yncFromPeer\x12&\n\x0eneedSyncFromUs\x18\x07\x20\x01(\x08R\x0eneedSyncFr\
    omUs\x12\x12\n\x04host\x18\x08\x20\x01(\tR\x04host\x12\x12\n\x04port\x18\
    \t\x20\x01(\x05R\x04port\x12\x16\n\x06nodeId\x18\n\x20\x01(\tR\x06nodeId\
    \x12\x20\n\x0bconnectTime\x18\x0b\x20\x01(\x03R\x0bconnectTime\x12\x1e\n\
    \navgLatency\x18\x0c\x20\x01(\x01R\navgLatency\x12(\n\x0fsyncToFetchSize\
    \x18\r\x20\x01(\x05R\x0fsyncToFetchSize\x126\n\x16syncToFetchSizePeekNum\
    \x18\x0e\x20\x01(\x03R\x16syncToFetchSizePeekNum\x126\n\x16syncBlockRequ\
    estedSize\x18\x0f\x20\x01(\x05R\x16syncBlockRequestedSize\x12$\n\runFetc\
    hSynNum\x18\x10\x20\x01(\x03R\runFetchSynNum\x12(\n\x0fblockInPorcSize\
    \x18\x11\x20\x01(\x05R\x0fblockInPorcSize\x120\n\x13headBlockWeBothHave\
    \x18\x12\x20\x01(\tR\x13headBlockWeBothHave\x12\x1a\n\x08isActive\x18\
    \x13\x20\x01(\x08R\x08isActive\x12\x14\n\x05score\x18\x14\x20\x01(\x05R\
    \x05score\x12\x1c\n\tnodeCount\x18\x15\x20\x01(\x05R\tnodeCount\x12\x16\
    \n\x06inFlow\x18\x16\x20\x01(\x03R\x06inFlow\x12(\n\x0fdisconnectTimes\
    \x18\x17\x20\x01(\x05R\x0fdisconnectTimes\x124\n\x15localDisconnectReaso\
    n\x18\x18\x20\x01(\tR\x15localDisconnectReason\x126\n\x16remoteDisconnec\
    tReason\x18\x19\x20\x01(\tR\x16remoteDisconnectReason\x1a\xa2\x06\n\x0eC\
    onfigNodeInfo\x12\x20\n\x0bcodeVersion\x18\x01\x20\x01(\tR\x0bcodeVersio\
    n\x12\x1e\n\np2pVersion\x18\x02\x20\x01(\tR\np2pVersion\x12\x1e\n\nliste\
    nPort\x18\x03\x20\x01(\x05R\nlistenPort\x12&\n\x0ediscoverEnable\x18\x04\
    \x20\x01(\x08R\x0ediscoverEnable\x12&\n\x0eactiveNodeSize\x18\x05\x20\
    \x01(\x05R\x0eactiveNodeSize\x12(\n\x0fpassiveNodeSize\x18\x06\x20\x01(\
    \x05R\x0fpassiveNodeSize\x12\"\n\x0csendNodeSize\x18\x07\x20\x01(\x05R\
    \x0csendNodeSize\x12(\n\x0fmaxConnectCount\x18\x08\x20\x01(\x05R\x0fmaxC\
    onnectCount\x124\n\x15sameIpMaxConnectCount\x18\t\x20\x01(\x05R\x15sameI\
    pMaxConnectCount\x12*\n\x10backupListenPort\x18\n\x20\x01(\x05R\x10backu\
    pListenPort\x12*\n\x10backupMemberSize\x18\x0b\x20\x01(\x05R\x10backupMe\
    mberSize\x12&\n\x0ebackupPriority\x18\x0c\x20\x01(\x05R\x0ebackupPriorit\
    y\x12\x1c\n\tdbVersion\x18\r\x20\x01(\x05R\tdbVersion\x122\n\x14minParti\
    cipationRate\x18\x0e\x20\x01(\x05R\x14minParticipationRate\x12(\n\x0fsup\
    portConstant\x18\x0f\x20\x01(\x08R\x0fsupportConstant\x12\"\n\x0cminTime\
    Ratio\x18\x10\x20\x01(\x01R\x0cminTimeRatio\x12\"\n\x0cmaxTimeRatio\x18\
    \x11\x20\x01(\x01R\x0cmaxTimeRatio\x12:\n\x18allowCreationOfContracts\
    \x18\x12\x20\x01(\x03R\x18allowCreationOfContracts\x120\n\x13allowAdapti\
    veEnergy\x18\x13\x20\x01(\x03R\x13allowAdaptiveEnergy\x1a\xbb\x07\n\x0bM\
    achineInfo\x12\x20\n\x0bthreadCount\x18\x01\x20\x01(\x05R\x0bthreadCount\
    \x120\n\x13deadLockThreadCount\x18\x02\x20\x01(\x05R\x13deadLockThreadCo\
    unt\x12\x1a\n\x08cpuCount\x18\x03\x20\x01(\x05R\x08cpuCount\x12\x20\n\
    \x0btotalMemory\x18\x04\x20\x01(\x03R\x0btotalMemory\x12\x1e\n\nfreeMemo\
    ry\x18\x05\x20\x01(\x03R\nfreeMemory\x12\x18\n\x07cpuRate\x18\x06\x20\
    \x01(\x01R\x07cpuRate\x12\x20\n\x0bjavaVersion\x18\x07\x20\x01(\tR\x0bja\
    vaVersion\x12\x16\n\x06osName\x18\x08\x20\x01(\tR\x06osName\x12(\n\x0fjv\
    mTotalMemoery\x18\t\x20\x01(\x03R\x0fjvmTotalMemoery\x12$\n\rjvmFreeMemo\
    ry\x18\n\x20\x01(\x03R\rjvmFreeMemory\x12&\n\x0eprocessCpuRate\x18\x0b\
    \x20\x01(\x01R\x0eprocessCpuRate\x12]\n\x12memoryDescInfoList\x18\x0c\
    \x20\x03(\x0b2-.protocol.NodeInfo.MachineInfo.MemoryDescInfoR\x12memoryD\
    escInfoList\x12i\n\x16deadLockThreadInfoList\x18\r\x20\x03(\x0b21.protoc\
    ol.NodeInfo.MachineInfo.DeadLockThreadInfoR\x16deadLockThreadInfoList\
    \x1a\x8e\x01\n\x0eMemoryDescInfo\x12\x12\n\x04name\x18\x01\x20\x01(\tR\
    \x04name\x12\x1a\n\x08initSize\x18\x02\x20\x01(\x03R\x08initSize\x12\x18\
    \n\x07useSize\x18\x03\x20\x01(\x03R\x07useSize\x12\x18\n\x07maxSize\x18\
    \x04\x20\x01(\x03R\x07maxSize\x12\x18\n\x07useRate\x18\x05\x20\x01(\x01R\
    \x07useRate\x1a\xd2\x01\n\x12DeadLockThreadInfo\x12\x12\n\x04name\x18\
    \x01\x20\x01(\tR\x04name\x12\x1a\n\x08lockName\x18\x02\x20\x01(\tR\x08lo\
    ckName\x12\x1c\n\tlockOwner\x18\x03\x20\x01(\tR\tlockOwner\x12\x14\n\x05\
    state\x18\x04\x20\x01(\tR\x05state\x12\x1c\n\tblockTime\x18\x05\x20\x01(\
    \x03R\tblockTime\x12\x1a\n\x08waitTime\x18\x06\x20\x01(\x03R\x08waitTime\
    \x12\x1e\n\nstackTrace\x18\x07\x20\x01(\tR\nstackTrace*7\n\x0bAccountTyp\
    e\x12\n\n\x06Normal\x10\0\x12\x0e\n\nAssetIssue\x10\x01\x12\x0c\n\x08Con\
    tract\x10\x02*\xc7\x03\n\nReasonCode\x12\r\n\tREQUESTED\x10\0\x12\x10\n\
    \x0cBAD_PROTOCOL\x10\x02\x12\x12\n\x0eTOO_MANY_PEERS\x10\x04\x12\x12\n\
    \x0eDUPLICATE_PEER\x10\x05\x12\x19\n\x15INCOMPATIBLE_PROTOCOL\x10\x06\
    \x12\x11\n\rNULL_IDENTITY\x10\x07\x12\x10\n\x0cPEER_QUITING\x10\x08\x12\
    \x17\n\x13UNEXPECTED_IDENTITY\x10\t\x12\x12\n\x0eLOCAL_IDENTITY\x10\n\
    \x12\x10\n\x0cPING_TIMEOUT\x10\x0b\x12\x0f\n\x0bUSER_REASON\x10\x10\x12\
    \t\n\x05RESET\x10\x11\x12\r\n\tSYNC_FAIL\x10\x12\x12\x0e\n\nFETCH_FAIL\
    \x10\x13\x12\n\n\x06BAD_TX\x10\x14\x12\r\n\tBAD_BLOCK\x10\x15\x12\n\n\
    \x06FORKED\x10\x16\x12\x0e\n\nUNLINKABLE\x10\x17\x12\x18\n\x14INCOMPATIB\
    LE_VERSION\x10\x18\x12\x16\n\x12INCOMPATIBLE_CHAIN\x10\x19\x12\x0c\n\x08\
    TIME_OUT\x10\x20\x12\x10\n\x0cCONNECT_FAIL\x10!\x12\x1f\n\x1bTOO_MANY_PE\
    ERS_WITH_SAME_IP\x10\"\x12\x0c\n\x07UNKNOWN\x10\xff\x01BF\n\x0forg.tron.\
    protosB\x08ProtocolZ)github.com/tronprotocol/grpc-gateway/coreJ\xef\x8d\
    \x02\n\x07\x12\x05\0\0\xa4\x05\x01\n\x08\n\x01\x0c\x12\x03\0\0\x12\n\t\n\
    \x02\x03\0\x12\x03\x02\x07\"\n\t\n\x02\x03\x01\x12\x03\x03\x07\x1c\n\x08\
    \n\x01\x02\x12\x03\x05\x08\x10\n\x08\n\x01\x08\x12\x03\x08\0(\nH\n\x02\
    \x08\x01\x12\x03\x08\0(\"=Specify\x20the\x20name\x20of\x20the\x20package\
    \x20that\x20generated\x20the\x20Java\x20file\n\n\x08\n\x01\x08\x12\x03\t\
    \0)\n=\n\x02\x08\x08\x12\x03\t\0)\"2Specify\x20the\x20class\x20name\x20o\
    f\x20the\x20generated\x20Java\x20file\n\n\x08\n\x01\x08\x12\x03\n\0@\n\t\
    \n\x02\x08\x0b\x12\x03\n\0@\n\n\n\x02\x05\0\x12\x04\x0c\0\x10\x01\n\n\n\
    \x03\x05\0\x01\x12\x03\x0c\x05\x10\n\x0b\n\x04\x05\0\x02\0\x12\x03\r\x02\
    \r\n\x0c\n\x05\x05\0\x02\0\x01\x12\x03\r\x02\x08\n\x0c\n\x05\x05\0\x02\0\
    \x02\x12\x03\r\x0b\x0c\n\x0b\n\x04\x05\0\x02\x01\x12\x03\x0e\x02\x11\n\
    \x0c\n\x05\x05\0\x02\x01\x01\x12\x03\x0e\x02\x0c\n\x0c\n\x05\x05\0\x02\
    \x01\x02\x12\x03\x0e\x0f\x10\n\x0b\n\x04\x05\0\x02\x02\x12\x03\x0f\x02\
    \x0f\n\x0c\n\x05\x05\0\x02\x02\x01\x12\x03\x0f\x02\n\n\x0c\n\x05\x05\0\
    \x02\x02\x02\x12\x03\x0f\r\x0e\nf\n\x02\x04\0\x12\x04\x13\0\x16\x01\x1aZ\
    \x20AccountId,\x20(name,\x20address)\x20use\x20name,\x20(null,\x20addres\
    s)\x20use\x20address,\x20(name,\x20null)\x20use\x20name,\n\n\n\n\x03\x04\
    \0\x01\x12\x03\x13\x08\x11\n\x0b\n\x04\x04\0\x02\0\x12\x03\x14\x02\x11\n\
    \r\n\x05\x04\0\x02\0\x04\x12\x04\x14\x02\x13\x13\n\x0c\n\x05\x04\0\x02\0\
    \x05\x12\x03\x14\x02\x07\n\x0c\n\x05\x04\0\x02\0\x01\x12\x03\x14\x08\x0c\
    \n\x0c\n\x05\x04\0\x02\0\x03\x12\x03\x14\x0f\x10\n\x0b\n\x04\x04\0\x02\
    \x01\x12\x03\x15\x02\x14\n\r\n\x05\x04\0\x02\x01\x04\x12\x04\x15\x02\x14\
    \x11\n\x0c\n\x05\x04\0\x02\x01\x05\x12\x03\x15\x02\x07\n\x0c\n\x05\x04\0\
    \x02\x01\x01\x12\x03\x15\x08\x0f\n\x0c\n\x05\x04\0\x02\x01\x03\x12\x03\
    \x15\x12\x13\n\x1a\n\x02\x04\x01\x12\x04\x19\0\x1e\x01\x1a\x0e\x20vote\
    \x20message\n\n\n\n\x03\x04\x01\x01\x12\x03\x19\x08\x0c\n$\n\x04\x04\x01\
    \x02\0\x12\x03\x1b\x02\x19\x1a\x17\x20the\x20super\x20rep\x20address\n\n\
    \r\n\x05\x04\x01\x02\0\x04\x12\x04\x1b\x02\x19\x0e\n\x0c\n\x05\x04\x01\
    \x02\0\x05\x12\x03\x1b\x02\x07\n\x0c\n\x05\x04\x01\x02\0\x01\x12\x03\x1b\
    \x08\x14\n\x0c\n\x05\x04\x01\x02\0\x03\x12\x03\x1b\x17\x18\n.\n\x04\x04\
    \x01\x02\x01\x12\x03\x1d\x02\x17\x1a!\x20the\x20vote\x20num\x20to\x20thi\
    s\x20super\x20rep.\n\n\r\n\x05\x04\x01\x02\x01\x04\x12\x04\x1d\x02\x1b\
    \x19\n\x0c\n\x05\x04\x01\x02\x01\x05\x12\x03\x1d\x02\x07\n\x0c\n\x05\x04\
    \x01\x02\x01\x01\x12\x03\x1d\x08\x12\n\x0c\n\x05\x04\x01\x02\x01\x03\x12\
    \x03\x1d\x15\x16\n\x16\n\x02\x04\x02\x12\x04!\0/\x01\x1a\n\x20Proposal\n\
    \n\n\n\x03\x04\x02\x01\x12\x03!\x08\x10\n\x0b\n\x04\x04\x02\x02\0\x12\
    \x03\"\x02\x18\n\r\n\x05\x04\x02\x02\0\x04\x12\x04\"\x02!\x12\n\x0c\n\
    \x05\x04\x02\x02\0\x05\x12\x03\"\x02\x07\n\x0c\n\x05\x04\x02\x02\0\x01\
    \x12\x03\"\x08\x13\n\x0c\n\x05\x04\x02\x02\0\x03\x12\x03\"\x16\x17\n\x0b\
    \n\x04\x04\x02\x02\x01\x12\x03#\x02\x1d\n\r\n\x05\x04\x02\x02\x01\x04\
    \x12\x04#\x02\"\x18\n\x0c\n\x05\x04\x02\x02\x01\x05\x12\x03#\x02\x07\n\
    \x0c\n\x05\x04\x02\x02\x01\x01\x12\x03#\x08\x18\n\x0c\n\x05\x04\x02\x02\
    \x01\x03\x12\x03#\x1b\x1c\n\x0b\n\x04\x04\x02\x02\x02\x12\x03$\x02#\n\r\
    \n\x05\x04\x02\x02\x02\x04\x12\x04$\x02#\x1d\n\x0c\n\x05\x04\x02\x02\x02\
    \x06\x12\x03$\x02\x13\n\x0c\n\x05\x04\x02\x02\x02\x01\x12\x03$\x14\x1e\n\
    \x0c\n\x05\x04\x02\x02\x02\x03\x12\x03$!\"\n\x0b\n\x04\x04\x02\x02\x03\
    \x12\x03%\x02\x1c\n\r\n\x05\x04\x02\x02\x03\x04\x12\x04%\x02$#\n\x0c\n\
    \x05\x04\x02\x02\x03\x05\x12\x03%\x02\x07\n\x0c\n\x05\x04\x02\x02\x03\
    \x01\x12\x03%\x08\x17\n\x0c\n\x05\x04\x02\x02\x03\x03\x12\x03%\x1a\x1b\n\
    \x0b\n\x04\x04\x02\x02\x04\x12\x03&\x02\x18\n\r\n\x05\x04\x02\x02\x04\
    \x04\x12\x04&\x02%\x1c\n\x0c\n\x05\x04\x02\x02\x04\x05\x12\x03&\x02\x07\
    \n\x0c\n\x05\x04\x02\x02\x04\x01\x12\x03&\x08\x13\n\x0c\n\x05\x04\x02\
    \x02\x04\x03\x12\x03&\x16\x17\n\x0b\n\x04\x04\x02\x02\x05\x12\x03'\x02\
    \x1f\n\x0c\n\x05\x04\x02\x02\x05\x04\x12\x03'\x02\n\n\x0c\n\x05\x04\x02\
    \x02\x05\x05\x12\x03'\x0b\x10\n\x0c\n\x05\x04\x02\x02\x05\x01\x12\x03'\
    \x11\x1a\n\x0c\n\x05\x04\x02\x02\x05\x03\x12\x03'\x1d\x1e\n\x0c\n\x04\
    \x04\x02\x04\0\x12\x04(\x02-\x03\n\x0c\n\x05\x04\x02\x04\0\x01\x12\x03(\
    \x07\x0c\n\r\n\x06\x04\x02\x04\0\x02\0\x12\x03)\x04\x10\n\x0e\n\x07\x04\
    \x02\x04\0\x02\0\x01\x12\x03)\x04\x0b\n\x0e\n\x07\x04\x02\x04\0\x02\0\
    \x02\x12\x03)\x0e\x0f\n\r\n\x06\x04\x02\x04\0\x02\x01\x12\x03*\x04\x14\n\
    \x0e\n\x07\x04\x02\x04\0\x02\x01\x01\x12\x03*\x04\x0f\n\x0e\n\x07\x04\
    \x02\x04\0\x02\x01\x02\x12\x03*\x12\x13\n\r\n\x06\x04\x02\x04\0\x02\x02\
    \x12\x03+\x04\x11\n\x0e\n\x07\x04\x02\x04\0\x02\x02\x01\x12\x03+\x04\x0c\
    \n\x0e\n\x07\x04\x02\x04\0\x02\x02\x02\x12\x03+\x0f\x10\n\r\n\x06\x04\
    \x02\x04\0\x02\x03\x12\x03,\x04\x11\n\x0e\n\x07\x04\x02\x04\0\x02\x03\
    \x01\x12\x03,\x04\x0c\n\x0e\n\x07\x04\x02\x04\0\x02\x03\x02\x12\x03,\x0f\
    \x10\n\x0b\n\x04\x04\x02\x02\x06\x12\x03.\x02\x12\n\r\n\x05\x04\x02\x02\
    \x06\x04\x12\x04.\x02-\x03\n\x0c\n\x05\x04\x02\x02\x06\x06\x12\x03.\x02\
    \x07\n\x0c\n\x05\x04\x02\x02\x06\x01\x12\x03.\x08\r\n\x0c\n\x05\x04\x02\
    \x02\x06\x03\x12\x03.\x10\x11\n\x16\n\x02\x04\x03\x12\x042\0:\x01\x1a\n\
    \x20Exchange\n\n\n\n\x03\x04\x03\x01\x12\x032\x08\x10\n\x0b\n\x04\x04\
    \x03\x02\0\x12\x033\x02\x18\n\r\n\x05\x04\x03\x02\0\x04\x12\x043\x022\
    \x12\n\x0c\n\x05\x04\x03\x02\0\x05\x12\x033\x02\x07\n\x0c\n\x05\x04\x03\
    \x02\0\x01\x12\x033\x08\x13\n\x0c\n\x05\x04\x03\x02\0\x03\x12\x033\x16\
    \x17\n\x0b\n\x04\x04\x03\x02\x01\x12\x034\x02\x1c\n\r\n\x05\x04\x03\x02\
    \x01\x04\x12\x044\x023\x18\n\x0c\n\x05\x04\x03\x02\x01\x05\x12\x034\x02\
    \x07\n\x0c\n\x05\x04\x03\x02\x01\x01\x12\x034\x08\x17\n\x0c\n\x05\x04\
    \x03\x02\x01\x03\x12\x034\x1a\x1b\n\x0b\n\x04\x04\x03\x02\x02\x12\x035\
    \x02\x18\n\r\n\x05\x04\x03\x02\x02\x04\x12\x045\x024\x1c\n\x0c\n\x05\x04\
    \x03\x02\x02\x05\x12\x035\x02\x07\n\x0c\n\x05\x04\x03\x02\x02\x01\x12\
    \x035\x08\x13\n\x0c\n\x05\x04\x03\x02\x02\x03\x12\x035\x16\x17\n\x0b\n\
    \x04\x04\x03\x02\x03\x12\x036\x02\x1b\n\r\n\x05\x04\x03\x02\x03\x04\x12\
    \x046\x025\x18\n\x0c\n\x05\x04\x03\x02\x03\x05\x12\x036\x02\x07\n\x0c\n\
    \x05\x04\x03\x02\x03\x01\x12\x036\x08\x16\n\x0c\n\x05\x04\x03\x02\x03\
    \x03\x12\x036\x19\x1a\n\x0b\n\x04\x04\x03\x02\x04\x12\x037\x02\x20\n\r\n\
    \x05\x04\x03\x02\x04\x04\x12\x047\x026\x1b\n\x0c\n\x05\x04\x03\x02\x04\
    \x05\x12\x037\x02\x07\n\x0c\n\x05\x04\x03\x02\x04\x01\x12\x037\x08\x1b\n\
    \x0c\n\x05\x04\x03\x02\x04\x03\x12\x037\x1e\x1f\n\x0b\n\x04\x04\x03\x02\
    \x05\x12\x038\x02\x1c\n\r\n\x05\x04\x03\x02\x05\x04\x12\x048\x027\x20\n\
    \x0c\n\x05\x04\x03\x02\x05\x05\x12\x038\x02\x07\n\x0c\n\x05\x04\x03\x02\
    \x05\x01\x12\x038\x08\x17\n\x0c\n\x05\x04\x03\x02\x05\x03\x12\x038\x1a\
    \x1b\n\x0b\n\x04\x04\x03\x02\x06\x12\x039\x02!\n\r\n\x05\x04\x03\x02\x06\
    \x04\x12\x049\x028\x1c\n\x0c\n\x05\x04\x03\x02\x06\x05\x12\x039\x02\x07\
    \n\x0c\n\x05\x04\x03\x02\x06\x01\x12\x039\x08\x1c\n\x0c\n\x05\x04\x03\
    \x02\x06\x03\x12\x039\x1f\x20\n\n\n\x02\x04\x04\x12\x04<\0B\x01\n\n\n\
    \x03\x04\x04\x01\x12\x03<\x08\x17\n\x0b\n\x04\x04\x04\x02\0\x12\x03=\x02\
    -\n\x0c\n\x05\x04\x04\x02\0\x04\x12\x03=\x02\n\n\x0c\n\x05\x04\x04\x02\0\
    \x06\x12\x03=\x0b\x19\n\x0c\n\x05\x04\x04\x02\0\x01\x12\x03=\x1a(\n\x0c\
    \n\x05\x04\x04\x02\0\x03\x12\x03=+,\n\x0c\n\x04\x04\x04\x03\0\x12\x04>\
    \x02A\x03\n\x0c\n\x05\x04\x04\x03\0\x01\x12\x03>\n\x18\n\r\n\x06\x04\x04\
    \x03\0\x02\0\x12\x03?\x04\x13\n\x0f\n\x07\x04\x04\x03\0\x02\0\x04\x12\
    \x04?\x04>\x1a\n\x0e\n\x07\x04\x04\x03\0\x02\0\x05\x12\x03?\x04\n\n\x0e\
    \n\x07\x04\x04\x03\0\x02\0\x01\x12\x03?\x0b\x0e\n\x0e\n\x07\x04\x04\x03\
    \0\x02\0\x03\x12\x03?\x11\x12\n\r\n\x06\x04\x04\x03\0\x02\x01\x12\x03@\
    \x04\x14\n\x0f\n\x07\x04\x04\x03\0\x02\x01\x04\x12\x04@\x04?\x13\n\x0e\n\
    \x07\x04\x04\x03\0\x02\x01\x05\x12\x03@\x04\t\n\x0e\n\x07\x04\x04\x03\0\
    \x02\x01\x01\x12\x03@\n\x0f\n\x0e\n\x07\x04\x04\x03\0\x02\x01\x03\x12\
    \x03@\x12\x13\n\x16\n\x02\x04\x05\x12\x05E\0\x96\x01\x01\x1a\t\x20Accoun\
    t\x20\n\n\n\x03\x04\x05\x01\x12\x03E\x08\x0f\n\x1e\n\x04\x04\x05\x03\0\
    \x12\x04G\x02J\x03\x1a\x10\x20frozen\x20balance\x20\n\x0c\n\x05\x04\x05\
    \x03\0\x01\x12\x03G\n\x10\n'\n\x06\x04\x05\x03\0\x02\0\x12\x03H\x04\x1d\
    \"\x18\x20the\x20frozen\x20trx\x20balance\n\n\x0f\n\x07\x04\x05\x03\0\
    \x02\0\x04\x12\x04H\x04G\x12\n\x0e\n\x07\x04\x05\x03\0\x02\0\x05\x12\x03\
    H\x04\t\n\x0e\n\x07\x04\x05\x03\0\x02\0\x01\x12\x03H\n\x18\n\x0e\n\x07\
    \x04\x05\x03\0\x02\0\x03\x12\x03H\x1b\x1c\n\x20\n\x06\x04\x05\x03\0\x02\
    \x01\x12\x03I\x04\x1a\"\x11\x20the\x20expire\x20time\n\n\x0f\n\x07\x04\
    \x05\x03\0\x02\x01\x04\x12\x04I\x04H\x1d\n\x0e\n\x07\x04\x05\x03\0\x02\
    \x01\x05\x12\x03I\x04\t\n\x0e\n\x07\x04\x05\x03\0\x02\x01\x01\x12\x03I\n\
    \x15\n\x0e\n\x07\x04\x05\x03\0\x02\x01\x03\x12\x03I\x18\x19\n\x20\n\x04\
    \x04\x05\x02\0\x12\x03L\x02\x19\x1a\x13\x20account\x20nick\x20name\n\n\r\
    \n\x05\x04\x05\x02\0\x04\x12\x04L\x02J\x03\n\x0c\n\x05\x04\x05\x02\0\x05\
    \x12\x03L\x02\x07\n\x0c\n\x05\x04\x05\x02\0\x01\x12\x03L\x08\x14\n\x0c\n\
    \x05\x04\x05\x02\0\x03\x12\x03L\x17\x18\n\x0b\n\x04\x04\x05\x02\x01\x12\
    \x03M\x02\x17\n\r\n\x05\x04\x05\x02\x01\x04\x12\x04M\x02L\x19\n\x0c\n\
    \x05\x04\x05\x02\x01\x06\x12\x03M\x02\r\n\x0c\n\x05\x04\x05\x02\x01\x01\
    \x12\x03M\x0e\x12\n\x0c\n\x05\x04\x05\x02\x01\x03\x12\x03M\x15\x16\n!\n\
    \x04\x04\x05\x02\x02\x12\x03O\x02\x14\x1a\x14\x20the\x20create\x20addres\
    s\n\n\r\n\x05\x04\x05\x02\x02\x04\x12\x04O\x02M\x17\n\x0c\n\x05\x04\x05\
    \x02\x02\x05\x12\x03O\x02\x07\n\x0c\n\x05\x04\x05\x02\x02\x01\x12\x03O\
    \x08\x0f\n\x0c\n\x05\x04\x05\x02\x02\x03\x12\x03O\x12\x13\n\x1e\n\x04\
    \x04\x05\x02\x03\x12\x03Q\x02\x14\x1a\x11\x20the\x20trx\x20balance\n\n\r\
    \n\x05\x04\x05\x02\x03\x04\x12\x04Q\x02O\x14\n\x0c\n\x05\x04\x05\x02\x03\
    \x05\x12\x03Q\x02\x07\n\x0c\n\x05\x04\x05\x02\x03\x01\x12\x03Q\x08\x0f\n\
    \x0c\n\x05\x04\x05\x02\x03\x03\x12\x03Q\x12\x13\n\x18\n\x04\x04\x05\x02\
    \x04\x12\x03S\x02\x1a\x1a\x0b\x20the\x20votes\n\n\x0c\n\x05\x04\x05\x02\
    \x04\x04\x12\x03S\x02\n\n\x0c\n\x05\x04\x05\x02\x04\x06\x12\x03S\x0b\x0f\
    \n\x0c\n\x05\x04\x05\x02\x04\x01\x12\x03S\x10\x15\n\x0c\n\x05\x04\x05\
    \x02\x04\x03\x12\x03S\x18\x19\n4\n\x04\x04\x05\x02\x05\x12\x03U\x02\x1f\
    \x1a'\x20the\x20other\x20asset\x20owned\x20by\x20this\x20account\n\n\r\n\
    \x05\x04\x05\x02\x05\x04\x12\x04U\x02S\x1a\n\x0c\n\x05\x04\x05\x02\x05\
    \x06\x12\x03U\x02\x14\n\x0c\n\x05\x04\x05\x02\x05\x01\x12\x03U\x15\x1a\n\
    \x0c\n\x05\x04\x05\x02\x05\x03\x12\x03U\x1d\x1e\nE\n\x04\x04\x05\x02\x06\
    \x12\x03X\x02\"\x1a8\x20the\x20other\x20asset\x20owned\x20by\x20this\x20\
    account\xef\xbc\x8ckey\x20is\x20assetId\n\n\r\n\x05\x04\x05\x02\x06\x04\
    \x12\x04X\x02U\x1f\n\x0c\n\x05\x04\x05\x02\x06\x06\x12\x03X\x02\x14\n\
    \x0c\n\x05\x04\x05\x02\x06\x01\x12\x03X\x15\x1c\n\x0c\n\x05\x04\x05\x02\
    \x06\x03\x12\x03X\x1f!\n/\n\x04\x04\x05\x02\x07\x12\x03[\x02\x1d\x1a\"\
    \x20the\x20frozen\x20balance\x20for\x20bandwidth\n\n\x0c\n\x05\x04\x05\
    \x02\x07\x04\x12\x03[\x02\n\n\x0c\n\x05\x04\x05\x02\x07\x06\x12\x03[\x0b\
    \x11\n\x0c\n\x05\x04\x05\x02\x07\x01\x12\x03[\x12\x18\n\x0c\n\x05\x04\
    \x05\x02\x07\x03\x12\x03[\x1b\x1c\n)\n\x04\x04\x05\x02\x08\x12\x03]\x02\
    \x16\x1a\x1c\x20bandwidth,\x20get\x20from\x20frozen\n\n\r\n\x05\x04\x05\
    \x02\x08\x04\x12\x04]\x02[\x1d\n\x0c\n\x05\x04\x05\x02\x08\x05\x12\x03]\
    \x02\x07\n\x0c\n\x05\x04\x05\x02\x08\x01\x12\x03]\x08\x11\n\x0c\n\x05\
    \x04\x05\x02\x08\x03\x12\x03]\x14\x15\nG\n\x04\x04\x05\x02\t\x12\x03_\
    \x02=\x1a:Frozen\x20balance\x20provided\x20by\x20other\x20accounts\x20to\
    \x20this\x20account\n\n\r\n\x05\x04\x05\x02\t\x04\x12\x04_\x02]\x16\n\
    \x0c\n\x05\x04\x05\x02\t\x05\x12\x03_\x02\x07\n\x0c\n\x05\x04\x05\x02\t\
    \x01\x12\x03_\x087\n\x0c\n\x05\x04\x05\x02\t\x03\x12\x03_:<\n;\n\x04\x04\
    \x05\x02\n\x12\x03a\x024\x1a.Freeze\x20and\x20provide\x20balances\x20to\
    \x20other\x20accounts\n\n\r\n\x05\x04\x05\x02\n\x04\x12\x04a\x02_=\n\x0c\
    \n\x05\x04\x05\x02\n\x05\x12\x03a\x02\x07\n\x0c\n\x05\x04\x05\x02\n\x01\
    \x12\x03a\x08.\n\x0c\n\x05\x04\x05\x02\n\x03\x12\x03a13\n'\n\x04\x04\x05\
    \x02\x0b\x12\x03d\x02\x1b\x1a\x1a\x20this\x20account\x20create\x20time\n\
    \n\r\n\x05\x04\x05\x02\x0b\x04\x12\x04d\x02a4\n\x0c\n\x05\x04\x05\x02\
    \x0b\x05\x12\x03d\x02\x07\n\x0c\n\x05\x04\x05\x02\x0b\x01\x12\x03d\x08\
    \x13\n\x0c\n\x05\x04\x05\x02\x0b\x03\x12\x03d\x16\x1a\nb\n\x04\x04\x05\
    \x02\x0c\x12\x03f\x02\"\x1aU\x20this\x20last\x20operation\x20time,\x20in\
    cluding\x20transfer,\x20voting\x20and\x20so\x20on.\x20//FIXME\x20fix\x20\
    grammar\n\n\r\n\x05\x04\x05\x02\x0c\x04\x12\x04f\x02d\x1b\n\x0c\n\x05\
    \x04\x05\x02\x0c\x05\x12\x03f\x02\x07\n\x0c\n\x05\x04\x05\x02\x0c\x01\
    \x12\x03f\x08\x1c\n\x0c\n\x05\x04\x05\x02\x0c\x03\x12\x03f\x1f!\n0\n\x04\
    \x04\x05\x02\r\x12\x03h\x02\x19\x1a#\x20witness\x20block\x20producing\
    \x20allowance\n\n\r\n\x05\x04\x05\x02\r\x04\x12\x04h\x02f\"\n\x0c\n\x05\
    \x04\x05\x02\r\x05\x12\x03h\x02\x07\n\x0c\n\x05\x04\x05\x02\r\x01\x12\
    \x03h\x08\x11\n\x0c\n\x05\x04\x05\x02\r\x03\x12\x03h\x14\x18\n!\n\x04\
    \x04\x05\x02\x0e\x12\x03j\x02$\x1a\x14\x20last\x20withdraw\x20time\n\n\r\
    \n\x05\x04\x05\x02\x0e\x04\x12\x04j\x02h\x19\n\x0c\n\x05\x04\x05\x02\x0e\
    \x05\x12\x03j\x02\x07\n\x0c\n\x05\x04\x05\x02\x0e\x01\x12\x03j\x08\x1c\n\
    \x0c\n\x05\x04\x05\x02\x0e\x03\x12\x03j\x1f#\n\x1e\n\x04\x04\x05\x02\x0f\
    \x12\x03l\x02\x12\x1a\x11\x20not\x20used\x20so\x20far\n\n\r\n\x05\x04\
    \x05\x02\x0f\x04\x12\x04l\x02j$\n\x0c\n\x05\x04\x05\x02\x0f\x05\x12\x03l\
    \x02\x07\n\x0c\n\x05\x04\x05\x02\x0f\x01\x12\x03l\x08\x0c\n\x0c\n\x05\
    \x04\x05\x02\x0f\x03\x12\x03l\x0f\x11\n\x0b\n\x04\x04\x05\x02\x10\x12\
    \x03m\x02\x17\n\r\n\x05\x04\x05\x02\x10\x04\x12\x04m\x02l\x12\n\x0c\n\
    \x05\x04\x05\x02\x10\x05\x12\x03m\x02\x06\n\x0c\n\x05\x04\x05\x02\x10\
    \x01\x12\x03m\x07\x11\n\x0c\n\x05\x04\x05\x02\x10\x03\x12\x03m\x14\x16\n\
    \x0b\n\x04\x04\x05\x02\x11\x12\x03n\x02\x19\n\r\n\x05\x04\x05\x02\x11\
    \x04\x12\x04n\x02m\x17\n\x0c\n\x05\x04\x05\x02\x11\x05\x12\x03n\x02\x06\
    \n\x0c\n\x05\x04\x05\x02\x11\x01\x12\x03n\x07\x13\n\x0c\n\x05\x04\x05\
    \x02\x11\x03\x12\x03n\x16\x18\n-\n\x04\x04\x05\x02\x12\x12\x03p\x02%\x1a\
    \x20\x20frozen\x20asset(for\x20asset\x20issuer)\n\n\x0c\n\x05\x04\x05\
    \x02\x12\x04\x12\x03p\x02\n\n\x0c\n\x05\x04\x05\x02\x12\x06\x12\x03p\x0b\
    \x11\n\x0c\n\x05\x04\x05\x02\x12\x01\x12\x03p\x12\x1f\n\x0c\n\x05\x04\
    \x05\x02\x12\x03\x12\x03p\"$\n\x20\n\x04\x04\x05\x02\x13\x12\x03r\x02\
    \x1f\x1a\x13\x20asset_issued_name\n\n\r\n\x05\x04\x05\x02\x13\x04\x12\
    \x04r\x02p%\n\x0c\n\x05\x04\x05\x02\x13\x05\x12\x03r\x02\x07\n\x0c\n\x05\
    \x04\x05\x02\x13\x01\x12\x03r\x08\x19\n\x0c\n\x05\x04\x05\x02\x13\x03\
    \x12\x03r\x1c\x1e\n\x0b\n\x04\x04\x05\x02\x14\x12\x03s\x02\x1d\n\r\n\x05\
    \x04\x05\x02\x14\x04\x12\x04s\x02r\x1f\n\x0c\n\x05\x04\x05\x02\x14\x05\
    \x12\x03s\x02\x07\n\x0c\n\x05\x04\x05\x02\x14\x01\x12\x03s\x08\x17\n\x0c\
    \n\x05\x04\x05\x02\x14\x03\x12\x03s\x1a\x1c\n\x0b\n\x04\x04\x05\x02\x15\
    \x12\x03t\x026\n\r\n\x05\x04\x05\x02\x15\x04\x12\x04t\x02s\x1d\n\x0c\n\
    \x05\x04\x05\x02\x15\x06\x12\x03t\x02\x14\n\x0c\n\x05\x04\x05\x02\x15\
    \x01\x12\x03t\x150\n\x0c\n\x05\x04\x05\x02\x15\x03\x12\x03t35\n\x0b\n\
    \x04\x04\x05\x02\x16\x12\x03u\x028\n\r\n\x05\x04\x05\x02\x16\x04\x12\x04\
    u\x02t6\n\x0c\n\x05\x04\x05\x02\x16\x06\x12\x03u\x02\x14\n\x0c\n\x05\x04\
    \x05\x02\x16\x01\x12\x03u\x152\n\x0c\n\x05\x04\x05\x02\x16\x03\x12\x03u5\
    7\n\x0b\n\x04\x04\x05\x02\x17\x12\x03v\x02\x1c\n\r\n\x05\x04\x05\x02\x17\
    \x04\x12\x04v\x02u8\n\x0c\n\x05\x04\x05\x02\x17\x05\x12\x03v\x02\x07\n\
    \x0c\n\x05\x04\x05\x02\x17\x01\x12\x03v\x08\x16\n\x0c\n\x05\x04\x05\x02\
    \x17\x03\x12\x03v\x19\x1b\n\x0b\n\x04\x04\x05\x02\x18\x12\x03w\x02/\n\r\
    \n\x05\x04\x05\x02\x18\x04\x12\x04w\x02v\x1c\n\x0c\n\x05\x04\x05\x02\x18\
    \x06\x12\x03w\x02\x14\n\x0c\n\x05\x04\x05\x02\x18\x01\x12\x03w\x15)\n\
    \x0c\n\x05\x04\x05\x02\x18\x03\x12\x03w,.\n\x0b\n\x04\x04\x05\x02\x19\
    \x12\x03x\x021\n\r\n\x05\x04\x05\x02\x19\x04\x12\x04x\x02w/\n\x0c\n\x05\
    \x04\x05\x02\x19\x06\x12\x03x\x02\x14\n\x0c\n\x05\x04\x05\x02\x19\x01\
    \x12\x03x\x15+\n\x0c\n\x05\x04\x05\x02\x19\x03\x12\x03x.0\n\x0b\n\x04\
    \x04\x05\x02\x1a\x12\x03y\x02!\n\r\n\x05\x04\x05\x02\x1a\x04\x12\x04y\
    \x02x1\n\x0c\n\x05\x04\x05\x02\x1a\x05\x12\x03y\x02\x07\n\x0c\n\x05\x04\
    \x05\x02\x1a\x01\x12\x03y\x08\x1b\n\x0c\n\x05\x04\x05\x02\x1a\x03\x12\
    \x03y\x1e\x20\n\x0b\n\x04\x04\x05\x02\x1b\x12\x03z\x02&\n\r\n\x05\x04\
    \x05\x02\x1b\x04\x12\x04z\x02y!\n\x0c\n\x05\x04\x05\x02\x1b\x05\x12\x03z\
    \x02\x07\n\x0c\n\x05\x04\x05\x02\x1b\x01\x12\x03z\x08\x20\n\x0c\n\x05\
    \x04\x05\x02\x1b\x03\x12\x03z#%\n=\n\x04\x04\x05\x02\x1c\x12\x03}\x02\
    \x18\x1a0\x20the\x20identity\x20of\x20this\x20account,\x20case\x20insens\
    itive\n\n\r\n\x05\x04\x05\x02\x1c\x04\x12\x04}\x02z&\n\x0c\n\x05\x04\x05\
    \x02\x1c\x05\x12\x03}\x02\x07\n\x0c\n\x05\x04\x05\x02\x1c\x01\x12\x03}\
    \x08\x12\n\x0c\n\x05\x04\x05\x02\x1c\x03\x12\x03}\x15\x17\n\r\n\x04\x04\
    \x05\x03\x07\x12\x05\x7f\x02\x90\x01\x03\n\x0c\n\x05\x04\x05\x03\x07\x01\
    \x12\x03\x7f\n\x19\n2\n\x06\x04\x05\x03\x07\x02\0\x12\x04\x81\x01\x04\
    \x1b\x1a\"\x20energy\x20resource,\x20get\x20from\x20frozen\n\n\x10\n\x07\
    \x04\x05\x03\x07\x02\0\x04\x12\x05\x81\x01\x04\x7f\x1b\n\x0f\n\x07\x04\
    \x05\x03\x07\x02\0\x05\x12\x04\x81\x01\x04\t\n\x0f\n\x07\x04\x05\x03\x07\
    \x02\0\x01\x12\x04\x81\x01\n\x16\n\x0f\n\x07\x04\x05\x03\x07\x02\0\x03\
    \x12\x04\x81\x01\x19\x1a\n/\n\x06\x04\x05\x03\x07\x02\x01\x12\x04\x83\
    \x01\x04)\x1a\x1f\x20the\x20frozen\x20balance\x20for\x20energy\n\n\x11\n\
    \x07\x04\x05\x03\x07\x02\x01\x04\x12\x06\x83\x01\x04\x81\x01\x1b\n\x0f\n\
    \x07\x04\x05\x03\x07\x02\x01\x06\x12\x04\x83\x01\x04\n\n\x0f\n\x07\x04\
    \x05\x03\x07\x02\x01\x01\x12\x04\x83\x01\x0b$\n\x0f\n\x07\x04\x05\x03\
    \x07\x02\x01\x03\x12\x04\x83\x01'(\n\x0e\n\x06\x04\x05\x03\x07\x02\x02\
    \x12\x04\x84\x01\x04-\n\x11\n\x07\x04\x05\x03\x07\x02\x02\x04\x12\x06\
    \x84\x01\x04\x83\x01)\n\x0f\n\x07\x04\x05\x03\x07\x02\x02\x05\x12\x04\
    \x84\x01\x04\t\n\x0f\n\x07\x04\x05\x03\x07\x02\x02\x01\x12\x04\x84\x01\n\
    (\n\x0f\n\x07\x04\x05\x03\x07\x02\x02\x03\x12\x04\x84\x01+,\nJ\n\x06\x04\
    \x05\x03\x07\x02\x03\x12\x04\x87\x01\x04;\x1a:Frozen\x20balance\x20provi\
    ded\x20by\x20other\x20accounts\x20to\x20this\x20account\n\n\x11\n\x07\
    \x04\x05\x03\x07\x02\x03\x04\x12\x06\x87\x01\x04\x84\x01-\n\x0f\n\x07\
    \x04\x05\x03\x07\x02\x03\x05\x12\x04\x87\x01\x04\t\n\x0f\n\x07\x04\x05\
    \x03\x07\x02\x03\x01\x12\x04\x87\x01\n6\n\x0f\n\x07\x04\x05\x03\x07\x02\
    \x03\x03\x12\x04\x87\x019:\n;\n\x06\x04\x05\x03\x07\x02\x04\x12\x04\x89\
    \x01\x042\x1a+Frozen\x20balances\x20provided\x20to\x20other\x20accounts\
    \n\n\x11\n\x07\x04\x05\x03\x07\x02\x04\x04\x12\x06\x89\x01\x04\x87\x01;\
    \n\x0f\n\x07\x04\x05\x03\x07\x02\x04\x05\x12\x04\x89\x01\x04\t\n\x0f\n\
    \x07\x04\x05\x03\x07\x02\x04\x01\x12\x04\x89\x01\n-\n\x0f\n\x07\x04\x05\
    \x03\x07\x02\x04\x03\x12\x04\x89\x0101\n3\n\x06\x04\x05\x03\x07\x02\x05\
    \x12\x04\x8c\x01\x04\x1c\x1a#\x20storage\x20resource,\x20get\x20from\x20\
    market\n\n\x11\n\x07\x04\x05\x03\x07\x02\x05\x04\x12\x06\x8c\x01\x04\x89\
    \x012\n\x0f\n\x07\x04\x05\x03\x07\x02\x05\x05\x12\x04\x8c\x01\x04\t\n\
    \x0f\n\x07\x04\x05\x03\x07\x02\x05\x01\x12\x04\x8c\x01\n\x17\n\x0f\n\x07\
    \x04\x05\x03\x07\x02\x05\x03\x12\x04\x8c\x01\x1a\x1b\n\x0e\n\x06\x04\x05\
    \x03\x07\x02\x06\x12\x04\x8d\x01\x04\x1c\n\x11\n\x07\x04\x05\x03\x07\x02\
    \x06\x04\x12\x06\x8d\x01\x04\x8c\x01\x1c\n\x0f\n\x07\x04\x05\x03\x07\x02\
    \x06\x05\x12\x04\x8d\x01\x04\t\n\x0f\n\x07\x04\x05\x03\x07\x02\x06\x01\
    \x12\x04\x8d\x01\n\x17\n\x0f\n\x07\x04\x05\x03\x07\x02\x06\x03\x12\x04\
    \x8d\x01\x1a\x1b\n\x0e\n\x06\x04\x05\x03\x07\x02\x07\x12\x04\x8e\x01\x04\
    +\n\x11\n\x07\x04\x05\x03\x07\x02\x07\x04\x12\x06\x8e\x01\x04\x8d\x01\
    \x1c\n\x0f\n\x07\x04\x05\x03\x07\x02\x07\x05\x12\x04\x8e\x01\x04\t\n\x0f\
    \n\x07\x04\x05\x03\x07\x02\x07\x01\x12\x04\x8e\x01\n&\n\x0f\n\x07\x04\
    \x05\x03\x07\x02\x07\x03\x12\x04\x8e\x01)*\n\x0c\n\x04\x04\x05\x02\x1d\
    \x12\x04\x91\x01\x02(\n\x0f\n\x05\x04\x05\x02\x1d\x04\x12\x06\x91\x01\
    \x02\x90\x01\x03\n\r\n\x05\x04\x05\x02\x1d\x06\x12\x04\x91\x01\x02\x11\n\
    \r\n\x05\x04\x05\x02\x1d\x01\x12\x04\x91\x01\x12\"\n\r\n\x05\x04\x05\x02\
    \x1d\x03\x12\x04\x91\x01%'\n\x0c\n\x04\x04\x05\x02\x1e\x12\x04\x92\x01\
    \x02\x16\n\x0f\n\x05\x04\x05\x02\x1e\x04\x12\x06\x92\x01\x02\x91\x01(\n\
    \r\n\x05\x04\x05\x02\x1e\x05\x12\x04\x92\x01\x02\x07\n\r\n\x05\x04\x05\
    \x02\x1e\x01\x12\x04\x92\x01\x08\x10\n\r\n\x05\x04\x05\x02\x1e\x03\x12\
    \x04\x92\x01\x13\x15\n\x0c\n\x04\x04\x05\x02\x1f\x12\x04\x93\x01\x02#\n\
    \x0f\n\x05\x04\x05\x02\x1f\x04\x12\x06\x93\x01\x02\x92\x01\x16\n\r\n\x05\
    \x04\x05\x02\x1f\x06\x12\x04\x93\x01\x02\x0c\n\r\n\x05\x04\x05\x02\x1f\
    \x01\x12\x04\x93\x01\r\x1d\n\r\n\x05\x04\x05\x02\x1f\x03\x12\x04\x93\x01\
    \x20\"\n\x0c\n\x04\x04\x05\x02\x20\x12\x04\x94\x01\x02%\n\x0f\n\x05\x04\
    \x05\x02\x20\x04\x12\x06\x94\x01\x02\x93\x01#\n\r\n\x05\x04\x05\x02\x20\
    \x06\x12\x04\x94\x01\x02\x0c\n\r\n\x05\x04\x05\x02\x20\x01\x12\x04\x94\
    \x01\r\x1f\n\r\n\x05\x04\x05\x02\x20\x03\x12\x04\x94\x01\"$\n\x0c\n\x04\
    \x04\x05\x02!\x12\x04\x95\x01\x02-\n\r\n\x05\x04\x05\x02!\x04\x12\x04\
    \x95\x01\x02\n\n\r\n\x05\x04\x05\x02!\x06\x12\x04\x95\x01\x0b\x15\n\r\n\
    \x05\x04\x05\x02!\x01\x12\x04\x95\x01\x16'\n\r\n\x05\x04\x05\x02!\x03\
    \x12\x04\x95\x01*,\n\x0c\n\x02\x04\x06\x12\x06\x99\x01\0\x9c\x01\x01\n\
    \x0b\n\x03\x04\x06\x01\x12\x04\x99\x01\x08\x0b\n\x0c\n\x04\x04\x06\x02\0\
    \x12\x04\x9a\x01\x02\x14\n\x0f\n\x05\x04\x06\x02\0\x04\x12\x06\x9a\x01\
    \x02\x99\x01\r\n\r\n\x05\x04\x06\x02\0\x05\x12\x04\x9a\x01\x02\x07\n\r\n\
    \x05\x04\x06\x02\0\x01\x12\x04\x9a\x01\x08\x0f\n\r\n\x05\x04\x06\x02\0\
    \x03\x12\x04\x9a\x01\x12\x13\n\x0c\n\x04\x04\x06\x02\x01\x12\x04\x9b\x01\
    \x02\x13\n\x0f\n\x05\x04\x06\x02\x01\x04\x12\x06\x9b\x01\x02\x9a\x01\x14\
    \n\r\n\x05\x04\x06\x02\x01\x05\x12\x04\x9b\x01\x02\x07\n\r\n\x05\x04\x06\
    \x02\x01\x01\x12\x04\x9b\x01\x08\x0e\n\r\n\x05\x04\x06\x02\x01\x03\x12\
    \x04\x9b\x01\x11\x12\n\x0c\n\x02\x04\x07\x12\x06\x9e\x01\0\xa5\x01\x01\n\
    \x0b\n\x03\x04\x07\x01\x12\x04\x9e\x01\x08\x19\n\x0c\n\x04\x04\x07\x02\0\
    \x12\x04\x9f\x01\x02\x11\n\x0f\n\x05\x04\x07\x02\0\x04\x12\x06\x9f\x01\
    \x02\x9e\x01\x1b\n\r\n\x05\x04\x07\x02\0\x05\x12\x04\x9f\x01\x02\x07\n\r\
    \n\x05\x04\x07\x02\0\x01\x12\x04\x9f\x01\x08\x0c\n\r\n\x05\x04\x07\x02\0\
    \x03\x12\x04\x9f\x01\x0f\x10\n\x0c\n\x04\x04\x07\x02\x01\x12\x04\xa0\x01\
    \x02\x0f\n\x0f\n\x05\x04\x07\x02\x01\x04\x12\x06\xa0\x01\x02\x9f\x01\x11\
    \n\r\n\x05\x04\x07\x02\x01\x05\x12\x04\xa0\x01\x02\x07\n\r\n\x05\x04\x07\
    \x02\x01\x01\x12\x04\xa0\x01\x08\n\n\r\n\x05\x04\x07\x02\x01\x03\x12\x04\
    \xa0\x01\r\x0e\n\x0c\n\x04\x04\x07\x02\x02\x12\x04\xa1\x01\x02)\n\x0f\n\
    \x05\x04\x07\x02\x02\x04\x12\x06\xa1\x01\x02\xa0\x01\x0f\n\r\n\x05\x04\
    \x07\x02\x02\x05\x12\x04\xa1\x01\x02\x07\n\r\n\x05\x04\x07\x02\x02\x01\
    \x12\x04\xa1\x01\x08$\n\r\n\x05\x04\x07\x02\x02\x03\x12\x04\xa1\x01'(\n\
    \x0c\n\x04\x04\x07\x02\x03\x12\x04\xa2\x01\x02&\n\x0f\n\x05\x04\x07\x02\
    \x03\x04\x12\x06\xa2\x01\x02\xa1\x01)\n\r\n\x05\x04\x07\x02\x03\x05\x12\
    \x04\xa2\x01\x02\x07\n\r\n\x05\x04\x07\x02\x03\x01\x12\x04\xa2\x01\x08!\
    \n\r\n\x05\x04\x07\x02\x03\x03\x12\x04\xa2\x01$%\n\x0c\n\x04\x04\x07\x02\
    \x04\x12\x04\xa3\x01\x02&\n\x0f\n\x05\x04\x07\x02\x04\x04\x12\x06\xa3\
    \x01\x02\xa2\x01&\n\r\n\x05\x04\x07\x02\x04\x05\x12\x04\xa3\x01\x02\x07\
    \n\r\n\x05\x04\x07\x02\x04\x01\x12\x04\xa3\x01\x08!\n\r\n\x05\x04\x07\
    \x02\x04\x03\x12\x04\xa3\x01$%\n\x0c\n\x04\x04\x07\x02\x05\x12\x04\xa4\
    \x01\x02#\n\x0f\n\x05\x04\x07\x02\x05\x04\x12\x06\xa4\x01\x02\xa3\x01&\n\
    \r\n\x05\x04\x07\x02\x05\x05\x12\x04\xa4\x01\x02\x07\n\r\n\x05\x04\x07\
    \x02\x05\x01\x12\x04\xa4\x01\x08\x1e\n\r\n\x05\x04\x07\x02\x05\x03\x12\
    \x04\xa4\x01!\"\n\x0c\n\x02\x04\x08\x12\x06\xa7\x01\0\xaa\x01\x01\n\x0b\
    \n\x03\x04\x08\x01\x12\x04\xa7\x01\x08\x11\n\x0c\n\x04\x04\x08\x02\0\x12\
    \x04\xa8\x01\x02\x18\n\x0f\n\x05\x04\x08\x02\0\x04\x12\x06\xa8\x01\x02\
    \xa7\x01\x13\n\r\n\x05\x04\x08\x02\0\x06\x12\x04\xa8\x01\x02\x0b\n\r\n\
    \x05\x04\x08\x02\0\x01\x12\x04\xa8\x01\x0c\x13\n\r\n\x05\x04\x08\x02\0\
    \x03\x12\x04\xa8\x01\x16\x17\n\x0c\n\x04\x04\x08\x02\x01\x12\x04\xa9\x01\
    \x02\x1c\n\x0f\n\x05\x04\x08\x02\x01\x04\x12\x06\xa9\x01\x02\xa8\x01\x18\
    \n\r\n\x05\x04\x08\x02\x01\x05\x12\x04\xa9\x01\x02\x07\n\r\n\x05\x04\x08\
    \x02\x01\x01\x12\x04\xa9\x01\x08\x17\n\r\n\x05\x04\x08\x02\x01\x03\x12\
    \x04\xa9\x01\x1a\x1b\n\x0c\n\x02\x04\t\x12\x06\xac\x01\0\xb9\x01\x01\n\
    \x0b\n\x03\x04\t\x01\x12\x04\xac\x01\x08\x12\n\x0e\n\x04\x04\t\x04\0\x12\
    \x06\xad\x01\x02\xb1\x01\x03\n\r\n\x05\x04\t\x04\0\x01\x12\x04\xad\x01\
    \x07\x15\n\x0e\n\x06\x04\t\x04\0\x02\0\x12\x04\xae\x01\x04\x0e\n\x0f\n\
    \x07\x04\t\x04\0\x02\0\x01\x12\x04\xae\x01\x04\t\n\x0f\n\x07\x04\t\x04\0\
    \x02\0\x02\x12\x04\xae\x01\x0c\r\n\x0e\n\x06\x04\t\x04\0\x02\x01\x12\x04\
    \xaf\x01\x04\x10\n\x0f\n\x07\x04\t\x04\0\x02\x01\x01\x12\x04\xaf\x01\x04\
    \x0b\n\x0f\n\x07\x04\t\x04\0\x02\x01\x02\x12\x04\xaf\x01\x0e\x0f\n\x0e\n\
    \x06\x04\t\x04\0\x02\x02\x12\x04\xb0\x01\x04\x0f\n\x0f\n\x07\x04\t\x04\0\
    \x02\x02\x01\x12\x04\xb0\x01\x04\n\n\x0f\n\x07\x04\t\x04\0\x02\x02\x02\
    \x12\x04\xb0\x01\r\x0e\n\x0c\n\x04\x04\t\x02\0\x12\x04\xb2\x01\x02\x1a\n\
    \x0f\n\x05\x04\t\x02\0\x04\x12\x06\xb2\x01\x02\xb1\x01\x03\n\r\n\x05\x04\
    \t\x02\0\x06\x12\x04\xb2\x01\x02\x10\n\r\n\x05\x04\t\x02\0\x01\x12\x04\
    \xb2\x01\x11\x15\n\r\n\x05\x04\t\x02\0\x03\x12\x04\xb2\x01\x18\x19\n=\n\
    \x04\x04\t\x02\x01\x12\x04\xb3\x01\x02\x0f\"/Owner\x20id=0,\x20Witness\
    \x20id=1,\x20Active\x20id\x20start\x20by\x202\n\n\x0f\n\x05\x04\t\x02\
    \x01\x04\x12\x06\xb3\x01\x02\xb2\x01\x1a\n\r\n\x05\x04\t\x02\x01\x05\x12\
    \x04\xb3\x01\x02\x07\n\r\n\x05\x04\t\x02\x01\x01\x12\x04\xb3\x01\x08\n\n\
    \r\n\x05\x04\t\x02\x01\x03\x12\x04\xb3\x01\r\x0e\n\x0c\n\x04\x04\t\x02\
    \x02\x12\x04\xb4\x01\x02\x1d\n\x0f\n\x05\x04\t\x02\x02\x04\x12\x06\xb4\
    \x01\x02\xb3\x01\x0f\n\r\n\x05\x04\t\x02\x02\x05\x12\x04\xb4\x01\x02\x08\
    \n\r\n\x05\x04\t\x02\x02\x01\x12\x04\xb4\x01\t\x18\n\r\n\x05\x04\t\x02\
    \x02\x03\x12\x04\xb4\x01\x1b\x1c\n\x0c\n\x04\x04\t\x02\x03\x12\x04\xb5\
    \x01\x02\x16\n\x0f\n\x05\x04\t\x02\x03\x04\x12\x06\xb5\x01\x02\xb4\x01\
    \x1d\n\r\n\x05\x04\t\x02\x03\x05\x12\x04\xb5\x01\x02\x07\n\r\n\x05\x04\t\
    \x02\x03\x01\x12\x04\xb5\x01\x08\x11\n\r\n\x05\x04\t\x02\x03\x03\x12\x04\
    \xb5\x01\x14\x15\n\x0c\n\x04\x04\t\x02\x04\x12\x04\xb6\x01\x02\x16\n\x0f\
    \n\x05\x04\t\x02\x04\x04\x12\x06\xb6\x01\x02\xb5\x01\x16\n\r\n\x05\x04\t\
    \x02\x04\x05\x12\x04\xb6\x01\x02\x07\n\r\n\x05\x04\t\x02\x04\x01\x12\x04\
    \xb6\x01\x08\x11\n\r\n\x05\x04\t\x02\x04\x03\x12\x04\xb6\x01\x14\x15\n\
    \x1f\n\x04\x04\t\x02\x05\x12\x04\xb7\x01\x02\x17\"\x111\x20bit\x201\x20c\
    ontract\n\n\x0f\n\x05\x04\t\x02\x05\x04\x12\x06\xb7\x01\x02\xb6\x01\x16\
    \n\r\n\x05\x04\t\x02\x05\x05\x12\x04\xb7\x01\x02\x07\n\r\n\x05\x04\t\x02\
    \x05\x01\x12\x04\xb7\x01\x08\x12\n\r\n\x05\x04\t\x02\x05\x03\x12\x04\xb7\
    \x01\x15\x16\n\x0c\n\x04\x04\t\x02\x06\x12\x04\xb8\x01\x02\x18\n\r\n\x05\
    \x04\t\x02\x06\x04\x12\x04\xb8\x01\x02\n\n\r\n\x05\x04\t\x02\x06\x06\x12\
    \x04\xb8\x01\x0b\x0e\n\r\n\x05\x04\t\x02\x06\x01\x12\x04\xb8\x01\x0f\x13\
    \n\r\n\x05\x04\t\x02\x06\x03\x12\x04\xb8\x01\x16\x17\n\x17\n\x02\x04\n\
    \x12\x06\xbc\x01\0\xc6\x01\x01\x1a\t\x20Witness\n\n\x0b\n\x03\x04\n\x01\
    \x12\x04\xbc\x01\x08\x0f\n\x0c\n\x04\x04\n\x02\0\x12\x04\xbd\x01\x02\x14\
    \n\x0f\n\x05\x04\n\x02\0\x04\x12\x06\xbd\x01\x02\xbc\x01\x11\n\r\n\x05\
    \x04\n\x02\0\x05\x12\x04\xbd\x01\x02\x07\n\r\n\x05\x04\n\x02\0\x01\x12\
    \x04\xbd\x01\x08\x0f\n\r\n\x05\x04\n\x02\0\x03\x12\x04\xbd\x01\x12\x13\n\
    \x0c\n\x04\x04\n\x02\x01\x12\x04\xbe\x01\x02\x16\n\x0f\n\x05\x04\n\x02\
    \x01\x04\x12\x06\xbe\x01\x02\xbd\x01\x14\n\r\n\x05\x04\n\x02\x01\x05\x12\
    \x04\xbe\x01\x02\x07\n\r\n\x05\x04\n\x02\x01\x01\x12\x04\xbe\x01\x08\x11\
    \n\r\n\x05\x04\n\x02\x01\x03\x12\x04\xbe\x01\x14\x15\n\x0c\n\x04\x04\n\
    \x02\x02\x12\x04\xbf\x01\x02\x13\n\x0f\n\x05\x04\n\x02\x02\x04\x12\x06\
    \xbf\x01\x02\xbe\x01\x16\n\r\n\x05\x04\n\x02\x02\x05\x12\x04\xbf\x01\x02\
    \x07\n\r\n\x05\x04\n\x02\x02\x01\x12\x04\xbf\x01\x08\x0e\n\r\n\x05\x04\n\
    \x02\x02\x03\x12\x04\xbf\x01\x11\x12\n\x0c\n\x04\x04\n\x02\x03\x12\x04\
    \xc0\x01\x02\x11\n\x0f\n\x05\x04\n\x02\x03\x04\x12\x06\xc0\x01\x02\xbf\
    \x01\x13\n\r\n\x05\x04\n\x02\x03\x05\x12\x04\xc0\x01\x02\x08\n\r\n\x05\
    \x04\n\x02\x03\x01\x12\x04\xc0\x01\t\x0c\n\r\n\x05\x04\n\x02\x03\x03\x12\
    \x04\xc0\x01\x0f\x10\n\x0c\n\x04\x04\n\x02\x04\x12\x04\xc1\x01\x02\x1a\n\
    \x0f\n\x05\x04\n\x02\x04\x04\x12\x06\xc1\x01\x02\xc0\x01\x11\n\r\n\x05\
    \x04\n\x02\x04\x05\x12\x04\xc1\x01\x02\x07\n\r\n\x05\x04\n\x02\x04\x01\
    \x12\x04\xc1\x01\x08\x15\n\r\n\x05\x04\n\x02\x04\x03\x12\x04\xc1\x01\x18\
    \x19\n\x0c\n\x04\x04\n\x02\x05\x12\x04\xc2\x01\x02\x18\n\x0f\n\x05\x04\n\
    \x02\x05\x04\x12\x06\xc2\x01\x02\xc1\x01\x1a\n\r\n\x05\x04\n\x02\x05\x05\
    \x12\x04\xc2\x01\x02\x07\n\r\n\x05\x04\n\x02\x05\x01\x12\x04\xc2\x01\x08\
    \x13\n\r\n\x05\x04\n\x02\x05\x03\x12\x04\xc2\x01\x16\x17\n\x0c\n\x04\x04\
    \n\x02\x06\x12\x04\xc3\x01\x02\x1b\n\x0f\n\x05\x04\n\x02\x06\x04\x12\x06\
    \xc3\x01\x02\xc2\x01\x18\n\r\n\x05\x04\n\x02\x06\x05\x12\x04\xc3\x01\x02\
    \x07\n\r\n\x05\x04\n\x02\x06\x01\x12\x04\xc3\x01\x08\x16\n\r\n\x05\x04\n\
    \x02\x06\x03\x12\x04\xc3\x01\x19\x1a\n\x0c\n\x04\x04\n\x02\x07\x12\x04\
    \xc4\x01\x02\x1a\n\x0f\n\x05\x04\n\x02\x07\x04\x12\x06\xc4\x01\x02\xc3\
    \x01\x1b\n\r\n\x05\x04\n\x02\x07\x05\x12\x04\xc4\x01\x02\x07\n\r\n\x05\
    \x04\n\x02\x07\x01\x12\x04\xc4\x01\x08\x15\n\r\n\x05\x04\n\x02\x07\x03\
    \x12\x04\xc4\x01\x18\x19\n\x0c\n\x04\x04\n\x02\x08\x12\x04\xc5\x01\x02\
    \x12\n\x0f\n\x05\x04\n\x02\x08\x04\x12\x06\xc5\x01\x02\xc4\x01\x1a\n\r\n\
    \x05\x04\n\x02\x08\x05\x12\x04\xc5\x01\x02\x06\n\r\n\x05\x04\n\x02\x08\
    \x01\x12\x04\xc5\x01\x07\r\n\r\n\x05\x04\n\x02\x08\x03\x12\x04\xc5\x01\
    \x10\x11\n\x1b\n\x02\x04\x0b\x12\x06\xc9\x01\0\xcd\x01\x01\x1a\r\x20Vote\
    \x20Change\n\n\x0b\n\x03\x04\x0b\x01\x12\x04\xc9\x01\x08\r\n\x0c\n\x04\
    \x04\x0b\x02\0\x12\x04\xca\x01\x02\x14\n\x0f\n\x05\x04\x0b\x02\0\x04\x12\
    \x06\xca\x01\x02\xc9\x01\x0f\n\r\n\x05\x04\x0b\x02\0\x05\x12\x04\xca\x01\
    \x02\x07\n\r\n\x05\x04\x0b\x02\0\x01\x12\x04\xca\x01\x08\x0f\n\r\n\x05\
    \x04\x0b\x02\0\x03\x12\x04\xca\x01\x12\x13\n\x0c\n\x04\x04\x0b\x02\x01\
    \x12\x04\xcb\x01\x02\x1e\n\r\n\x05\x04\x0b\x02\x01\x04\x12\x04\xcb\x01\
    \x02\n\n\r\n\x05\x04\x0b\x02\x01\x06\x12\x04\xcb\x01\x0b\x0f\n\r\n\x05\
    \x04\x0b\x02\x01\x01\x12\x04\xcb\x01\x10\x19\n\r\n\x05\x04\x0b\x02\x01\
    \x03\x12\x04\xcb\x01\x1c\x1d\n\x0c\n\x04\x04\x0b\x02\x02\x12\x04\xcc\x01\
    \x02\x1e\n\r\n\x05\x04\x0b\x02\x02\x04\x12\x04\xcc\x01\x02\n\n\r\n\x05\
    \x04\x0b\x02\x02\x06\x12\x04\xcc\x01\x0b\x0f\n\r\n\x05\x04\x0b\x02\x02\
    \x01\x12\x04\xcc\x01\x10\x19\n\r\n\x05\x04\x0b\x02\x02\x03\x12\x04\xcc\
    \x01\x1c\x1d\n\x1b\n\x02\x04\x0c\x12\x06\xd1\x01\0\xd4\x01\x012\r\x20Tra\
    nscation\n\n\x0b\n\x03\x04\x0c\x01\x12\x04\xd1\x01\x08\x10\n\x0c\n\x04\
    \x04\x0c\x02\0\x12\x04\xd2\x01\x02\x12\n\x0f\n\x05\x04\x0c\x02\0\x04\x12\
    \x06\xd2\x01\x02\xd1\x01\x12\n\r\n\x05\x04\x0c\x02\0\x05\x12\x04\xd2\x01\
    \x02\x07\n\r\n\x05\x04\x0c\x02\0\x01\x12\x04\xd2\x01\x08\r\n\r\n\x05\x04\
    \x0c\x02\0\x03\x12\x04\xd2\x01\x10\x11\n\x0c\n\x04\x04\x0c\x02\x01\x12\
    \x04\xd3\x01\x02\x17\n\x0f\n\x05\x04\x0c\x02\x01\x04\x12\x06\xd3\x01\x02\
    \xd2\x01\x12\n\r\n\x05\x04\x0c\x02\x01\x05\x12\x04\xd3\x01\x02\x07\n\r\n\
    \x05\x04\x0c\x02\x01\x01\x12\x04\xd3\x01\x08\x12\n\r\n\x05\x04\x0c\x02\
    \x01\x03\x12\x04\xd3\x01\x15\x16\n\x0c\n\x02\x04\r\x12\x06\xd6\x01\0\xde\
    \x01\x01\n\x0b\n\x03\x04\r\x01\x12\x04\xd6\x01\x08\x0f\n\x0e\n\x04\x04\r\
    \x03\0\x12\x06\xd7\x01\x02\xdb\x01\x03\n\r\n\x05\x04\r\x03\0\x01\x12\x04\
    \xd7\x01\n\r\n\x0e\n\x06\x04\r\x03\0\x02\0\x12\x04\xd8\x01\x04\x13\n\x11\
    \n\x07\x04\r\x03\0\x02\0\x04\x12\x06\xd8\x01\x04\xd7\x01\x0f\n\x0f\n\x07\
    \x04\r\x03\0\x02\0\x05\x12\x04\xd8\x01\x04\t\n\x0f\n\x07\x04\r\x03\0\x02\
    \0\x01\x12\x04\xd8\x01\n\x0e\n\x0f\n\x07\x04\r\x03\0\x02\0\x03\x12\x04\
    \xd8\x01\x11\x12\n\x0e\n\x06\x04\r\x03\0\x02\x01\x12\x04\xd9\x01\x04\x13\
    \n\x11\n\x07\x04\r\x03\0\x02\x01\x04\x12\x06\xd9\x01\x04\xd8\x01\x13\n\
    \x0f\n\x07\x04\r\x03\0\x02\x01\x05\x12\x04\xd9\x01\x04\t\n\x0f\n\x07\x04\
    \r\x03\0\x02\x01\x01\x12\x04\xd9\x01\n\x0e\n\x0f\n\x07\x04\r\x03\0\x02\
    \x01\x03\x12\x04\xd9\x01\x11\x12\n\x0e\n\x06\x04\r\x03\0\x02\x02\x12\x04\
    \xda\x01\x04\x15\n\x11\n\x07\x04\r\x03\0\x02\x02\x04\x12\x06\xda\x01\x04\
    \xd9\x01\x13\n\x0f\n\x07\x04\r\x03\0\x02\x02\x05\x12\x04\xda\x01\x04\t\n\
    \x0f\n\x07\x04\r\x03\0\x02\x02\x01\x12\x04\xda\x01\n\x10\n\x0f\n\x07\x04\
    \r\x03\0\x02\x02\x03\x12\x04\xda\x01\x13\x14\n\x0c\n\x04\x04\r\x02\0\x12\
    \x04\xdc\x01\x02\x13\n\x0f\n\x05\x04\r\x02\0\x04\x12\x06\xdc\x01\x02\xdb\
    \x01\x03\n\r\n\x05\x04\r\x02\0\x06\x12\x04\xdc\x01\x02\x05\n\r\n\x05\x04\
    \r\x02\0\x01\x12\x04\xdc\x01\x06\x0e\n\r\n\x05\x04\r\x02\0\x03\x12\x04\
    \xdc\x01\x11\x12\n\x0c\n\x04\x04\r\x02\x01\x12\x04\xdd\x01\x02\x16\n\x0f\
    \n\x05\x04\r\x02\x01\x04\x12\x06\xdd\x01\x02\xdc\x01\x13\n\r\n\x05\x04\r\
    \x02\x01\x05\x12\x04\xdd\x01\x02\x07\n\r\n\x05\x04\r\x02\x01\x01\x12\x04\
    \xdd\x01\x08\x11\n\r\n\x05\x04\r\x02\x01\x03\x12\x04\xdd\x01\x14\x15\n\
    \x0c\n\x02\x04\x0e\x12\x06\xe0\x01\0\xe2\x01\x01\n\x0b\n\x03\x04\x0e\x01\
    \x12\x04\xe0\x01\x08\x11\n\x0c\n\x04\x04\x0e\x02\0\x12\x04\xe1\x01\x02\
    \x20\n\r\n\x05\x04\x0e\x02\0\x04\x12\x04\xe1\x01\x02\n\n\r\n\x05\x04\x0e\
    \x02\0\x06\x12\x04\xe1\x01\x0b\x13\n\r\n\x05\x04\x0e\x02\0\x01\x12\x04\
    \xe1\x01\x14\x1b\n\r\n\x05\x04\x0e\x02\0\x03\x12\x04\xe1\x01\x1e\x1f\n\
    \x0c\n\x02\x04\x0f\x12\x06\xe4\x01\0\xec\x01\x01\n\x0b\n\x03\x04\x0f\x01\
    \x12\x04\xe4\x01\x08\x17\n\x0c\n\x04\x04\x0f\x02\0\x12\x04\xe5\x01\x02\
    \x19\n\x0f\n\x05\x04\x0f\x02\0\x04\x12\x06\xe5\x01\x02\xe4\x01\x19\n\r\n\
    \x05\x04\x0f\x02\0\x05\x12\x04\xe5\x01\x02\x07\n\r\n\x05\x04\x0f\x02\0\
    \x01\x12\x04\xe5\x01\x08\x14\n\r\n\x05\x04\x0f\x02\0\x03\x12\x04\xe5\x01\
    \x17\x18\n\x0c\n\x04\x04\x0f\x02\x01\x12\x04\xe6\x01\x02\x17\n\x0f\n\x05\
    \x04\x0f\x02\x01\x04\x12\x06\xe6\x01\x02\xe5\x01\x19\n\r\n\x05\x04\x0f\
    \x02\x01\x05\x12\x04\xe6\x01\x02\x07\n\r\n\x05\x04\x0f\x02\x01\x01\x12\
    \x04\xe6\x01\x08\x12\n\r\n\x05\x04\x0f\x02\x01\x03\x12\x04\xe6\x01\x15\
    \x16\n\x0c\n\x04\x04\x0f\x02\x02\x12\x04\xe7\x01\x02\x20\n\x0f\n\x05\x04\
    \x0f\x02\x02\x04\x12\x06\xe7\x01\x02\xe6\x01\x17\n\r\n\x05\x04\x0f\x02\
    \x02\x05\x12\x04\xe7\x01\x02\x07\n\r\n\x05\x04\x0f\x02\x02\x01\x12\x04\
    \xe7\x01\x08\x1b\n\r\n\x05\x04\x0f\x02\x02\x03\x12\x04\xe7\x01\x1e\x1f\n\
    \x0c\n\x04\x04\x0f\x02\x03\x12\x04\xe8\x01\x02\x1f\n\x0f\n\x05\x04\x0f\
    \x02\x03\x04\x12\x06\xe8\x01\x02\xe7\x01\x20\n\r\n\x05\x04\x0f\x02\x03\
    \x05\x12\x04\xe8\x01\x02\x07\n\r\n\x05\x04\x0f\x02\x03\x01\x12\x04\xe8\
    \x01\x08\x1a\n\r\n\x05\x04\x0f\x02\x03\x03\x12\x04\xe8\x01\x1d\x1e\n\x0c\
    \n\x04\x04\x0f\x02\x04\x12\x04\xe9\x01\x02\x16\n\x0f\n\x05\x04\x0f\x02\
    \x04\x04\x12\x06\xe9\x01\x02\xe8\x01\x1f\n\r\n\x05\x04\x0f\x02\x04\x05\
    \x12\x04\xe9\x01\x02\x07\n\r\n\x05\x04\x0f\x02\x04\x01\x12\x04\xe9\x01\
    \x08\x11\n\r\n\x05\x04\x0f\x02\x04\x03\x12\x04\xe9\x01\x14\x15\n\x0c\n\
    \x04\x04\x0f\x02\x05\x12\x04\xea\x01\x02\x14\n\x0f\n\x05\x04\x0f\x02\x05\
    \x04\x12\x06\xea\x01\x02\xe9\x01\x16\n\r\n\x05\x04\x0f\x02\x05\x05\x12\
    \x04\xea\x01\x02\x07\n\r\n\x05\x04\x0f\x02\x05\x01\x12\x04\xea\x01\x08\
    \x0f\n\r\n\x05\x04\x0f\x02\x05\x03\x12\x04\xea\x01\x12\x13\n\x0c\n\x04\
    \x04\x0f\x02\x06\x12\x04\xeb\x01\x02/\n\x0f\n\x05\x04\x0f\x02\x06\x04\
    \x12\x06\xeb\x01\x02\xea\x01\x14\n\r\n\x05\x04\x0f\x02\x06\x06\x12\x04\
    \xeb\x01\x02#\n\r\n\x05\x04\x0f\x02\x06\x01\x12\x04\xeb\x01$*\n\r\n\x05\
    \x04\x0f\x02\x06\x03\x12\x04\xeb\x01-.\n\x0c\n\x02\x04\x10\x12\x06\xee\
    \x01\0\xd2\x02\x01\n\x0b\n\x03\x04\x10\x01\x12\x04\xee\x01\x08\x13\n\x0e\
    \n\x04\x04\x10\x03\0\x12\x06\xef\x01\x02\x99\x02\x03\n\r\n\x05\x04\x10\
    \x03\0\x01\x12\x04\xef\x01\n\x12\n\x10\n\x06\x04\x10\x03\0\x04\0\x12\x06\
    \xf0\x01\x04\x93\x02\x05\n\x0f\n\x07\x04\x10\x03\0\x04\0\x01\x12\x04\xf0\
    \x01\t\x15\n\x10\n\x08\x04\x10\x03\0\x04\0\x02\0\x12\x04\xf1\x01\x06\x20\
    \n\x11\n\t\x04\x10\x03\0\x04\0\x02\0\x01\x12\x04\xf1\x01\x06\x1b\n\x11\n\
    \t\x04\x10\x03\0\x04\0\x02\0\x02\x12\x04\xf1\x01\x1e\x1f\n\x10\n\x08\x04\
    \x10\x03\0\x04\0\x02\x01\x12\x04\xf2\x01\x06\x1b\n\x11\n\t\x04\x10\x03\0\
    \x04\0\x02\x01\x01\x12\x04\xf2\x01\x06\x16\n\x11\n\t\x04\x10\x03\0\x04\0\
    \x02\x01\x02\x12\x04\xf2\x01\x19\x1a\n\x10\n\x08\x04\x10\x03\0\x04\0\x02\
    \x02\x12\x04\xf3\x01\x06\x20\n\x11\n\t\x04\x10\x03\0\x04\0\x02\x02\x01\
    \x12\x04\xf3\x01\x06\x1b\n\x11\n\t\x04\x10\x03\0\x04\0\x02\x02\x02\x12\
    \x04\xf3\x01\x1e\x1f\n\x10\n\x08\x04\x10\x03\0\x04\0\x02\x03\x12\x04\xf4\
    \x01\x06\x1c\n\x11\n\t\x04\x10\x03\0\x04\0\x02\x03\x01\x12\x04\xf4\x01\
    \x06\x17\n\x11\n\t\x04\x10\x03\0\x04\0\x02\x03\x02\x12\x04\xf4\x01\x1a\
    \x1b\n\x10\n\x08\x04\x10\x03\0\x04\0\x02\x04\x12\x04\xf5\x01\x06\x1e\n\
    \x11\n\t\x04\x10\x03\0\x04\0\x02\x04\x01\x12\x04\xf5\x01\x06\x19\n\x11\n\
    \t\x04\x10\x03\0\x04\0\x02\x04\x02\x12\x04\xf5\x01\x1c\x1d\n\x10\n\x08\
    \x04\x10\x03\0\x04\0\x02\x05\x12\x04\xf6\x01\x06\x20\n\x11\n\t\x04\x10\
    \x03\0\x04\0\x02\x05\x01\x12\x04\xf6\x01\x06\x1b\n\x11\n\t\x04\x10\x03\0\
    \x04\0\x02\x05\x02\x12\x04\xf6\x01\x1e\x1f\n\x10\n\x08\x04\x10\x03\0\x04\
    \0\x02\x06\x12\x04\xf7\x01\x06\x1d\n\x11\n\t\x04\x10\x03\0\x04\0\x02\x06\
    \x01\x12\x04\xf7\x01\x06\x18\n\x11\n\t\x04\x10\x03\0\x04\0\x02\x06\x02\
    \x12\x04\xf7\x01\x1b\x1c\n\x10\n\x08\x04\x10\x03\0\x04\0\x02\x07\x12\x04\
    \xf8\x01\x06\x20\n\x11\n\t\x04\x10\x03\0\x04\0\x02\x07\x01\x12\x04\xf8\
    \x01\x06\x1b\n\x11\n\t\x04\x10\x03\0\x04\0\x02\x07\x02\x12\x04\xf8\x01\
    \x1e\x1f\n\x10\n\x08\x04\x10\x03\0\x04\0\x02\x08\x12\x04\xf9\x01\x06(\n\
    \x11\n\t\x04\x10\x03\0\x04\0\x02\x08\x01\x12\x04\xf9\x01\x06#\n\x11\n\t\
    \x04\x10\x03\0\x04\0\x02\x08\x02\x12\x04\xf9\x01&'\n\x10\n\x08\x04\x10\
    \x03\0\x04\0\x02\t\x12\x04\xfa\x01\x06!\n\x11\n\t\x04\x10\x03\0\x04\0\
    \x02\t\x01\x12\x04\xfa\x01\x06\x1b\n\x11\n\t\x04\x10\x03\0\x04\0\x02\t\
    \x02\x12\x04\xfa\x01\x1e\x20\n\x10\n\x08\x04\x10\x03\0\x04\0\x02\n\x12\
    \x04\xfb\x01\x06!\n\x11\n\t\x04\x10\x03\0\x04\0\x02\n\x01\x12\x04\xfb\
    \x01\x06\x1b\n\x11\n\t\x04\x10\x03\0\x04\0\x02\n\x02\x12\x04\xfb\x01\x1e\
    \x20\n\x10\n\x08\x04\x10\x03\0\x04\0\x02\x0b\x12\x04\xfc\x01\x06#\n\x11\
    \n\t\x04\x10\x03\0\x04\0\x02\x0b\x01\x12\x04\xfc\x01\x06\x1d\n\x11\n\t\
    \x04\x10\x03\0\x04\0\x02\x0b\x02\x12\x04\xfc\x01\x20\"\n\x10\n\x08\x04\
    \x10\x03\0\x04\0\x02\x0c\x12\x04\xfd\x01\x06#\n\x11\n\t\x04\x10\x03\0\
    \x04\0\x02\x0c\x01\x12\x04\xfd\x01\x06\x1d\n\x11\n\t\x04\x10\x03\0\x04\0\
    \x02\x0c\x02\x12\x04\xfd\x01\x20\"\n\x10\n\x08\x04\x10\x03\0\x04\0\x02\r\
    \x12\x04\xfe\x01\x06!\n\x11\n\t\x04\x10\x03\0\x04\0\x02\r\x01\x12\x04\
    \xfe\x01\x06\x1b\n\x11\n\t\x04\x10\x03\0\x04\0\x02\r\x02\x12\x04\xfe\x01\
    \x1e\x20\n\x10\n\x08\x04\x10\x03\0\x04\0\x02\x0e\x12\x04\xff\x01\x06\x1f\
    \n\x11\n\t\x04\x10\x03\0\x04\0\x02\x0e\x01\x12\x04\xff\x01\x06\x19\n\x11\
    \n\t\x04\x10\x03\0\x04\0\x02\x0e\x02\x12\x04\xff\x01\x1c\x1e\n\x10\n\x08\
    \x04\x10\x03\0\x04\0\x02\x0f\x12\x04\x80\x02\x06\"\n\x11\n\t\x04\x10\x03\
    \0\x04\0\x02\x0f\x01\x12\x04\x80\x02\x06\x1c\n\x11\n\t\x04\x10\x03\0\x04\
    \0\x02\x0f\x02\x12\x04\x80\x02\x1f!\n\x10\n\x08\x04\x10\x03\0\x04\0\x02\
    \x10\x12\x04\x81\x02\x06#\n\x11\n\t\x04\x10\x03\0\x04\0\x02\x10\x01\x12\
    \x04\x81\x02\x06\x1d\n\x11\n\t\x04\x10\x03\0\x04\0\x02\x10\x02\x12\x04\
    \x81\x02\x20\"\n\x10\n\x08\x04\x10\x03\0\x04\0\x02\x11\x12\x04\x82\x02\
    \x06\"\n\x11\n\t\x04\x10\x03\0\x04\0\x02\x11\x01\x12\x04\x82\x02\x06\x1c\
    \n\x11\n\t\x04\x10\x03\0\x04\0\x02\x11\x02\x12\x04\x82\x02\x1f!\n\x10\n\
    \x08\x04\x10\x03\0\x04\0\x02\x12\x12\x04\x83\x02\x06\x20\n\x11\n\t\x04\
    \x10\x03\0\x04\0\x02\x12\x01\x12\x04\x83\x02\x06\x1a\n\x11\n\t\x04\x10\
    \x03\0\x04\0\x02\x12\x02\x12\x04\x83\x02\x1d\x1f\n\x10\n\x08\x04\x10\x03\
    \0\x04\0\x02\x13\x12\x04\x84\x02\x06\x1a\n\x11\n\t\x04\x10\x03\0\x04\0\
    \x02\x13\x01\x12\x04\x84\x02\x06\x14\n\x11\n\t\x04\x10\x03\0\x04\0\x02\
    \x13\x02\x12\x04\x84\x02\x17\x19\nf\n\x08\x04\x10\x03\0\x04\0\x02\x14\
    \x12\x04\x88\x02\x06\x1f\x1aT\x20BuyStorageContract\x20=\x2021;\n\x20Buy\
    StorageBytesContract\x20=\x2022;\n\x20SellStorageContract\x20=\x2023;\n\
    \n\x11\n\t\x04\x10\x03\0\x04\0\x02\x14\x01\x12\x04\x88\x02\x06\x19\n\x11\
    \n\t\x04\x10\x03\0\x04\0\x02\x14\x02\x12\x04\x88\x02\x1c\x1e\n\x10\n\x08\
    \x04\x10\x03\0\x04\0\x02\x15\x12\x04\x89\x02\x06\x20\n\x11\n\t\x04\x10\
    \x03\0\x04\0\x02\x15\x01\x12\x04\x89\x02\x06\x1a\n\x11\n\t\x04\x10\x03\0\
    \x04\0\x02\x15\x02\x12\x04\x89\x02\x1d\x1f\n\x10\n\x08\x04\x10\x03\0\x04\
    \0\x02\x16\x12\x04\x8a\x02\x06\x17\n\x11\n\t\x04\x10\x03\0\x04\0\x02\x16\
    \x01\x12\x04\x8a\x02\x06\x11\n\x11\n\t\x04\x10\x03\0\x04\0\x02\x16\x02\
    \x12\x04\x8a\x02\x14\x16\n\x10\n\x08\x04\x10\x03\0\x04\0\x02\x17\x12\x04\
    \x8b\x02\x06!\n\x11\n\t\x04\x10\x03\0\x04\0\x02\x17\x01\x12\x04\x8b\x02\
    \x06\x1b\n\x11\n\t\x04\x10\x03\0\x04\0\x02\x17\x02\x12\x04\x8b\x02\x1e\
    \x20\n\x10\n\x08\x04\x10\x03\0\x04\0\x02\x18\x12\x04\x8c\x02\x06\"\n\x11\
    \n\t\x04\x10\x03\0\x04\0\x02\x18\x01\x12\x04\x8c\x02\x06\x1c\n\x11\n\t\
    \x04\x10\x03\0\x04\0\x02\x18\x02\x12\x04\x8c\x02\x1f!\n\x10\n\x08\x04\
    \x10\x03\0\x04\0\x02\x19\x12\x04\x8d\x02\x06\"\n\x11\n\t\x04\x10\x03\0\
    \x04\0\x02\x19\x01\x12\x04\x8d\x02\x06\x1c\n\x11\n\t\x04\x10\x03\0\x04\0\
    \x02\x19\x02\x12\x04\x8d\x02\x1f!\n\x10\n\x08\x04\x10\x03\0\x04\0\x02\
    \x1a\x12\x04\x8e\x02\x06$\n\x11\n\t\x04\x10\x03\0\x04\0\x02\x1a\x01\x12\
    \x04\x8e\x02\x06\x1e\n\x11\n\t\x04\x10\x03\0\x04\0\x02\x1a\x02\x12\x04\
    \x8e\x02!#\n\x10\n\x08\x04\x10\x03\0\x04\0\x02\x1b\x12\x04\x8f\x02\x06'\
    \n\x11\n\t\x04\x10\x03\0\x04\0\x02\x1b\x01\x12\x04\x8f\x02\x06!\n\x11\n\
    \t\x04\x10\x03\0\x04\0\x02\x1b\x02\x12\x04\x8f\x02$&\n\x10\n\x08\x04\x10\
    \x03\0\x04\0\x02\x1c\x12\x04\x90\x02\x06%\n\x11\n\t\x04\x10\x03\0\x04\0\
    \x02\x1c\x01\x12\x04\x90\x02\x06\x1f\n\x11\n\t\x04\x10\x03\0\x04\0\x02\
    \x1c\x02\x12\x04\x90\x02\"$\n\x10\n\x08\x04\x10\x03\0\x04\0\x02\x1d\x12\
    \x04\x91\x02\x06+\n\x11\n\t\x04\x10\x03\0\x04\0\x02\x1d\x01\x12\x04\x91\
    \x02\x06%\n\x11\n\t\x04\x10\x03\0\x04\0\x02\x1d\x02\x12\x04\x91\x02(*\n\
    \x10\n\x08\x04\x10\x03\0\x04\0\x02\x1e\x12\x04\x92\x02\x06\x1c\n\x11\n\t\
    \x04\x10\x03\0\x04\0\x02\x1e\x01\x12\x04\x92\x02\x06\x16\n\x11\n\t\x04\
    \x10\x03\0\x04\0\x02\x1e\x02\x12\x04\x92\x02\x19\x1b\n\x0e\n\x06\x04\x10\
    \x03\0\x02\0\x12\x04\x94\x02\x04\x1a\n\x11\n\x07\x04\x10\x03\0\x02\0\x04\
    \x12\x06\x94\x02\x04\x93\x02\x05\n\x0f\n\x07\x04\x10\x03\0\x02\0\x06\x12\
    \x04\x94\x02\x04\x10\n\x0f\n\x07\x04\x10\x03\0\x02\0\x01\x12\x04\x94\x02\
    \x11\x15\n\x0f\n\x07\x04\x10\x03\0\x02\0\x03\x12\x04\x94\x02\x18\x19\n\
    \x0e\n\x06\x04\x10\x03\0\x02\x01\x12\x04\x95\x02\x04&\n\x11\n\x07\x04\
    \x10\x03\0\x02\x01\x04\x12\x06\x95\x02\x04\x94\x02\x1a\n\x0f\n\x07\x04\
    \x10\x03\0\x02\x01\x06\x12\x04\x95\x02\x04\x17\n\x0f\n\x07\x04\x10\x03\0\
    \x02\x01\x01\x12\x04\x95\x02\x18!\n\x0f\n\x07\x04\x10\x03\0\x02\x01\x03\
    \x12\x04\x95\x02$%\n\x0e\n\x06\x04\x10\x03\0\x02\x02\x12\x04\x96\x02\x04\
    \x17\n\x11\n\x07\x04\x10\x03\0\x02\x02\x04\x12\x06\x96\x02\x04\x95\x02&\
    \n\x0f\n\x07\x04\x10\x03\0\x02\x02\x05\x12\x04\x96\x02\x04\t\n\x0f\n\x07\
    \x04\x10\x03\0\x02\x02\x01\x12\x04\x96\x02\n\x12\n\x0f\n\x07\x04\x10\x03\
    \0\x02\x02\x03\x12\x04\x96\x02\x15\x16\n\x0e\n\x06\x04\x10\x03\0\x02\x03\
    \x12\x04\x97\x02\x04\x1b\n\x11\n\x07\x04\x10\x03\0\x02\x03\x04\x12\x06\
    \x97\x02\x04\x96\x02\x17\n\x0f\n\x07\x04\x10\x03\0\x02\x03\x05\x12\x04\
    \x97\x02\x04\t\n\x0f\n\x07\x04\x10\x03\0\x02\x03\x01\x12\x04\x97\x02\n\
    \x16\n\x0f\n\x07\x04\x10\x03\0\x02\x03\x03\x12\x04\x97\x02\x19\x1a\n\x0e\
    \n\x06\x04\x10\x03\0\x02\x04\x12\x04\x98\x02\x04\x1c\n\x11\n\x07\x04\x10\
    \x03\0\x02\x04\x04\x12\x06\x98\x02\x04\x97\x02\x1b\n\x0f\n\x07\x04\x10\
    \x03\0\x02\x04\x05\x12\x04\x98\x02\x04\t\n\x0f\n\x07\x04\x10\x03\0\x02\
    \x04\x01\x12\x04\x98\x02\n\x17\n\x0f\n\x07\x04\x10\x03\0\x02\x04\x03\x12\
    \x04\x98\x02\x1a\x1b\n\x0e\n\x04\x04\x10\x03\x01\x12\x06\x9b\x02\x02\xbc\
    \x02\x03\n\r\n\x05\x04\x10\x03\x01\x01\x12\x04\x9b\x02\n\x10\n\x10\n\x06\
    \x04\x10\x03\x01\x04\0\x12\x06\x9c\x02\x04\x9f\x02\x05\n\x0f\n\x07\x04\
    \x10\x03\x01\x04\0\x01\x12\x04\x9c\x02\t\r\n\x10\n\x08\x04\x10\x03\x01\
    \x04\0\x02\0\x12\x04\x9d\x02\x06\x11\n\x11\n\t\x04\x10\x03\x01\x04\0\x02\
    \0\x01\x12\x04\x9d\x02\x06\x0c\n\x11\n\t\x04\x10\x03\x01\x04\0\x02\0\x02\
    \x12\x04\x9d\x02\x0f\x10\n\x10\n\x08\x04\x10\x03\x01\x04\0\x02\x01\x12\
    \x04\x9e\x02\x06\x11\n\x11\n\t\x04\x10\x03\x01\x04\0\x02\x01\x01\x12\x04\
    \x9e\x02\x06\x0c\n\x11\n\t\x04\x10\x03\x01\x04\0\x02\x01\x02\x12\x04\x9e\
    \x02\x0f\x10\n\x10\n\x06\x04\x10\x03\x01\x04\x01\x12\x06\xa0\x02\x04\xb0\
    \x02\x05\n\x0f\n\x07\x04\x10\x03\x01\x04\x01\x01\x12\x04\xa0\x02\t\x17\n\
    \x10\n\x08\x04\x10\x03\x01\x04\x01\x02\0\x12\x04\xa1\x02\x06\x12\n\x11\n\
    \t\x04\x10\x03\x01\x04\x01\x02\0\x01\x12\x04\xa1\x02\x06\r\n\x11\n\t\x04\
    \x10\x03\x01\x04\x01\x02\0\x02\x12\x04\xa1\x02\x10\x11\n\x10\n\x08\x04\
    \x10\x03\x01\x04\x01\x02\x01\x12\x04\xa2\x02\x06\x12\n\x11\n\t\x04\x10\
    \x03\x01\x04\x01\x02\x01\x01\x12\x04\xa2\x02\x06\r\n\x11\n\t\x04\x10\x03\
    \x01\x04\x01\x02\x01\x02\x12\x04\xa2\x02\x10\x11\n\x10\n\x08\x04\x10\x03\
    \x01\x04\x01\x02\x02\x12\x04\xa3\x02\x06\x11\n\x11\n\t\x04\x10\x03\x01\
    \x04\x01\x02\x02\x01\x12\x04\xa3\x02\x06\x0c\n\x11\n\t\x04\x10\x03\x01\
    \x04\x01\x02\x02\x02\x12\x04\xa3\x02\x0f\x10\n\x10\n\x08\x04\x10\x03\x01\
    \x04\x01\x02\x03\x12\x04\xa4\x02\x06\x1f\n\x11\n\t\x04\x10\x03\x01\x04\
    \x01\x02\x03\x01\x12\x04\xa4\x02\x06\x1a\n\x11\n\t\x04\x10\x03\x01\x04\
    \x01\x02\x03\x02\x12\x04\xa4\x02\x1d\x1e\n\x10\n\x08\x04\x10\x03\x01\x04\
    \x01\x02\x04\x12\x04\xa5\x02\x06\x18\n\x11\n\t\x04\x10\x03\x01\x04\x01\
    \x02\x04\x01\x12\x04\xa5\x02\x06\x13\n\x11\n\t\x04\x10\x03\x01\x04\x01\
    \x02\x04\x02\x12\x04\xa5\x02\x16\x17\n\x10\n\x08\x04\x10\x03\x01\x04\x01\
    \x02\x05\x12\x04\xa6\x02\x06\x1f\n\x11\n\t\x04\x10\x03\x01\x04\x01\x02\
    \x05\x01\x12\x04\xa6\x02\x06\x1a\n\x11\n\t\x04\x10\x03\x01\x04\x01\x02\
    \x05\x02\x12\x04\xa6\x02\x1d\x1e\n\x10\n\x08\x04\x10\x03\x01\x04\x01\x02\
    \x06\x12\x04\xa7\x02\x06\x1a\n\x11\n\t\x04\x10\x03\x01\x04\x01\x02\x06\
    \x01\x12\x04\xa7\x02\x06\x15\n\x11\n\t\x04\x10\x03\x01\x04\x01\x02\x06\
    \x02\x12\x04\xa7\x02\x18\x19\n\x10\n\x08\x04\x10\x03\x01\x04\x01\x02\x07\
    \x12\x04\xa8\x02\x06\x1a\n\x11\n\t\x04\x10\x03\x01\x04\x01\x02\x07\x01\
    \x12\x04\xa8\x02\x06\x15\n\x11\n\t\x04\x10\x03\x01\x04\x01\x02\x07\x02\
    \x12\x04\xa8\x02\x18\x19\n\x10\n\x08\x04\x10\x03\x01\x04\x01\x02\x08\x12\
    \x04\xa9\x02\x06\x1c\n\x11\n\t\x04\x10\x03\x01\x04\x01\x02\x08\x01\x12\
    \x04\xa9\x02\x06\x17\n\x11\n\t\x04\x10\x03\x01\x04\x01\x02\x08\x02\x12\
    \x04\xa9\x02\x1a\x1b\n\x10\n\x08\x04\x10\x03\x01\x04\x01\x02\t\x12\x04\
    \xaa\x02\x06\x19\n\x11\n\t\x04\x10\x03\x01\x04\x01\x02\t\x01\x12\x04\xaa\
    \x02\x06\x14\n\x11\n\t\x04\x10\x03\x01\x04\x01\x02\t\x02\x12\x04\xaa\x02\
    \x17\x18\n\x10\n\x08\x04\x10\x03\x01\x04\x01\x02\n\x12\x04\xab\x02\x06\
    \x19\n\x11\n\t\x04\x10\x03\x01\x04\x01\x02\n\x01\x12\x04\xab\x02\x06\x13\
    \n\x11\n\t\x04\x10\x03\x01\x04\x01\x02\n\x02\x12\x04\xab\x02\x16\x18\n\
    \x10\n\x08\x04\x10\x03\x01\x04\x01\x02\x0b\x12\x04\xac\x02\x06\x17\n\x11\
    \n\t\x04\x10\x03\x01\x04\x01\x02\x0b\x01\x12\x04\xac\x02\x06\x11\n\x11\n\
    \t\x04\x10\x03\x01\x04\x01\x02\x0b\x02\x12\x04\xac\x02\x14\x16\n\x10\n\
    \x08\x04\x10\x03\x01\x04\x01\x02\x0c\x12\x04\xad\x02\x06\x1f\n\x11\n\t\
    \x04\x10\x03\x01\x04\x01\x02\x0c\x01\x12\x04\xad\x02\x06\x19\n\x11\n\t\
    \x04\x10\x03\x01\x04\x01\x02\x0c\x02\x12\x04\xad\x02\x1c\x1e\n\x10\n\x08\
    \x04\x10\x03\x01\x04\x01\x02\r\x12\x04\xae\x02\x06\x13\n\x11\n\t\x04\x10\
    \x03\x01\x04\x01\x02\r\x01\x12\x04\xae\x02\x06\r\n\x11\n\t\x04\x10\x03\
    \x01\x04\x01\x02\r\x02\x12\x04\xae\x02\x10\x12\n\x10\n\x08\x04\x10\x03\
    \x01\x04\x01\x02\x0e\x12\x04\xaf\x02\x06\x1b\n\x11\n\t\x04\x10\x03\x01\
    \x04\x01\x02\x0e\x01\x12\x04\xaf\x02\x06\x15\n\x11\n\t\x04\x10\x03\x01\
    \x04\x01\x02\x0e\x02\x12\x04\xaf\x02\x18\x1a\n\x0e\n\x06\x04\x10\x03\x01\
    \x02\0\x12\x04\xb1\x02\x04\x12\n\x11\n\x07\x04\x10\x03\x01\x02\0\x04\x12\
    \x06\xb1\x02\x04\xb0\x02\x05\n\x0f\n\x07\x04\x10\x03\x01\x02\0\x05\x12\
    \x04\xb1\x02\x04\t\n\x0f\n\x07\x04\x10\x03\x01\x02\0\x01\x12\x04\xb1\x02\
    \n\r\n\x0f\n\x07\x04\x10\x03\x01\x02\0\x03\x12\x04\xb1\x02\x10\x11\n\x0e\
    \n\x06\x04\x10\x03\x01\x02\x01\x12\x04\xb2\x02\x04\x11\n\x11\n\x07\x04\
    \x10\x03\x01\x02\x01\x04\x12\x06\xb2\x02\x04\xb1\x02\x12\n\x0f\n\x07\x04\
    \x10\x03\x01\x02\x01\x06\x12\x04\xb2\x02\x04\x08\n\x0f\n\x07\x04\x10\x03\
    \x01\x02\x01\x01\x12\x04\xb2\x02\t\x0c\n\x0f\n\x07\x04\x10\x03\x01\x02\
    \x01\x03\x12\x04\xb2\x02\x0f\x10\n\x0e\n\x06\x04\x10\x03\x01\x02\x02\x12\
    \x04\xb3\x02\x04#\n\x11\n\x07\x04\x10\x03\x01\x02\x02\x04\x12\x06\xb3\
    \x02\x04\xb2\x02\x11\n\x0f\n\x07\x04\x10\x03\x01\x02\x02\x06\x12\x04\xb3\
    \x02\x04\x12\n\x0f\n\x07\x04\x10\x03\x01\x02\x02\x01\x12\x04\xb3\x02\x13\
    \x1e\n\x0f\n\x07\x04\x10\x03\x01\x02\x02\x03\x12\x04\xb3\x02!\"\n\x0e\n\
    \x06\x04\x10\x03\x01\x02\x03\x12\x04\xb5\x02\x04\x1d\n\x11\n\x07\x04\x10\
    \x03\x01\x02\x03\x04\x12\x06\xb5\x02\x04\xb3\x02#\n\x0f\n\x07\x04\x10\
    \x03\x01\x02\x03\x05\x12\x04\xb5\x02\x04\n\n\x0f\n\x07\x04\x10\x03\x01\
    \x02\x03\x01\x12\x04\xb5\x02\x0b\x17\n\x0f\n\x07\x04\x10\x03\x01\x02\x03\
    \x03\x12\x04\xb5\x02\x1a\x1c\n\x0e\n\x06\x04\x10\x03\x01\x02\x04\x12\x04\
    \xb6\x02\x04\x1f\n\x11\n\x07\x04\x10\x03\x01\x02\x04\x04\x12\x06\xb6\x02\
    \x04\xb5\x02\x1d\n\x0f\n\x07\x04\x10\x03\x01\x02\x04\x05\x12\x04\xb6\x02\
    \x04\t\n\x0f\n\x07\x04\x10\x03\x01\x02\x04\x01\x12\x04\xb6\x02\n\x19\n\
    \x0f\n\x07\x04\x10\x03\x01\x02\x04\x03\x12\x04\xb6\x02\x1c\x1e\n\x0e\n\
    \x06\x04\x10\x03\x01\x02\x05\x12\x04\xb7\x02\x04\x1f\n\x11\n\x07\x04\x10\
    \x03\x01\x02\x05\x04\x12\x06\xb7\x02\x04\xb6\x02\x1f\n\x0f\n\x07\x04\x10\
    \x03\x01\x02\x05\x05\x12\x04\xb7\x02\x04\t\n\x0f\n\x07\x04\x10\x03\x01\
    \x02\x05\x01\x12\x04\xb7\x02\n\x19\n\x0f\n\x07\x04\x10\x03\x01\x02\x05\
    \x03\x12\x04\xb7\x02\x1c\x1e\n\x0e\n\x06\x04\x10\x03\x01\x02\x06\x12\x04\
    \xb8\x02\x04(\n\x11\n\x07\x04\x10\x03\x01\x02\x06\x04\x12\x06\xb8\x02\
    \x04\xb7\x02\x1f\n\x0f\n\x07\x04\x10\x03\x01\x02\x06\x05\x12\x04\xb8\x02\
    \x04\t\n\x0f\n\x07\x04\x10\x03\x01\x02\x06\x01\x12\x04\xb8\x02\n\"\n\x0f\
    \n\x07\x04\x10\x03\x01\x02\x06\x03\x12\x04\xb8\x02%'\n\x0e\n\x06\x04\x10\
    \x03\x01\x02\x07\x12\x04\xb9\x02\x04.\n\x11\n\x07\x04\x10\x03\x01\x02\
    \x07\x04\x12\x06\xb9\x02\x04\xb8\x02(\n\x0f\n\x07\x04\x10\x03\x01\x02\
    \x07\x05\x12\x04\xb9\x02\x04\t\n\x0f\n\x07\x04\x10\x03\x01\x02\x07\x01\
    \x12\x04\xb9\x02\n(\n\x0f\n\x07\x04\x10\x03\x01\x02\x07\x03\x12\x04\xb9\
    \x02+-\n\x0e\n\x06\x04\x10\x03\x01\x02\x08\x12\x04\xba\x02\x040\n\x11\n\
    \x07\x04\x10\x03\x01\x02\x08\x04\x12\x06\xba\x02\x04\xb9\x02.\n\x0f\n\
    \x07\x04\x10\x03\x01\x02\x08\x05\x12\x04\xba\x02\x04\t\n\x0f\n\x07\x04\
    \x10\x03\x01\x02\x08\x01\x12\x04\xba\x02\n*\n\x0f\n\x07\x04\x10\x03\x01\
    \x02\x08\x03\x12\x04\xba\x02-/\n\x0e\n\x06\x04\x10\x03\x01\x02\t\x12\x04\
    \xbb\x02\x04\x1b\n\x11\n\x07\x04\x10\x03\x01\x02\t\x04\x12\x06\xbb\x02\
    \x04\xba\x020\n\x0f\n\x07\x04\x10\x03\x01\x02\t\x05\x12\x04\xbb\x02\x04\
    \t\n\x0f\n\x07\x04\x10\x03\x01\x02\t\x01\x12\x04\xbb\x02\n\x15\n\x0f\n\
    \x07\x04\x10\x03\x01\x02\t\x03\x12\x04\xbb\x02\x18\x1a\n\x0e\n\x04\x04\
    \x10\x03\x02\x12\x06\xbe\x02\x02\xcc\x02\x03\n\r\n\x05\x04\x10\x03\x02\
    \x01\x12\x04\xbe\x02\n\r\n\x0e\n\x06\x04\x10\x03\x02\x02\0\x12\x04\xbf\
    \x02\x04\x1e\n\x11\n\x07\x04\x10\x03\x02\x02\0\x04\x12\x06\xbf\x02\x04\
    \xbe\x02\x0f\n\x0f\n\x07\x04\x10\x03\x02\x02\0\x05\x12\x04\xbf\x02\x04\t\
    \n\x0f\n\x07\x04\x10\x03\x02\x02\0\x01\x12\x04\xbf\x02\n\x19\n\x0f\n\x07\
    \x04\x10\x03\x02\x02\0\x03\x12\x04\xbf\x02\x1c\x1d\n\x0e\n\x06\x04\x10\
    \x03\x02\x02\x01\x12\x04\xc0\x02\x04\x1c\n\x11\n\x07\x04\x10\x03\x02\x02\
    \x01\x04\x12\x06\xc0\x02\x04\xbf\x02\x1e\n\x0f\n\x07\x04\x10\x03\x02\x02\
    \x01\x05\x12\x04\xc0\x02\x04\t\n\x0f\n\x07\x04\x10\x03\x02\x02\x01\x01\
    \x12\x04\xc0\x02\n\x17\n\x0f\n\x07\x04\x10\x03\x02\x02\x01\x03\x12\x04\
    \xc0\x02\x1a\x1b\n\x0e\n\x06\x04\x10\x03\x02\x02\x02\x12\x04\xc1\x02\x04\
    \x1d\n\x11\n\x07\x04\x10\x03\x02\x02\x02\x04\x12\x06\xc1\x02\x04\xc0\x02\
    \x1c\n\x0f\n\x07\x04\x10\x03\x02\x02\x02\x05\x12\x04\xc1\x02\x04\t\n\x0f\
    \n\x07\x04\x10\x03\x02\x02\x02\x01\x12\x04\xc1\x02\n\x18\n\x0f\n\x07\x04\
    \x10\x03\x02\x02\x02\x03\x12\x04\xc1\x02\x1b\x1c\n\x0e\n\x06\x04\x10\x03\
    \x02\x02\x03\x12\x04\xc2\x02\x04\x19\n\x11\n\x07\x04\x10\x03\x02\x02\x03\
    \x04\x12\x06\xc2\x02\x04\xc1\x02\x1d\n\x0f\n\x07\x04\x10\x03\x02\x02\x03\
    \x05\x12\x04\xc2\x02\x04\t\n\x0f\n\x07\x04\x10\x03\x02\x02\x03\x01\x12\
    \x04\xc2\x02\n\x14\n\x0f\n\x07\x04\x10\x03\x02\x02\x03\x03\x12\x04\xc2\
    \x02\x17\x18\n\x0e\n\x06\x04\x10\x03\x02\x02\x04\x12\x04\xc3\x02\x04!\n\
    \x0f\n\x07\x04\x10\x03\x02\x02\x04\x04\x12\x04\xc3\x02\x04\x0c\n\x0f\n\
    \x07\x04\x10\x03\x02\x02\x04\x06\x12\x04\xc3\x02\r\x16\n\x0f\n\x07\x04\
    \x10\x03\x02\x02\x04\x01\x12\x04\xc3\x02\x17\x1c\n\x0f\n\x07\x04\x10\x03\
    \x02\x02\x04\x03\x12\x04\xc3\x02\x1f\x20\n\x1f\n\x06\x04\x10\x03\x02\x02\
    \x05\x12\x04\xc5\x02\x04\x14\x1a\x0f\x20data\x20not\x20used\n\n\x11\n\
    \x07\x04\x10\x03\x02\x02\x05\x04\x12\x06\xc5\x02\x04\xc3\x02!\n\x0f\n\
    \x07\x04\x10\x03\x02\x02\x05\x05\x12\x04\xc5\x02\x04\t\n\x0f\n\x07\x04\
    \x10\x03\x02\x02\x05\x01\x12\x04\xc5\x02\n\x0e\n\x0f\n\x07\x04\x10\x03\
    \x02\x02\x05\x03\x12\x04\xc5\x02\x11\x13\nI\n\x06\x04\x10\x03\x02\x02\
    \x06\x12\x04\xc7\x02\x04$\x1a9only\x20support\x20size\x20=\x201,\x20\x20\
    repeated\x20list\x20here\x20for\x20extension\n\n\x0f\n\x07\x04\x10\x03\
    \x02\x02\x06\x04\x12\x04\xc7\x02\x04\x0c\n\x0f\n\x07\x04\x10\x03\x02\x02\
    \x06\x06\x12\x04\xc7\x02\r\x15\n\x0f\n\x07\x04\x10\x03\x02\x02\x06\x01\
    \x12\x04\xc7\x02\x16\x1e\n\x0f\n\x07\x04\x10\x03\x02\x02\x06\x03\x12\x04\
    \xc7\x02!#\n\"\n\x06\x04\x10\x03\x02\x02\x07\x12\x04\xc9\x02\x04\x17\x1a\
    \x12\x20scripts\x20not\x20used\n\n\x11\n\x07\x04\x10\x03\x02\x02\x07\x04\
    \x12\x06\xc9\x02\x04\xc7\x02$\n\x0f\n\x07\x04\x10\x03\x02\x02\x07\x05\
    \x12\x04\xc9\x02\x04\t\n\x0f\n\x07\x04\x10\x03\x02\x02\x07\x01\x12\x04\
    \xc9\x02\n\x11\n\x0f\n\x07\x04\x10\x03\x02\x02\x07\x03\x12\x04\xc9\x02\
    \x14\x16\n\x0e\n\x06\x04\x10\x03\x02\x02\x08\x12\x04\xca\x02\x04\x19\n\
    \x11\n\x07\x04\x10\x03\x02\x02\x08\x04\x12\x06\xca\x02\x04\xc9\x02\x17\n\
    \x0f\n\x07\x04\x10\x03\x02\x02\x08\x05\x12\x04\xca\x02\x04\t\n\x0f\n\x07\
    \x04\x10\x03\x02\x02\x08\x01\x12\x04\xca\x02\n\x13\n\x0f\n\x07\x04\x10\
    \x03\x02\x02\x08\x03\x12\x04\xca\x02\x16\x18\n\x0e\n\x06\x04\x10\x03\x02\
    \x02\t\x12\x04\xcb\x02\x04\x19\n\x11\n\x07\x04\x10\x03\x02\x02\t\x04\x12\
    \x06\xcb\x02\x04\xca\x02\x19\n\x0f\n\x07\x04\x10\x03\x02\x02\t\x05\x12\
    \x04\xcb\x02\x04\t\n\x0f\n\x07\x04\x10\x03\x02\x02\t\x01\x12\x04\xcb\x02\
    \n\x13\n\x0f\n\x07\x04\x10\x03\x02\x02\t\x03\x12\x04\xcb\x02\x16\x18\n\
    \x0c\n\x04\x04\x10\x02\0\x12\x04\xce\x02\x02\x13\n\x0f\n\x05\x04\x10\x02\
    \0\x04\x12\x06\xce\x02\x02\xcc\x02\x03\n\r\n\x05\x04\x10\x02\0\x06\x12\
    \x04\xce\x02\x02\x05\n\r\n\x05\x04\x10\x02\0\x01\x12\x04\xce\x02\x06\x0e\
    \n\r\n\x05\x04\x10\x02\0\x03\x12\x04\xce\x02\x11\x12\nQ\n\x04\x04\x10\
    \x02\x01\x12\x04\xd0\x02\x02\x1f\x1aC\x20only\x20support\x20size\x20=\
    \x201,\x20\x20repeated\x20list\x20here\x20for\x20muti-sig\x20extension\n\
    \n\r\n\x05\x04\x10\x02\x01\x04\x12\x04\xd0\x02\x02\n\n\r\n\x05\x04\x10\
    \x02\x01\x05\x12\x04\xd0\x02\x0b\x10\n\r\n\x05\x04\x10\x02\x01\x01\x12\
    \x04\xd0\x02\x11\x1a\n\r\n\x05\x04\x10\x02\x01\x03\x12\x04\xd0\x02\x1d\
    \x1e\n\x0c\n\x04\x04\x10\x02\x02\x12\x04\xd1\x02\x02\x1a\n\r\n\x05\x04\
    \x10\x02\x02\x04\x12\x04\xd1\x02\x02\n\n\r\n\x05\x04\x10\x02\x02\x06\x12\
    \x04\xd1\x02\x0b\x11\n\r\n\x05\x04\x10\x02\x02\x01\x12\x04\xd1\x02\x12\
    \x15\n\r\n\x05\x04\x10\x02\x02\x03\x12\x04\xd1\x02\x18\x19\n\x0c\n\x02\
    \x04\x11\x12\x06\xd4\x02\0\xf1\x02\x01\n\x0b\n\x03\x04\x11\x01\x12\x04\
    \xd4\x02\x08\x17\n\x0e\n\x04\x04\x11\x04\0\x12\x06\xd5\x02\x02\xd8\x02\
    \x03\n\r\n\x05\x04\x11\x04\0\x01\x12\x04\xd5\x02\x07\x0b\n\x0e\n\x06\x04\
    \x11\x04\0\x02\0\x12\x04\xd6\x02\x04\x0f\n\x0f\n\x07\x04\x11\x04\0\x02\0\
    \x01\x12\x04\xd6\x02\x04\n\n\x0f\n\x07\x04\x11\x04\0\x02\0\x02\x12\x04\
    \xd6\x02\r\x0e\n\x0e\n\x06\x04\x11\x04\0\x02\x01\x12\x04\xd7\x02\x04\x0f\
    \n\x0f\n\x07\x04\x11\x04\0\x02\x01\x01\x12\x04\xd7\x02\x04\n\n\x0f\n\x07\
    \x04\x11\x04\0\x02\x01\x02\x12\x04\xd7\x02\r\x0e\n\x0e\n\x04\x04\x11\x03\
    \0\x12\x06\xd9\x02\x02\xdd\x02\x03\n\r\n\x05\x04\x11\x03\0\x01\x12\x04\
    \xd9\x02\n\r\n\x0e\n\x06\x04\x11\x03\0\x02\0\x12\x04\xda\x02\x04\x16\n\
    \x11\n\x07\x04\x11\x03\0\x02\0\x04\x12\x06\xda\x02\x04\xd9\x02\x0f\n\x0f\
    \n\x07\x04\x11\x03\0\x02\0\x05\x12\x04\xda\x02\x04\t\n\x0f\n\x07\x04\x11\
    \x03\0\x02\0\x01\x12\x04\xda\x02\n\x11\n\x0f\n\x07\x04\x11\x03\0\x02\0\
    \x03\x12\x04\xda\x02\x14\x15\n\x0e\n\x06\x04\x11\x03\0\x02\x01\x12\x04\
    \xdb\x02\x04\x1e\n\x0f\n\x07\x04\x11\x03\0\x02\x01\x04\x12\x04\xdb\x02\
    \x04\x0c\n\x0f\n\x07\x04\x11\x03\0\x02\x01\x05\x12\x04\xdb\x02\r\x12\n\
    \x0f\n\x07\x04\x11\x03\0\x02\x01\x01\x12\x04\xdb\x02\x13\x19\n\x0f\n\x07\
    \x04\x11\x03\0\x02\x01\x03\x12\x04\xdb\x02\x1c\x1d\n\x0e\n\x06\x04\x11\
    \x03\0\x02\x02\x12\x04\xdc\x02\x04\x13\n\x11\n\x07\x04\x11\x03\0\x02\x02\
    \x04\x12\x06\xdc\x02\x04\xdb\x02\x1e\n\x0f\n\x07\x04\x11\x03\0\x02\x02\
    \x05\x12\x04\xdc\x02\x04\t\n\x0f\n\x07\x04\x11\x03\0\x02\x02\x01\x12\x04\
    \xdc\x02\n\x0e\n\x0f\n\x07\x04\x11\x03\0\x02\x02\x03\x12\x04\xdc\x02\x11\
    \x12\n\x0c\n\x04\x04\x11\x02\0\x12\x04\xde\x02\x02\x0f\n\x0f\n\x05\x04\
    \x11\x02\0\x04\x12\x06\xde\x02\x02\xdd\x02\x03\n\r\n\x05\x04\x11\x02\0\
    \x05\x12\x04\xde\x02\x02\x07\n\r\n\x05\x04\x11\x02\0\x01\x12\x04\xde\x02\
    \x08\n\n\r\n\x05\x04\x11\x02\0\x03\x12\x04\xde\x02\r\x0e\n\x0c\n\x04\x04\
    \x11\x02\x01\x12\x04\xdf\x02\x02\x10\n\x0f\n\x05\x04\x11\x02\x01\x04\x12\
    \x06\xdf\x02\x02\xde\x02\x0f\n\r\n\x05\x04\x11\x02\x01\x05\x12\x04\xdf\
    \x02\x02\x07\n\r\n\x05\x04\x11\x02\x01\x01\x12\x04\xdf\x02\x08\x0b\n\r\n\
    \x05\x04\x11\x02\x01\x03\x12\x04\xdf\x02\x0e\x0f\n\x0c\n\x04\x04\x11\x02\
    \x02\x12\x04\xe0\x02\x02\x18\n\x0f\n\x05\x04\x11\x02\x02\x04\x12\x06\xe0\
    \x02\x02\xdf\x02\x10\n\r\n\x05\x04\x11\x02\x02\x05\x12\x04\xe0\x02\x02\
    \x07\n\r\n\x05\x04\x11\x02\x02\x01\x12\x04\xe0\x02\x08\x13\n\r\n\x05\x04\
    \x11\x02\x02\x03\x12\x04\xe0\x02\x16\x17\n\x0c\n\x04\x04\x11\x02\x03\x12\
    \x04\xe1\x02\x02\x1b\n\x0f\n\x05\x04\x11\x02\x03\x04\x12\x06\xe1\x02\x02\
    \xe0\x02\x18\n\r\n\x05\x04\x11\x02\x03\x05\x12\x04\xe1\x02\x02\x07\n\r\n\
    \x05\x04\x11\x02\x03\x01\x12\x04\xe1\x02\x08\x16\n\r\n\x05\x04\x11\x02\
    \x03\x03\x12\x04\xe1\x02\x19\x1a\n\x0c\n\x04\x04\x11\x02\x04\x12\x04\xe2\
    \x02\x02$\n\r\n\x05\x04\x11\x02\x04\x04\x12\x04\xe2\x02\x02\n\n\r\n\x05\
    \x04\x11\x02\x04\x05\x12\x04\xe2\x02\x0b\x10\n\r\n\x05\x04\x11\x02\x04\
    \x01\x12\x04\xe2\x02\x11\x1f\n\r\n\x05\x04\x11\x02\x04\x03\x12\x04\xe2\
    \x02\"#\n\x0c\n\x04\x04\x11\x02\x05\x12\x04\xe3\x02\x02\x1d\n\x0f\n\x05\
    \x04\x11\x02\x05\x04\x12\x06\xe3\x02\x02\xe2\x02$\n\r\n\x05\x04\x11\x02\
    \x05\x05\x12\x04\xe3\x02\x02\x07\n\r\n\x05\x04\x11\x02\x05\x01\x12\x04\
    \xe3\x02\x08\x18\n\r\n\x05\x04\x11\x02\x05\x03\x12\x04\xe3\x02\x1b\x1c\n\
    \x0c\n\x04\x04\x11\x02\x06\x12\x04\xe4\x02\x02\x1e\n\x0f\n\x05\x04\x11\
    \x02\x06\x04\x12\x06\xe4\x02\x02\xe3\x02\x1d\n\r\n\x05\x04\x11\x02\x06\
    \x06\x12\x04\xe4\x02\x02\x11\n\r\n\x05\x04\x11\x02\x06\x01\x12\x04\xe4\
    \x02\x12\x19\n\r\n\x05\x04\x11\x02\x06\x03\x12\x04\xe4\x02\x1c\x1d\n\x0c\
    \n\x04\x04\x11\x02\x07\x12\x04\xe5\x02\x02\x17\n\r\n\x05\x04\x11\x02\x07\
    \x04\x12\x04\xe5\x02\x02\n\n\r\n\x05\x04\x11\x02\x07\x06\x12\x04\xe5\x02\
    \x0b\x0e\n\r\n\x05\x04\x11\x02\x07\x01\x12\x04\xe5\x02\x0f\x12\n\r\n\x05\
    \x04\x11\x02\x07\x03\x12\x04\xe5\x02\x15\x16\n\x0c\n\x04\x04\x11\x02\x08\
    \x12\x04\xe6\x02\x02\x12\n\x0f\n\x05\x04\x11\x02\x08\x04\x12\x06\xe6\x02\
    \x02\xe5\x02\x17\n\r\n\x05\x04\x11\x02\x08\x06\x12\x04\xe6\x02\x02\x06\n\
    \r\n\x05\x04\x11\x02\x08\x01\x12\x04\xe6\x02\x07\r\n\r\n\x05\x04\x11\x02\
    \x08\x03\x12\x04\xe6\x02\x10\x11\n\x0c\n\x04\x04\x11\x02\t\x12\x04\xe7\
    \x02\x02\x18\n\x0f\n\x05\x04\x11\x02\t\x04\x12\x06\xe7\x02\x02\xe6\x02\
    \x12\n\r\n\x05\x04\x11\x02\t\x05\x12\x04\xe7\x02\x02\x07\n\r\n\x05\x04\
    \x11\x02\t\x01\x12\x04\xe7\x02\x08\x12\n\r\n\x05\x04\x11\x02\t\x03\x12\
    \x04\xe7\x02\x15\x17\n\x0c\n\x04\x04\x11\x02\n\x12\x04\xe9\x02\x02\x1b\n\
    \x0f\n\x05\x04\x11\x02\n\x04\x12\x06\xe9\x02\x02\xe7\x02\x18\n\r\n\x05\
    \x04\x11\x02\n\x05\x12\x04\xe9\x02\x02\x08\n\r\n\x05\x04\x11\x02\n\x01\
    \x12\x04\xe9\x02\t\x15\n\r\n\x05\x04\x11\x02\n\x03\x12\x04\xe9\x02\x18\
    \x1a\n\x0c\n\x04\x04\x11\x02\x0b\x12\x04\xea\x02\x02\x1d\n\x0f\n\x05\x04\
    \x11\x02\x0b\x04\x12\x06\xea\x02\x02\xe9\x02\x1b\n\r\n\x05\x04\x11\x02\
    \x0b\x05\x12\x04\xea\x02\x02\x07\n\r\n\x05\x04\x11\x02\x0b\x01\x12\x04\
    \xea\x02\x08\x17\n\r\n\x05\x04\x11\x02\x0b\x03\x12\x04\xea\x02\x1a\x1c\n\
    \x0c\n\x04\x04\x11\x02\x0c\x12\x04\xeb\x02\x02\x1d\n\x0f\n\x05\x04\x11\
    \x02\x0c\x04\x12\x06\xeb\x02\x02\xea\x02\x1d\n\r\n\x05\x04\x11\x02\x0c\
    \x05\x12\x04\xeb\x02\x02\x07\n\r\n\x05\x04\x11\x02\x0c\x01\x12\x04\xeb\
    \x02\x08\x17\n\r\n\x05\x04\x11\x02\x0c\x03\x12\x04\xeb\x02\x1a\x1c\n\x0c\
    \n\x04\x04\x11\x02\r\x12\x04\xec\x02\x02:\n\r\n\x05\x04\x11\x02\r\x04\
    \x12\x04\xec\x02\x02\n\n\r\n\x05\x04\x11\x02\r\x06\x12\x04\xec\x02\x0b\
    \x1e\n\r\n\x05\x04\x11\x02\r\x01\x12\x04\xec\x02\x1f4\n\r\n\x05\x04\x11\
    \x02\r\x03\x12\x04\xec\x0279\n\x0c\n\x04\x04\x11\x02\x0e\x12\x04\xed\x02\
    \x02&\n\x0f\n\x05\x04\x11\x02\x0e\x04\x12\x06\xed\x02\x02\xec\x02:\n\r\n\
    \x05\x04\x11\x02\x0e\x05\x12\x04\xed\x02\x02\x07\n\r\n\x05\x04\x11\x02\
    \x0e\x01\x12\x04\xed\x02\x08\x20\n\r\n\x05\x04\x11\x02\x0e\x03\x12\x04\
    \xed\x02#%\n\x0c\n\x04\x04\x11\x02\x0f\x12\x04\xee\x02\x02,\n\x0f\n\x05\
    \x04\x11\x02\x0f\x04\x12\x06\xee\x02\x02\xed\x02&\n\r\n\x05\x04\x11\x02\
    \x0f\x05\x12\x04\xee\x02\x02\x07\n\r\n\x05\x04\x11\x02\x0f\x01\x12\x04\
    \xee\x02\x08&\n\r\n\x05\x04\x11\x02\x0f\x03\x12\x04\xee\x02)+\n\x0c\n\
    \x04\x04\x11\x02\x10\x12\x04\xef\x02\x02.\n\x0f\n\x05\x04\x11\x02\x10\
    \x04\x12\x06\xef\x02\x02\xee\x02,\n\r\n\x05\x04\x11\x02\x10\x05\x12\x04\
    \xef\x02\x02\x07\n\r\n\x05\x04\x11\x02\x10\x01\x12\x04\xef\x02\x08(\n\r\
    \n\x05\x04\x11\x02\x10\x03\x12\x04\xef\x02+-\n\x0c\n\x04\x04\x11\x02\x11\
    \x12\x04\xf0\x02\x02\x19\n\x0f\n\x05\x04\x11\x02\x11\x04\x12\x06\xf0\x02\
    \x02\xef\x02.\n\r\n\x05\x04\x11\x02\x11\x05\x12\x04\xf0\x02\x02\x07\n\r\
    \n\x05\x04\x11\x02\x11\x01\x12\x04\xf0\x02\x08\x13\n\r\n\x05\x04\x11\x02\
    \x11\x03\x12\x04\xf0\x02\x16\x18\n\x0c\n\x02\x04\x12\x12\x06\xf3\x02\0\
    \xf7\x02\x01\n\x0b\n\x03\x04\x12\x01\x12\x04\xf3\x02\x08\x16\n\x0c\n\x04\
    \x04\x12\x02\0\x12\x04\xf4\x02\x02\x18\n\x0f\n\x05\x04\x12\x02\0\x04\x12\
    \x06\xf4\x02\x02\xf3\x02\x18\n\r\n\x05\x04\x12\x02\0\x05\x12\x04\xf4\x02\
    \x02\x07\n\r\n\x05\x04\x12\x02\0\x01\x12\x04\xf4\x02\x08\x13\n\r\n\x05\
    \x04\x12\x02\0\x03\x12\x04\xf4\x02\x16\x17\n\x0c\n\x04\x04\x12\x02\x01\
    \x12\x04\xf5\x02\x02\x1b\n\x0f\n\x05\x04\x12\x02\x01\x04\x12\x06\xf5\x02\
    \x02\xf4\x02\x18\n\r\n\x05\x04\x12\x02\x01\x05\x12\x04\xf5\x02\x02\x07\n\
    \r\n\x05\x04\x12\x02\x01\x01\x12\x04\xf5\x02\x08\x16\n\r\n\x05\x04\x12\
    \x02\x01\x03\x12\x04\xf5\x02\x19\x1a\n\x0c\n\x04\x04\x12\x02\x02\x12\x04\
    \xf6\x02\x02/\n\r\n\x05\x04\x12\x02\x02\x04\x12\x04\xf6\x02\x02\n\n\r\n\
    \x05\x04\x12\x02\x02\x06\x12\x04\xf6\x02\x0b\x1a\n\r\n\x05\x04\x12\x02\
    \x02\x01\x12\x04\xf6\x02\x1b*\n\r\n\x05\x04\x12\x02\x02\x03\x12\x04\xf6\
    \x02-.\n\x0c\n\x02\x04\x13\x12\x06\xf9\x02\0\xfb\x02\x01\n\x0b\n\x03\x04\
    \x13\x01\x12\x04\xf9\x02\x08\x14\n\x0c\n\x04\x04\x13\x02\0\x12\x04\xfa\
    \x02\x02(\n\r\n\x05\x04\x13\x02\0\x04\x12\x04\xfa\x02\x02\n\n\r\n\x05\
    \x04\x13\x02\0\x06\x12\x04\xfa\x02\x0b\x16\n\r\n\x05\x04\x13\x02\0\x01\
    \x12\x04\xfa\x02\x17#\n\r\n\x05\x04\x13\x02\0\x03\x12\x04\xfa\x02&'\n\
    \x0c\n\x02\x04\x14\x12\x06\xfd\x02\0\x80\x03\x01\n\x0b\n\x03\x04\x14\x01\
    \x12\x04\xfd\x02\x08\x17\n\x0c\n\x04\x04\x14\x02\0\x12\x04\xfe\x02\x02\
    \x1e\n\x0f\n\x05\x04\x14\x02\0\x04\x12\x06\xfe\x02\x02\xfd\x02\x19\n\r\n\
    \x05\x04\x14\x02\0\x06\x12\x04\xfe\x02\x02\r\n\r\n\x05\x04\x14\x02\0\x01\
    \x12\x04\xfe\x02\x0e\x19\n\r\n\x05\x04\x14\x02\0\x03\x12\x04\xfe\x02\x1c\
    \x1d\n\x0c\n\x04\x04\x14\x02\x01\x12\x04\xff\x02\x02\x17\n\x0f\n\x05\x04\
    \x14\x02\x01\x04\x12\x06\xff\x02\x02\xfe\x02\x1e\n\r\n\x05\x04\x14\x02\
    \x01\x05\x12\x04\xff\x02\x02\x07\n\r\n\x05\x04\x14\x02\x01\x01\x12\x04\
    \xff\x02\x08\x12\n\r\n\x05\x04\x14\x02\x01\x03\x12\x04\xff\x02\x15\x16\n\
    \x0c\n\x02\x04\x15\x12\x06\x82\x03\0\x91\x03\x01\n\x0b\n\x03\x04\x15\x01\
    \x12\x04\x82\x03\x08\x13\n\x0e\n\x04\x04\x15\x03\0\x12\x06\x83\x03\x02\
    \x8e\x03\x03\n\r\n\x05\x04\x15\x03\0\x01\x12\x04\x83\x03\n\r\n\x0e\n\x06\
    \x04\x15\x03\0\x02\0\x12\x04\x84\x03\x04\x18\n\x11\n\x07\x04\x15\x03\0\
    \x02\0\x04\x12\x06\x84\x03\x04\x83\x03\x0f\n\x0f\n\x07\x04\x15\x03\0\x02\
    \0\x05\x12\x04\x84\x03\x04\t\n\x0f\n\x07\x04\x15\x03\0\x02\0\x01\x12\x04\
    \x84\x03\n\x13\n\x0f\n\x07\x04\x15\x03\0\x02\0\x03\x12\x04\x84\x03\x16\
    \x17\n\x0e\n\x06\x04\x15\x03\0\x02\x01\x12\x04\x85\x03\x04\x19\n\x11\n\
    \x07\x04\x15\x03\0\x02\x01\x04\x12\x06\x85\x03\x04\x84\x03\x18\n\x0f\n\
    \x07\x04\x15\x03\0\x02\x01\x05\x12\x04\x85\x03\x04\t\n\x0f\n\x07\x04\x15\
    \x03\0\x02\x01\x01\x12\x04\x85\x03\n\x14\n\x0f\n\x07\x04\x15\x03\0\x02\
    \x01\x03\x12\x04\x85\x03\x17\x18\n\x0e\n\x06\x04\x15\x03\0\x02\x02\x12\
    \x04\x86\x03\x04\x19\n\x11\n\x07\x04\x15\x03\0\x02\x02\x04\x12\x06\x86\
    \x03\x04\x85\x03\x19\n\x0f\n\x07\x04\x15\x03\0\x02\x02\x05\x12\x04\x86\
    \x03\x04\t\n\x0f\n\x07\x04\x15\x03\0\x02\x02\x01\x12\x04\x86\x03\n\x14\n\
    \x0f\n\x07\x04\x15\x03\0\x02\x02\x03\x12\x04\x86\x03\x17\x18\n7\n\x06\
    \x04\x15\x03\0\x02\x03\x12\x04\x89\x03\x04\x15\x1a'bytes\x20nonce\x20=\
    \x205;\nbytes\x20difficulty\x20=\x206;\n\n\x11\n\x07\x04\x15\x03\0\x02\
    \x03\x04\x12\x06\x89\x03\x04\x86\x03\x19\n\x0f\n\x07\x04\x15\x03\0\x02\
    \x03\x05\x12\x04\x89\x03\x04\t\n\x0f\n\x07\x04\x15\x03\0\x02\x03\x01\x12\
    \x04\x89\x03\n\x10\n\x0f\n\x07\x04\x15\x03\0\x02\x03\x03\x12\x04\x89\x03\
    \x13\x14\n\x0e\n\x06\x04\x15\x03\0\x02\x04\x12\x04\x8a\x03\x04\x19\n\x11\
    \n\x07\x04\x15\x03\0\x02\x04\x04\x12\x06\x8a\x03\x04\x89\x03\x15\n\x0f\n\
    \x07\x04\x15\x03\0\x02\x04\x05\x12\x04\x8a\x03\x04\t\n\x0f\n\x07\x04\x15\
    \x03\0\x02\x04\x01\x12\x04\x8a\x03\n\x14\n\x0f\n\x07\x04\x15\x03\0\x02\
    \x04\x03\x12\x04\x8a\x03\x17\x18\n\x0e\n\x06\x04\x15\x03\0\x02\x05\x12\
    \x04\x8b\x03\x04\x1e\n\x11\n\x07\x04\x15\x03\0\x02\x05\x04\x12\x06\x8b\
    \x03\x04\x8a\x03\x19\n\x0f\n\x07\x04\x15\x03\0\x02\x05\x05\x12\x04\x8b\
    \x03\x04\t\n\x0f\n\x07\x04\x15\x03\0\x02\x05\x01\x12\x04\x8b\x03\n\x19\n\
    \x0f\n\x07\x04\x15\x03\0\x02\x05\x03\x12\x04\x8b\x03\x1c\x1d\n\x0e\n\x06\
    \x04\x15\x03\0\x02\x06\x12\x04\x8c\x03\x04\x17\n\x11\n\x07\x04\x15\x03\0\
    \x02\x06\x04\x12\x06\x8c\x03\x04\x8b\x03\x1e\n\x0f\n\x07\x04\x15\x03\0\
    \x02\x06\x05\x12\x04\x8c\x03\x04\t\n\x0f\n\x07\x04\x15\x03\0\x02\x06\x01\
    \x12\x04\x8c\x03\n\x11\n\x0f\n\x07\x04\x15\x03\0\x02\x06\x03\x12\x04\x8c\
    \x03\x14\x16\n\x0e\n\x06\x04\x15\x03\0\x02\x07\x12\x04\x8d\x03\x04\x20\n\
    \x11\n\x07\x04\x15\x03\0\x02\x07\x04\x12\x06\x8d\x03\x04\x8c\x03\x17\n\
    \x0f\n\x07\x04\x15\x03\0\x02\x07\x05\x12\x04\x8d\x03\x04\t\n\x0f\n\x07\
    \x04\x15\x03\0\x02\x07\x01\x12\x04\x8d\x03\n\x1a\n\x0f\n\x07\x04\x15\x03\
    \0\x02\x07\x03\x12\x04\x8d\x03\x1d\x1f\n\x0c\n\x04\x04\x15\x02\0\x12\x04\
    \x8f\x03\x02\x13\n\x0f\n\x05\x04\x15\x02\0\x04\x12\x06\x8f\x03\x02\x8e\
    \x03\x03\n\r\n\x05\x04\x15\x02\0\x06\x12\x04\x8f\x03\x02\x05\n\r\n\x05\
    \x04\x15\x02\0\x01\x12\x04\x8f\x03\x06\x0e\n\r\n\x05\x04\x15\x02\0\x03\
    \x12\x04\x8f\x03\x11\x12\n\x0c\n\x04\x04\x15\x02\x01\x12\x04\x90\x03\x02\
    \x1e\n\x0f\n\x05\x04\x15\x02\x01\x04\x12\x06\x90\x03\x02\x8f\x03\x13\n\r\
    \n\x05\x04\x15\x02\x01\x05\x12\x04\x90\x03\x02\x07\n\r\n\x05\x04\x15\x02\
    \x01\x01\x12\x04\x90\x03\x08\x19\n\r\n\x05\x04\x15\x02\x01\x03\x12\x04\
    \x90\x03\x1c\x1d\n\x15\n\x02\x04\x16\x12\x06\x94\x03\0\x97\x03\x01\x1a\
    \x07\x20block\n\n\x0b\n\x03\x04\x16\x01\x12\x04\x94\x03\x08\r\n\x0c\n\
    \x04\x04\x16\x02\0\x12\x04\x95\x03\x02(\n\r\n\x05\x04\x16\x02\0\x04\x12\
    \x04\x95\x03\x02\n\n\r\n\x05\x04\x16\x02\0\x06\x12\x04\x95\x03\x0b\x16\n\
    \r\n\x05\x04\x16\x02\0\x01\x12\x04\x95\x03\x17#\n\r\n\x05\x04\x16\x02\0\
    \x03\x12\x04\x95\x03&'\n\x0c\n\x04\x04\x16\x02\x01\x12\x04\x96\x03\x02\
    \x1f\n\x0f\n\x05\x04\x16\x02\x01\x04\x12\x06\x96\x03\x02\x95\x03(\n\r\n\
    \x05\x04\x16\x02\x01\x06\x12\x04\x96\x03\x02\r\n\r\n\x05\x04\x16\x02\x01\
    \x01\x12\x04\x96\x03\x0e\x1a\n\r\n\x05\x04\x16\x02\x01\x03\x12\x04\x96\
    \x03\x1d\x1e\n\x0c\n\x02\x04\x17\x12\x06\x99\x03\0\xa0\x03\x01\n\x0b\n\
    \x03\x04\x17\x01\x12\x04\x99\x03\x08\x16\n\x0e\n\x04\x04\x17\x03\0\x12\
    \x06\x9a\x03\x02\x9d\x03\x03\n\r\n\x05\x04\x17\x03\0\x01\x12\x04\x9a\x03\
    \n\x11\n\x0e\n\x06\x04\x17\x03\0\x02\0\x12\x04\x9b\x03\x04\x13\n\x11\n\
    \x07\x04\x17\x03\0\x02\0\x04\x12\x06\x9b\x03\x04\x9a\x03\x13\n\x0f\n\x07\
    \x04\x17\x03\0\x02\0\x05\x12\x04\x9b\x03\x04\t\n\x0f\n\x07\x04\x17\x03\0\
    \x02\0\x01\x12\x04\x9b\x03\n\x0e\n\x0f\n\x07\x04\x17\x03\0\x02\0\x03\x12\
    \x04\x9b\x03\x11\x12\n\x0e\n\x06\x04\x17\x03\0\x02\x01\x12\x04\x9c\x03\
    \x04\x15\n\x11\n\x07\x04\x17\x03\0\x02\x01\x04\x12\x06\x9c\x03\x04\x9b\
    \x03\x13\n\x0f\n\x07\x04\x17\x03\0\x02\x01\x05\x12\x04\x9c\x03\x04\t\n\
    \x0f\n\x07\x04\x17\x03\0\x02\x01\x01\x12\x04\x9c\x03\n\x10\n\x0f\n\x07\
    \x04\x17\x03\0\x02\x01\x03\x12\x04\x9c\x03\x13\x14\n\x0c\n\x04\x04\x17\
    \x02\0\x12\x04\x9e\x03\x02\x1b\n\r\n\x05\x04\x17\x02\0\x04\x12\x04\x9e\
    \x03\x02\n\n\r\n\x05\x04\x17\x02\0\x06\x12\x04\x9e\x03\x0b\x12\n\r\n\x05\
    \x04\x17\x02\0\x01\x12\x04\x9e\x03\x13\x16\n\r\n\x05\x04\x17\x02\0\x03\
    \x12\x04\x9e\x03\x19\x1a\n\x0c\n\x04\x04\x17\x02\x01\x12\x04\x9f\x03\x02\
    \x17\n\x0f\n\x05\x04\x17\x02\x01\x04\x12\x06\x9f\x03\x02\x9e\x03\x1b\n\r\
    \n\x05\x04\x17\x02\x01\x05\x12\x04\x9f\x03\x02\x07\n\r\n\x05\x04\x17\x02\
    \x01\x01\x12\x04\x9f\x03\x08\x12\n\r\n\x05\x04\x17\x02\x01\x03\x12\x04\
    \x9f\x03\x15\x16\n\x19\n\x02\x04\x18\x12\x06\xa3\x03\0\xb0\x03\x01\x1a\
    \x0b\x20Inventory\n\n\x0b\n\x03\x04\x18\x01\x12\x04\xa3\x03\x08\x16\n\
    \x0e\n\x04\x04\x18\x04\0\x12\x06\xa4\x03\x02\xa8\x03\x03\n\r\n\x05\x04\
    \x18\x04\0\x01\x12\x04\xa4\x03\x07\x0b\n\x0e\n\x06\x04\x18\x04\0\x02\0\
    \x12\x04\xa5\x03\x04\r\n\x0f\n\x07\x04\x18\x04\0\x02\0\x01\x12\x04\xa5\
    \x03\x04\x08\n\x0f\n\x07\x04\x18\x04\0\x02\0\x02\x12\x04\xa5\x03\x0b\x0c\
    \n\x0e\n\x06\x04\x18\x04\0\x02\x01\x12\x04\xa6\x03\x04\x10\n\x0f\n\x07\
    \x04\x18\x04\0\x02\x01\x01\x12\x04\xa6\x03\x04\x0b\n\x0f\n\x07\x04\x18\
    \x04\0\x02\x01\x02\x12\x04\xa6\x03\x0e\x0f\n\x0e\n\x06\x04\x18\x04\0\x02\
    \x02\x12\x04\xa7\x03\x04\x0e\n\x0f\n\x07\x04\x18\x04\0\x02\x02\x01\x12\
    \x04\xa7\x03\x04\t\n\x0f\n\x07\x04\x18\x04\0\x02\x02\x02\x12\x04\xa7\x03\
    \x0c\r\n\x0e\n\x04\x04\x18\x03\0\x12\x06\xaa\x03\x02\xad\x03\x03\n\r\n\
    \x05\x04\x18\x03\0\x01\x12\x04\xaa\x03\n\x11\n\x0e\n\x06\x04\x18\x03\0\
    \x02\0\x12\x04\xab\x03\x04\x13\n\x11\n\x07\x04\x18\x03\0\x02\0\x04\x12\
    \x06\xab\x03\x04\xaa\x03\x13\n\x0f\n\x07\x04\x18\x03\0\x02\0\x05\x12\x04\
    \xab\x03\x04\t\n\x0f\n\x07\x04\x18\x03\0\x02\0\x01\x12\x04\xab\x03\n\x0e\
    \n\x0f\n\x07\x04\x18\x03\0\x02\0\x03\x12\x04\xab\x03\x11\x12\n\x0e\n\x06\
    \x04\x18\x03\0\x02\x01\x12\x04\xac\x03\x04\x15\n\x11\n\x07\x04\x18\x03\0\
    \x02\x01\x04\x12\x06\xac\x03\x04\xab\x03\x13\n\x0f\n\x07\x04\x18\x03\0\
    \x02\x01\x05\x12\x04\xac\x03\x04\t\n\x0f\n\x07\x04\x18\x03\0\x02\x01\x01\
    \x12\x04\xac\x03\n\x10\n\x0f\n\x07\x04\x18\x03\0\x02\x01\x03\x12\x04\xac\
    \x03\x13\x14\n\x0c\n\x04\x04\x18\x02\0\x12\x04\xae\x03\x02\x1b\n\r\n\x05\
    \x04\x18\x02\0\x04\x12\x04\xae\x03\x02\n\n\r\n\x05\x04\x18\x02\0\x06\x12\
    \x04\xae\x03\x0b\x12\n\r\n\x05\x04\x18\x02\0\x01\x12\x04\xae\x03\x13\x16\
    \n\r\n\x05\x04\x18\x02\0\x03\x12\x04\xae\x03\x19\x1a\n\x0c\n\x04\x04\x18\
    \x02\x01\x12\x04\xaf\x03\x02\x10\n\x0f\n\x05\x04\x18\x02\x01\x04\x12\x06\
    \xaf\x03\x02\xae\x03\x1b\n\r\n\x05\x04\x18\x02\x01\x06\x12\x04\xaf\x03\
    \x02\x06\n\r\n\x05\x04\x18\x02\x01\x01\x12\x04\xaf\x03\x07\x0b\n\r\n\x05\
    \x04\x18\x02\x01\x03\x12\x04\xaf\x03\x0e\x0f\n\x0c\n\x02\x04\x19\x12\x06\
    \xb2\x03\0\xb9\x03\x01\n\x0b\n\x03\x04\x19\x01\x12\x04\xb2\x03\x08\x11\n\
    \x0e\n\x04\x04\x19\x04\0\x12\x06\xb3\x03\x02\xb6\x03\x03\n\r\n\x05\x04\
    \x19\x04\0\x01\x12\x04\xb3\x03\x07\x14\n\x0e\n\x06\x04\x19\x04\0\x02\0\
    \x12\x04\xb4\x03\x04\x0c\n\x0f\n\x07\x04\x19\x04\0\x02\0\x01\x12\x04\xb4\
    \x03\x04\x07\n\x0f\n\x07\x04\x19\x04\0\x02\0\x02\x12\x04\xb4\x03\n\x0b\n\
    \x0e\n\x06\x04\x19\x04\0\x02\x01\x12\x04\xb5\x03\x04\x0e\n\x0f\n\x07\x04\
    \x19\x04\0\x02\x01\x01\x12\x04\xb5\x03\x04\t\n\x0f\n\x07\x04\x19\x04\0\
    \x02\x01\x02\x12\x04\xb5\x03\x0c\r\n\x0c\n\x04\x04\x19\x02\0\x12\x04\xb7\
    \x03\x02\x19\n\x0f\n\x05\x04\x19\x02\0\x04\x12\x06\xb7\x03\x02\xb6\x03\
    \x03\n\r\n\x05\x04\x19\x02\0\x06\x12\x04\xb7\x03\x02\x0f\n\r\n\x05\x04\
    \x19\x02\0\x01\x12\x04\xb7\x03\x10\x14\n\r\n\x05\x04\x19\x02\0\x03\x12\
    \x04\xb7\x03\x17\x18\n\x0c\n\x04\x04\x19\x02\x01\x12\x04\xb8\x03\x02\x19\
    \n\r\n\x05\x04\x19\x02\x01\x04\x12\x04\xb8\x03\x02\n\n\r\n\x05\x04\x19\
    \x02\x01\x05\x12\x04\xb8\x03\x0b\x10\n\r\n\x05\x04\x19\x02\x01\x01\x12\
    \x04\xb8\x03\x11\x14\n\r\n\x05\x04\x19\x02\x01\x03\x12\x04\xb8\x03\x17\
    \x18\n\x0c\n\x02\x04\x1a\x12\x06\xbb\x03\0\xc7\x03\x01\n\x0b\n\x03\x04\
    \x1a\x01\x12\x04\xbb\x03\x08\r\n\x0e\n\x04\x04\x1a\x04\0\x12\x06\xbc\x03\
    \x02\xc1\x03\x03\n\r\n\x05\x04\x1a\x04\0\x01\x12\x04\xbc\x03\x07\x0f\n\
    \x0e\n\x06\x04\x1a\x04\0\x02\0\x12\x04\xbd\x03\x04\x0c\n\x0f\n\x07\x04\
    \x1a\x04\0\x02\0\x01\x12\x04\xbd\x03\x04\x07\n\x0f\n\x07\x04\x1a\x04\0\
    \x02\0\x02\x12\x04\xbd\x03\n\x0b\n\x0e\n\x06\x04\x1a\x04\0\x02\x01\x12\
    \x04\xbe\x03\x04\x0c\n\x0f\n\x07\x04\x1a\x04\0\x02\x01\x01\x12\x04\xbe\
    \x03\x04\x07\n\x0f\n\x07\x04\x1a\x04\0\x02\x01\x02\x12\x04\xbe\x03\n\x0b\
    \n\x0e\n\x06\x04\x1a\x04\0\x02\x02\x12\x04\xbf\x03\x04\x0e\n\x0f\n\x07\
    \x04\x1a\x04\0\x02\x02\x01\x12\x04\xbf\x03\x04\t\n\x0f\n\x07\x04\x1a\x04\
    \0\x02\x02\x02\x12\x04\xbf\x03\x0c\r\n\x0e\n\x06\x04\x1a\x04\0\x02\x03\
    \x12\x04\xc0\x03\x04\x14\n\x0f\n\x07\x04\x1a\x04\0\x02\x03\x01\x12\x04\
    \xc0\x03\x04\x0f\n\x0f\n\x07\x04\x1a\x04\0\x02\x03\x02\x12\x04\xc0\x03\
    \x12\x13\n\x0c\n\x04\x04\x1a\x02\0\x12\x04\xc3\x03\x02\x14\n\x0f\n\x05\
    \x04\x1a\x02\0\x04\x12\x06\xc3\x03\x02\xc1\x03\x03\n\r\n\x05\x04\x1a\x02\
    \0\x06\x12\x04\xc3\x03\x02\n\n\r\n\x05\x04\x1a\x02\0\x01\x12\x04\xc3\x03\
    \x0b\x0f\n\r\n\x05\x04\x1a\x02\0\x03\x12\x04\xc3\x03\x12\x13\n\x0c\n\x04\
    \x04\x1a\x02\x01\x12\x04\xc4\x03\x02\x1c\n\r\n\x05\x04\x1a\x02\x01\x04\
    \x12\x04\xc4\x03\x02\n\n\r\n\x05\x04\x1a\x02\x01\x06\x12\x04\xc4\x03\x0b\
    \x10\n\r\n\x05\x04\x1a\x02\x01\x01\x12\x04\xc4\x03\x11\x17\n\r\n\x05\x04\
    \x1a\x02\x01\x03\x12\x04\xc4\x03\x1a\x1b\n\x0c\n\x04\x04\x1a\x02\x02\x12\
    \x04\xc5\x03\x02)\n\r\n\x05\x04\x1a\x02\x02\x04\x12\x04\xc5\x03\x02\n\n\
    \r\n\x05\x04\x1a\x02\x02\x06\x12\x04\xc5\x03\x0b\x16\n\r\n\x05\x04\x1a\
    \x02\x02\x01\x12\x04\xc5\x03\x17$\n\r\n\x05\x04\x1a\x02\x02\x03\x12\x04\
    \xc5\x03'(\n\x0c\n\x04\x04\x1a\x02\x03\x12\x04\xc6\x03\x02(\n\r\n\x05\
    \x04\x1a\x02\x03\x04\x12\x04\xc6\x03\x02\n\n\r\n\x05\x04\x1a\x02\x03\x06\
    \x12\x04\xc6\x03\x0b\x16\n\r\n\x05\x04\x1a\x02\x03\x01\x12\x04\xc6\x03\
    \x17#\n\r\n\x05\x04\x1a\x02\x03\x03\x12\x04\xc6\x03&'\n!\n\x02\x04\x1b\
    \x12\x06\xca\x03\0\xcc\x03\x01\x1a\x13\x20DynamicProperties\n\n\x0b\n\
    \x03\x04\x1b\x01\x12\x04\xca\x03\x08\x19\n\x0c\n\x04\x04\x1b\x02\0\x12\
    \x04\xcb\x03\x02$\n\x0f\n\x05\x04\x1b\x02\0\x04\x12\x06\xcb\x03\x02\xca\
    \x03\x1b\n\r\n\x05\x04\x1b\x02\0\x05\x12\x04\xcb\x03\x02\x07\n\r\n\x05\
    \x04\x1b\x02\0\x01\x12\x04\xcb\x03\x08\x1f\n\r\n\x05\x04\x1b\x02\0\x03\
    \x12\x04\xcb\x03\"#\n\x0c\n\x02\x05\x01\x12\x06\xce\x03\0\xe7\x03\x01\n\
    \x0b\n\x03\x05\x01\x01\x12\x04\xce\x03\x05\x0f\n\x0c\n\x04\x05\x01\x02\0\
    \x12\x04\xcf\x03\x02\x13\n\r\n\x05\x05\x01\x02\0\x01\x12\x04\xcf\x03\x02\
    \x0b\n\r\n\x05\x05\x01\x02\0\x02\x12\x04\xcf\x03\x0e\x12\n\x0c\n\x04\x05\
    \x01\x02\x01\x12\x04\xd0\x03\x02\x16\n\r\n\x05\x05\x01\x02\x01\x01\x12\
    \x04\xd0\x03\x02\x0e\n\r\n\x05\x05\x01\x02\x01\x02\x12\x04\xd0\x03\x11\
    \x15\n\x0c\n\x04\x05\x01\x02\x02\x12\x04\xd1\x03\x02\x18\n\r\n\x05\x05\
    \x01\x02\x02\x01\x12\x04\xd1\x03\x02\x10\n\r\n\x05\x05\x01\x02\x02\x02\
    \x12\x04\xd1\x03\x13\x17\n\x0c\n\x04\x05\x01\x02\x03\x12\x04\xd2\x03\x02\
    \x18\n\r\n\x05\x05\x01\x02\x03\x01\x12\x04\xd2\x03\x02\x10\n\r\n\x05\x05\
    \x01\x02\x03\x02\x12\x04\xd2\x03\x13\x17\n\x0c\n\x04\x05\x01\x02\x04\x12\
    \x04\xd3\x03\x02\x1f\n\r\n\x05\x05\x01\x02\x04\x01\x12\x04\xd3\x03\x02\
    \x17\n\r\n\x05\x05\x01\x02\x04\x02\x12\x04\xd3\x03\x1a\x1e\n\x0c\n\x04\
    \x05\x01\x02\x05\x12\x04\xd4\x03\x02\x17\n\r\n\x05\x05\x01\x02\x05\x01\
    \x12\x04\xd4\x03\x02\x0f\n\r\n\x05\x05\x01\x02\x05\x02\x12\x04\xd4\x03\
    \x12\x16\n\x0c\n\x04\x05\x01\x02\x06\x12\x04\xd5\x03\x02\x16\n\r\n\x05\
    \x05\x01\x02\x06\x01\x12\x04\xd5\x03\x02\x0e\n\r\n\x05\x05\x01\x02\x06\
    \x02\x12\x04\xd5\x03\x11\x15\n\x0c\n\x04\x05\x01\x02\x07\x12\x04\xd6\x03\
    \x02\x1d\n\r\n\x05\x05\x01\x02\x07\x01\x12\x04\xd6\x03\x02\x15\n\r\n\x05\
    \x05\x01\x02\x07\x02\x12\x04\xd6\x03\x18\x1c\n\x0c\n\x04\x05\x01\x02\x08\
    \x12\x04\xd7\x03\x02\x18\n\r\n\x05\x05\x01\x02\x08\x01\x12\x04\xd7\x03\
    \x02\x10\n\r\n\x05\x05\x01\x02\x08\x02\x12\x04\xd7\x03\x13\x17\n\x0c\n\
    \x04\x05\x01\x02\t\x12\x04\xd8\x03\x02\x16\n\r\n\x05\x05\x01\x02\t\x01\
    \x12\x04\xd8\x03\x02\x0e\n\r\n\x05\x05\x01\x02\t\x02\x12\x04\xd8\x03\x11\
    \x15\n\x0c\n\x04\x05\x01\x02\n\x12\x04\xd9\x03\x02\x15\n\r\n\x05\x05\x01\
    \x02\n\x01\x12\x04\xd9\x03\x02\r\n\r\n\x05\x05\x01\x02\n\x02\x12\x04\xd9\
    \x03\x10\x14\n\x0c\n\x04\x05\x01\x02\x0b\x12\x04\xda\x03\x02\x0f\n\r\n\
    \x05\x05\x01\x02\x0b\x01\x12\x04\xda\x03\x02\x07\n\r\n\x05\x05\x01\x02\
    \x0b\x02\x12\x04\xda\x03\n\x0e\n\x0c\n\x04\x05\x01\x02\x0c\x12\x04\xdb\
    \x03\x02\x13\n\r\n\x05\x05\x01\x02\x0c\x01\x12\x04\xdb\x03\x02\x0b\n\r\n\
    \x05\x05\x01\x02\x0c\x02\x12\x04\xdb\x03\x0e\x12\n\x0c\n\x04\x05\x01\x02\
    \r\x12\x04\xdc\x03\x02\x14\n\r\n\x05\x05\x01\x02\r\x01\x12\x04\xdc\x03\
    \x02\x0c\n\r\n\x05\x05\x01\x02\r\x02\x12\x04\xdc\x03\x0f\x13\n\x0c\n\x04\
    \x05\x01\x02\x0e\x12\x04\xdd\x03\x02\x10\n\r\n\x05\x05\x01\x02\x0e\x01\
    \x12\x04\xdd\x03\x02\x08\n\r\n\x05\x05\x01\x02\x0e\x02\x12\x04\xdd\x03\
    \x0b\x0f\n\x0c\n\x04\x05\x01\x02\x0f\x12\x04\xde\x03\x02\x13\n\r\n\x05\
    \x05\x01\x02\x0f\x01\x12\x04\xde\x03\x02\x0b\n\r\n\x05\x05\x01\x02\x0f\
    \x02\x12\x04\xde\x03\x0e\x12\n\x0c\n\x04\x05\x01\x02\x10\x12\x04\xdf\x03\
    \x02\x10\n\r\n\x05\x05\x01\x02\x10\x01\x12\x04\xdf\x03\x02\x08\n\r\n\x05\
    \x05\x01\x02\x10\x02\x12\x04\xdf\x03\x0b\x0f\n\x0c\n\x04\x05\x01\x02\x11\
    \x12\x04\xe0\x03\x02\x14\n\r\n\x05\x05\x01\x02\x11\x01\x12\x04\xe0\x03\
    \x02\x0c\n\r\n\x05\x05\x01\x02\x11\x02\x12\x04\xe0\x03\x0f\x13\n\x0c\n\
    \x04\x05\x01\x02\x12\x12\x04\xe1\x03\x02\x1e\n\r\n\x05\x05\x01\x02\x12\
    \x01\x12\x04\xe1\x03\x02\x16\n\r\n\x05\x05\x01\x02\x12\x02\x12\x04\xe1\
    \x03\x19\x1d\n\x0c\n\x04\x05\x01\x02\x13\x12\x04\xe2\x03\x02\x1c\n\r\n\
    \x05\x05\x01\x02\x13\x01\x12\x04\xe2\x03\x02\x14\n\r\n\x05\x05\x01\x02\
    \x13\x02\x12\x04\xe2\x03\x17\x1b\n\x0c\n\x04\x05\x01\x02\x14\x12\x04\xe3\
    \x03\x02\x12\n\r\n\x05\x05\x01\x02\x14\x01\x12\x04\xe3\x03\x02\n\n\r\n\
    \x05\x05\x01\x02\x14\x02\x12\x04\xe3\x03\r\x11\n\x0c\n\x04\x05\x01\x02\
    \x15\x12\x04\xe4\x03\x02\x16\n\r\n\x05\x05\x01\x02\x15\x01\x12\x04\xe4\
    \x03\x02\x0e\n\r\n\x05\x05\x01\x02\x15\x02\x12\x04\xe4\x03\x11\x15\n\x0c\
    \n\x04\x05\x01\x02\x16\x12\x04\xe5\x03\x02%\n\r\n\x05\x05\x01\x02\x16\
    \x01\x12\x04\xe5\x03\x02\x1d\n\r\n\x05\x05\x01\x02\x16\x02\x12\x04\xe5\
    \x03\x20$\n\x0c\n\x04\x05\x01\x02\x17\x12\x04\xe6\x03\x02\x11\n\r\n\x05\
    \x05\x01\x02\x17\x01\x12\x04\xe6\x03\x02\t\n\r\n\x05\x05\x01\x02\x17\x02\
    \x12\x04\xe6\x03\x0c\x10\n\x0c\n\x02\x04\x1c\x12\x06\xe9\x03\0\xeb\x03\
    \x01\n\x0b\n\x03\x04\x1c\x01\x12\x04\xe9\x03\x08\x19\n\x0c\n\x04\x04\x1c\
    \x02\0\x12\x04\xea\x03\x02\x18\n\x0f\n\x05\x04\x1c\x02\0\x04\x12\x06\xea\
    \x03\x02\xe9\x03\x1b\n\r\n\x05\x04\x1c\x02\0\x06\x12\x04\xea\x03\x02\x0c\
    \n\r\n\x05\x04\x1c\x02\0\x01\x12\x04\xea\x03\r\x13\n\r\n\x05\x04\x1c\x02\
    \0\x03\x12\x04\xea\x03\x16\x17\n\x0c\n\x02\x04\x1d\x12\x06\xed\x03\0\xf9\
    \x03\x01\n\x0b\n\x03\x04\x1d\x01\x12\x04\xed\x03\x08\x14\n\x0e\n\x04\x04\
    \x1d\x03\0\x12\x06\xee\x03\x02\xf1\x03\x03\n\r\n\x05\x04\x1d\x03\0\x01\
    \x12\x04\xee\x03\n\x11\n\x0e\n\x06\x04\x1d\x03\0\x02\0\x12\x04\xef\x03\
    \x04\x13\n\x11\n\x07\x04\x1d\x03\0\x02\0\x04\x12\x06\xef\x03\x04\xee\x03\
    \x13\n\x0f\n\x07\x04\x1d\x03\0\x02\0\x05\x12\x04\xef\x03\x04\t\n\x0f\n\
    \x07\x04\x1d\x03\0\x02\0\x01\x12\x04\xef\x03\n\x0e\n\x0f\n\x07\x04\x1d\
    \x03\0\x02\0\x03\x12\x04\xef\x03\x11\x12\n\x0e\n\x06\x04\x1d\x03\0\x02\
    \x01\x12\x04\xf0\x03\x04\x15\n\x11\n\x07\x04\x1d\x03\0\x02\x01\x04\x12\
    \x06\xf0\x03\x04\xef\x03\x13\n\x0f\n\x07\x04\x1d\x03\0\x02\x01\x05\x12\
    \x04\xf0\x03\x04\t\n\x0f\n\x07\x04\x1d\x03\0\x02\x01\x01\x12\x04\xf0\x03\
    \n\x10\n\x0f\n\x07\x04\x1d\x03\0\x02\x01\x03\x12\x04\xf0\x03\x13\x14\n\
    \x0c\n\x04\x04\x1d\x02\0\x12\x04\xf3\x03\x02\x14\n\x0f\n\x05\x04\x1d\x02\
    \0\x04\x12\x06\xf3\x03\x02\xf1\x03\x03\n\r\n\x05\x04\x1d\x02\0\x06\x12\
    \x04\xf3\x03\x02\n\n\r\n\x05\x04\x1d\x02\0\x01\x12\x04\xf3\x03\x0b\x0f\n\
    \r\n\x05\x04\x1d\x02\0\x03\x12\x04\xf3\x03\x12\x13\n\x0c\n\x04\x04\x1d\
    \x02\x01\x12\x04\xf4\x03\x02\x14\n\x0f\n\x05\x04\x1d\x02\x01\x04\x12\x06\
    \xf4\x03\x02\xf3\x03\x14\n\r\n\x05\x04\x1d\x02\x01\x05\x12\x04\xf4\x03\
    \x02\x07\n\r\n\x05\x04\x1d\x02\x01\x01\x12\x04\xf4\x03\x08\x0f\n\r\n\x05\
    \x04\x1d\x02\x01\x03\x12\x04\xf4\x03\x12\x13\n\x0c\n\x04\x04\x1d\x02\x02\
    \x12\x04\xf5\x03\x02\x16\n\x0f\n\x05\x04\x1d\x02\x02\x04\x12\x06\xf5\x03\
    \x02\xf4\x03\x14\n\r\n\x05\x04\x1d\x02\x02\x05\x12\x04\xf5\x03\x02\x07\n\
    \r\n\x05\x04\x1d\x02\x02\x01\x12\x04\xf5\x03\x08\x11\n\r\n\x05\x04\x1d\
    \x02\x02\x03\x12\x04\xf5\x03\x14\x15\n\x0c\n\x04\x04\x1d\x02\x03\x12\x04\
    \xf6\x03\x02\x1d\n\x0f\n\x05\x04\x1d\x02\x03\x04\x12\x06\xf6\x03\x02\xf5\
    \x03\x16\n\r\n\x05\x04\x1d\x02\x03\x06\x12\x04\xf6\x03\x02\t\n\r\n\x05\
    \x04\x1d\x02\x03\x01\x12\x04\xf6\x03\n\x18\n\r\n\x05\x04\x1d\x02\x03\x03\
    \x12\x04\xf6\x03\x1b\x1c\n\x0c\n\x04\x04\x1d\x02\x04\x12\x04\xf7\x03\x02\
    \x1b\n\x0f\n\x05\x04\x1d\x02\x04\x04\x12\x06\xf7\x03\x02\xf6\x03\x1d\n\r\
    \n\x05\x04\x1d\x02\x04\x06\x12\x04\xf7\x03\x02\t\n\r\n\x05\x04\x1d\x02\
    \x04\x01\x12\x04\xf7\x03\n\x16\n\r\n\x05\x04\x1d\x02\x04\x03\x12\x04\xf7\
    \x03\x19\x1a\n\x0c\n\x04\x04\x1d\x02\x05\x12\x04\xf8\x03\x02\x1a\n\x0f\n\
    \x05\x04\x1d\x02\x05\x04\x12\x06\xf8\x03\x02\xf7\x03\x1b\n\r\n\x05\x04\
    \x1d\x02\x05\x06\x12\x04\xf8\x03\x02\t\n\r\n\x05\x04\x1d\x02\x05\x01\x12\
    \x04\xf8\x03\n\x15\n\r\n\x05\x04\x1d\x02\x05\x03\x12\x04\xf8\x03\x18\x19\
    \n\x0c\n\x02\x04\x1e\x12\x06\xfb\x03\0\xa8\x04\x01\n\x0b\n\x03\x04\x1e\
    \x01\x12\x04\xfb\x03\x08\x15\n\x0e\n\x04\x04\x1e\x03\0\x12\x06\xfc\x03\
    \x02\x9d\x04\x03\n\r\n\x05\x04\x1e\x03\0\x01\x12\x04\xfc\x03\n\r\n\x10\n\
    \x06\x04\x1e\x03\0\x03\0\x12\x06\xfd\x03\x04\x9b\x04\x05\n\x0f\n\x07\x04\
    \x1e\x03\0\x03\0\x01\x12\x04\xfd\x03\x0c\x11\n\x12\n\x08\x04\x1e\x03\0\
    \x03\0\x04\0\x12\x06\xfe\x03\x06\x84\x04\x07\n\x11\n\t\x04\x1e\x03\0\x03\
    \0\x04\0\x01\x12\x04\xfe\x03\x0b\x14\n\x12\n\n\x04\x1e\x03\0\x03\0\x04\0\
    \x02\0\x12\x04\xff\x03\x08\x1d\n\x13\n\x0b\x04\x1e\x03\0\x03\0\x04\0\x02\
    \0\x01\x12\x04\xff\x03\x08\x18\n\x13\n\x0b\x04\x1e\x03\0\x03\0\x04\0\x02\
    \0\x02\x12\x04\xff\x03\x1b\x1c\n\x12\n\n\x04\x1e\x03\0\x03\0\x04\0\x02\
    \x01\x12\x04\x80\x04\x08\x18\n\x13\n\x0b\x04\x1e\x03\0\x03\0\x04\0\x02\
    \x01\x01\x12\x04\x80\x04\x08\x13\n\x13\n\x0b\x04\x1e\x03\0\x03\0\x04\0\
    \x02\x01\x02\x12\x04\x80\x04\x16\x17\n\x12\n\n\x04\x1e\x03\0\x03\0\x04\0\
    \x02\x02\x12\x04\x81\x04\x08\x15\n\x13\n\x0b\x04\x1e\x03\0\x03\0\x04\0\
    \x02\x02\x01\x12\x04\x81\x04\x08\x10\n\x13\n\x0b\x04\x1e\x03\0\x03\0\x04\
    \0\x02\x02\x02\x12\x04\x81\x04\x13\x14\n\x12\n\n\x04\x1e\x03\0\x03\0\x04\
    \0\x02\x03\x12\x04\x82\x04\x08\x12\n\x13\n\x0b\x04\x1e\x03\0\x03\0\x04\0\
    \x02\x03\x01\x12\x04\x82\x04\x08\r\n\x13\n\x0b\x04\x1e\x03\0\x03\0\x04\0\
    \x02\x03\x02\x12\x04\x82\x04\x10\x11\n\x12\n\n\x04\x1e\x03\0\x03\0\x04\0\
    \x02\x04\x12\x04\x83\x04\x08\x15\n\x13\n\x0b\x04\x1e\x03\0\x03\0\x04\0\
    \x02\x04\x01\x12\x04\x83\x04\x08\x10\n\x13\n\x0b\x04\x1e\x03\0\x03\0\x04\
    \0\x02\x04\x02\x12\x04\x83\x04\x13\x14\n\x12\n\x08\x04\x1e\x03\0\x03\0\
    \x03\0\x12\x06\x85\x04\x06\x8a\x04\x07\n\x11\n\t\x04\x1e\x03\0\x03\0\x03\
    \0\x01\x12\x04\x85\x04\x0e\x13\n\x12\n\n\x04\x1e\x03\0\x03\0\x03\0\x02\0\
    \x12\x04\x86\x04\x08\x19\n\x15\n\x0b\x04\x1e\x03\0\x03\0\x03\0\x02\0\x04\
    \x12\x06\x86\x04\x08\x85\x04\x15\n\x13\n\x0b\x04\x1e\x03\0\x03\0\x03\0\
    \x02\0\x05\x12\x04\x86\x04\x08\x0c\n\x13\n\x0b\x04\x1e\x03\0\x03\0\x03\0\
    \x02\0\x01\x12\x04\x86\x04\r\x14\n\x13\n\x0b\x04\x1e\x03\0\x03\0\x03\0\
    \x02\0\x03\x12\x04\x86\x04\x17\x18\n\x12\n\n\x04\x1e\x03\0\x03\0\x03\0\
    \x02\x01\x12\x04\x87\x04\x08\x18\n\x15\n\x0b\x04\x1e\x03\0\x03\0\x03\0\
    \x02\x01\x04\x12\x06\x87\x04\x08\x86\x04\x19\n\x13\n\x0b\x04\x1e\x03\0\
    \x03\0\x03\0\x02\x01\x05\x12\x04\x87\x04\x08\x0e\n\x13\n\x0b\x04\x1e\x03\
    \0\x03\0\x03\0\x02\x01\x01\x12\x04\x87\x04\x0f\x13\n\x13\n\x0b\x04\x1e\
    \x03\0\x03\0\x03\0\x02\x01\x03\x12\x04\x87\x04\x16\x17\n,\n\n\x04\x1e\
    \x03\0\x03\0\x03\0\x02\x02\x12\x04\x88\x04\x08\x18\"\x18\x20SolidityType\
    \x20type\x20=\x203;\n\n\x15\n\x0b\x04\x1e\x03\0\x03\0\x03\0\x02\x02\x04\
    \x12\x06\x88\x04\x08\x87\x04\x18\n\x13\n\x0b\x04\x1e\x03\0\x03\0\x03\0\
    \x02\x02\x05\x12\x04\x88\x04\x08\x0e\n\x13\n\x0b\x04\x1e\x03\0\x03\0\x03\
    \0\x02\x02\x01\x12\x04\x88\x04\x0f\x13\n\x13\n\x0b\x04\x1e\x03\0\x03\0\
    \x03\0\x02\x02\x03\x12\x04\x88\x04\x16\x17\n\x12\n\x08\x04\x1e\x03\0\x03\
    \0\x04\x01\x12\x06\x8b\x04\x06\x91\x04\x07\n\x11\n\t\x04\x1e\x03\0\x03\0\
    \x04\x01\x01\x12\x04\x8b\x04\x0b\x1e\n\x12\n\n\x04\x1e\x03\0\x03\0\x04\
    \x01\x02\0\x12\x04\x8c\x04\x08\"\n\x13\n\x0b\x04\x1e\x03\0\x03\0\x04\x01\
    \x02\0\x01\x12\x04\x8c\x04\x08\x1d\n\x13\n\x0b\x04\x1e\x03\0\x03\0\x04\
    \x01\x02\0\x02\x12\x04\x8c\x04\x20!\n\x12\n\n\x04\x1e\x03\0\x03\0\x04\
    \x01\x02\x01\x12\x04\x8d\x04\x08\x11\n\x13\n\x0b\x04\x1e\x03\0\x03\0\x04\
    \x01\x02\x01\x01\x12\x04\x8d\x04\x08\x0c\n\x13\n\x0b\x04\x1e\x03\0\x03\0\
    \x04\x01\x02\x01\x02\x12\x04\x8d\x04\x0f\x10\n\x12\n\n\x04\x1e\x03\0\x03\
    \0\x04\x01\x02\x02\x12\x04\x8e\x04\x08\x11\n\x13\n\x0b\x04\x1e\x03\0\x03\
    \0\x04\x01\x02\x02\x01\x12\x04\x8e\x04\x08\x0c\n\x13\n\x0b\x04\x1e\x03\0\
    \x03\0\x04\x01\x02\x02\x02\x12\x04\x8e\x04\x0f\x10\n\x12\n\n\x04\x1e\x03\
    \0\x03\0\x04\x01\x02\x03\x12\x04\x8f\x04\x08\x17\n\x13\n\x0b\x04\x1e\x03\
    \0\x03\0\x04\x01\x02\x03\x01\x12\x04\x8f\x04\x08\x12\n\x13\n\x0b\x04\x1e\
    \x03\0\x03\0\x04\x01\x02\x03\x02\x12\x04\x8f\x04\x15\x16\n\x12\n\n\x04\
    \x1e\x03\0\x03\0\x04\x01\x02\x04\x12\x04\x90\x04\x08\x14\n\x13\n\x0b\x04\
    \x1e\x03\0\x03\0\x04\x01\x02\x04\x01\x12\x04\x90\x04\x08\x0f\n\x13\n\x0b\
    \x04\x1e\x03\0\x03\0\x04\x01\x02\x04\x02\x12\x04\x90\x04\x12\x13\n\x10\n\
    \x08\x04\x1e\x03\0\x03\0\x02\0\x12\x04\x93\x04\x06\x19\n\x13\n\t\x04\x1e\
    \x03\0\x03\0\x02\0\x04\x12\x06\x93\x04\x06\x91\x04\x07\n\x11\n\t\x04\x1e\
    \x03\0\x03\0\x02\0\x05\x12\x04\x93\x04\x06\n\n\x11\n\t\x04\x1e\x03\0\x03\
    \0\x02\0\x01\x12\x04\x93\x04\x0b\x14\n\x11\n\t\x04\x1e\x03\0\x03\0\x02\0\
    \x03\x12\x04\x93\x04\x17\x18\n\x10\n\x08\x04\x1e\x03\0\x03\0\x02\x01\x12\
    \x04\x94\x04\x06\x18\n\x13\n\t\x04\x1e\x03\0\x03\0\x02\x01\x04\x12\x06\
    \x94\x04\x06\x93\x04\x19\n\x11\n\t\x04\x1e\x03\0\x03\0\x02\x01\x05\x12\
    \x04\x94\x04\x06\n\n\x11\n\t\x04\x1e\x03\0\x03\0\x02\x01\x01\x12\x04\x94\
    \x04\x0b\x13\n\x11\n\t\x04\x1e\x03\0\x03\0\x02\x01\x03\x12\x04\x94\x04\
    \x16\x17\n\x10\n\x08\x04\x1e\x03\0\x03\0\x02\x02\x12\x04\x95\x04\x06\x16\
    \n\x13\n\t\x04\x1e\x03\0\x03\0\x02\x02\x04\x12\x06\x95\x04\x06\x94\x04\
    \x18\n\x11\n\t\x04\x1e\x03\0\x03\0\x02\x02\x05\x12\x04\x95\x04\x06\x0c\n\
    \x11\n\t\x04\x1e\x03\0\x03\0\x02\x02\x01\x12\x04\x95\x04\r\x11\n\x11\n\t\
    \x04\x1e\x03\0\x03\0\x02\x02\x03\x12\x04\x95\x04\x14\x15\n\x10\n\x08\x04\
    \x1e\x03\0\x03\0\x02\x03\x12\x04\x96\x04\x06\x20\n\x11\n\t\x04\x1e\x03\0\
    \x03\0\x02\x03\x04\x12\x04\x96\x04\x06\x0e\n\x11\n\t\x04\x1e\x03\0\x03\0\
    \x02\x03\x06\x12\x04\x96\x04\x0f\x14\n\x11\n\t\x04\x1e\x03\0\x03\0\x02\
    \x03\x01\x12\x04\x96\x04\x15\x1b\n\x11\n\t\x04\x1e\x03\0\x03\0\x02\x03\
    \x03\x12\x04\x96\x04\x1e\x1f\n\x10\n\x08\x04\x1e\x03\0\x03\0\x02\x04\x12\
    \x04\x97\x04\x06!\n\x11\n\t\x04\x1e\x03\0\x03\0\x02\x04\x04\x12\x04\x97\
    \x04\x06\x0e\n\x11\n\t\x04\x1e\x03\0\x03\0\x02\x04\x06\x12\x04\x97\x04\
    \x0f\x14\n\x11\n\t\x04\x1e\x03\0\x03\0\x02\x04\x01\x12\x04\x97\x04\x15\
    \x1c\n\x11\n\t\x04\x1e\x03\0\x03\0\x02\x04\x03\x12\x04\x97\x04\x1f\x20\n\
    \x10\n\x08\x04\x1e\x03\0\x03\0\x02\x05\x12\x04\x98\x04\x06\x19\n\x13\n\t\
    \x04\x1e\x03\0\x03\0\x02\x05\x04\x12\x06\x98\x04\x06\x97\x04!\n\x11\n\t\
    \x04\x1e\x03\0\x03\0\x02\x05\x06\x12\x04\x98\x04\x06\x0f\n\x11\n\t\x04\
    \x1e\x03\0\x03\0\x02\x05\x01\x12\x04\x98\x04\x10\x14\n\x11\n\t\x04\x1e\
    \x03\0\x03\0\x02\x05\x03\x12\x04\x98\x04\x17\x18\n\x10\n\x08\x04\x1e\x03\
    \0\x03\0\x02\x06\x12\x04\x99\x04\x06\x17\n\x13\n\t\x04\x1e\x03\0\x03\0\
    \x02\x06\x04\x12\x06\x99\x04\x06\x98\x04\x19\n\x11\n\t\x04\x1e\x03\0\x03\
    \0\x02\x06\x05\x12\x04\x99\x04\x06\n\n\x11\n\t\x04\x1e\x03\0\x03\0\x02\
    \x06\x01\x12\x04\x99\x04\x0b\x12\n\x11\n\t\x04\x1e\x03\0\x03\0\x02\x06\
    \x03\x12\x04\x99\x04\x15\x16\n\x10\n\x08\x04\x1e\x03\0\x03\0\x02\x07\x12\
    \x04\x9a\x04\x06.\n\x13\n\t\x04\x1e\x03\0\x03\0\x02\x07\x04\x12\x06\x9a\
    \x04\x06\x99\x04\x17\n\x11\n\t\x04\x1e\x03\0\x03\0\x02\x07\x06\x12\x04\
    \x9a\x04\x06\x19\n\x11\n\t\x04\x1e\x03\0\x03\0\x02\x07\x01\x12\x04\x9a\
    \x04\x1a)\n\x11\n\t\x04\x1e\x03\0\x03\0\x02\x07\x03\x12\x04\x9a\x04,-\n\
    \x0e\n\x06\x04\x1e\x03\0\x02\0\x12\x04\x9c\x04\x04\x1e\n\x0f\n\x07\x04\
    \x1e\x03\0\x02\0\x04\x12\x04\x9c\x04\x04\x0c\n\x0f\n\x07\x04\x1e\x03\0\
    \x02\0\x06\x12\x04\x9c\x04\r\x12\n\x0f\n\x07\x04\x1e\x03\0\x02\0\x01\x12\
    \x04\x9c\x04\x13\x19\n\x0f\n\x07\x04\x1e\x03\0\x02\0\x03\x12\x04\x9c\x04\
    \x1c\x1d\n\x0c\n\x04\x04\x1e\x02\0\x12\x04\x9e\x04\x02\x1b\n\x0f\n\x05\
    \x04\x1e\x02\0\x04\x12\x06\x9e\x04\x02\x9d\x04\x03\n\r\n\x05\x04\x1e\x02\
    \0\x05\x12\x04\x9e\x04\x02\x07\n\r\n\x05\x04\x1e\x02\0\x01\x12\x04\x9e\
    \x04\x08\x16\n\r\n\x05\x04\x1e\x02\0\x03\x12\x04\x9e\x04\x19\x1a\n\x0c\n\
    \x04\x04\x1e\x02\x01\x12\x04\x9f\x04\x02\x1d\n\x0f\n\x05\x04\x1e\x02\x01\
    \x04\x12\x06\x9f\x04\x02\x9e\x04\x1b\n\r\n\x05\x04\x1e\x02\x01\x05\x12\
    \x04\x9f\x04\x02\x07\n\r\n\x05\x04\x1e\x02\x01\x01\x12\x04\x9f\x04\x08\
    \x18\n\r\n\x05\x04\x1e\x02\x01\x03\x12\x04\x9f\x04\x1b\x1c\n\x0c\n\x04\
    \x04\x1e\x02\x02\x12\x04\xa0\x04\x02\x0e\n\x0f\n\x05\x04\x1e\x02\x02\x04\
    \x12\x06\xa0\x04\x02\x9f\x04\x1d\n\r\n\x05\x04\x1e\x02\x02\x06\x12\x04\
    \xa0\x04\x02\x05\n\r\n\x05\x04\x1e\x02\x02\x01\x12\x04\xa0\x04\x06\t\n\r\
    \n\x05\x04\x1e\x02\x02\x03\x12\x04\xa0\x04\x0c\r\n\x0c\n\x04\x04\x1e\x02\
    \x03\x12\x04\xa1\x04\x02\x15\n\x0f\n\x05\x04\x1e\x02\x03\x04\x12\x06\xa1\
    \x04\x02\xa0\x04\x0e\n\r\n\x05\x04\x1e\x02\x03\x05\x12\x04\xa1\x04\x02\
    \x07\n\r\n\x05\x04\x1e\x02\x03\x01\x12\x04\xa1\x04\x08\x10\n\r\n\x05\x04\
    \x1e\x02\x03\x03\x12\x04\xa1\x04\x13\x14\n\x0c\n\x04\x04\x1e\x02\x04\x12\
    \x04\xa2\x04\x02\x17\n\x0f\n\x05\x04\x1e\x02\x04\x04\x12\x06\xa2\x04\x02\
    \xa1\x04\x15\n\r\n\x05\x04\x1e\x02\x04\x05\x12\x04\xa2\x04\x02\x07\n\r\n\
    \x05\x04\x1e\x02\x04\x01\x12\x04\xa2\x04\x08\x12\n\r\n\x05\x04\x1e\x02\
    \x04\x03\x12\x04\xa2\x04\x15\x16\n\x0c\n\x04\x04\x1e\x02\x05\x12\x04\xa3\
    \x04\x02*\n\x0f\n\x05\x04\x1e\x02\x05\x04\x12\x06\xa3\x04\x02\xa2\x04\
    \x17\n\r\n\x05\x04\x1e\x02\x05\x05\x12\x04\xa3\x04\x02\x07\n\r\n\x05\x04\
    \x1e\x02\x05\x01\x12\x04\xa3\x04\x08%\n\r\n\x05\x04\x1e\x02\x05\x03\x12\
    \x04\xa3\x04()\n\x0c\n\x04\x04\x1e\x02\x06\x12\x04\xa4\x04\x02\x12\n\x0f\
    \n\x05\x04\x1e\x02\x06\x04\x12\x06\xa4\x04\x02\xa3\x04*\n\r\n\x05\x04\
    \x1e\x02\x06\x05\x12\x04\xa4\x04\x02\x08\n\r\n\x05\x04\x1e\x02\x06\x01\
    \x12\x04\xa4\x04\t\r\n\r\n\x05\x04\x1e\x02\x06\x03\x12\x04\xa4\x04\x10\
    \x11\n\x0c\n\x04\x04\x1e\x02\x07\x12\x04\xa5\x04\x02\x20\n\x0f\n\x05\x04\
    \x1e\x02\x07\x04\x12\x06\xa5\x04\x02\xa4\x04\x12\n\r\n\x05\x04\x1e\x02\
    \x07\x05\x12\x04\xa5\x04\x02\x07\n\r\n\x05\x04\x1e\x02\x07\x01\x12\x04\
    \xa5\x04\x08\x1b\n\r\n\x05\x04\x1e\x02\x07\x03\x12\x04\xa5\x04\x1e\x1f\n\
    \x0c\n\x04\x04\x1e\x02\x08\x12\x04\xa6\x04\x02\x16\n\x0f\n\x05\x04\x1e\
    \x02\x08\x04\x12\x06\xa6\x04\x02\xa5\x04\x20\n\r\n\x05\x04\x1e\x02\x08\
    \x05\x12\x04\xa6\x04\x02\x07\n\r\n\x05\x04\x1e\x02\x08\x01\x12\x04\xa6\
    \x04\x08\x11\n\r\n\x05\x04\x1e\x02\x08\x03\x12\x04\xa6\x04\x14\x15\n\x0c\
    \n\x04\x04\x1e\x02\t\x12\x04\xa7\x04\x02\x16\n\x0f\n\x05\x04\x1e\x02\t\
    \x04\x12\x06\xa7\x04\x02\xa6\x04\x16\n\r\n\x05\x04\x1e\x02\t\x05\x12\x04\
    \xa7\x04\x02\x07\n\r\n\x05\x04\x1e\x02\t\x01\x12\x04\xa7\x04\x08\x10\n\r\
    \n\x05\x04\x1e\x02\t\x03\x12\x04\xa7\x04\x13\x15\n\x0c\n\x02\x04\x1f\x12\
    \x06\xaa\x04\0\xbb\x04\x01\n\x0b\n\x03\x04\x1f\x01\x12\x04\xaa\x04\x08\
    \x1b\nv\n\x04\x04\x1f\x02\0\x12\x04\xad\x04\x02\x11\x1ah\x20internalTran\
    saction\x20identity,\x20the\x20root\x20InternalTransaction\x20hash\n\x20\
    should\x20equals\x20to\x20root\x20transaction\x20id.\n\n\x0f\n\x05\x04\
    \x1f\x02\0\x04\x12\x06\xad\x04\x02\xaa\x04\x1d\n\r\n\x05\x04\x1f\x02\0\
    \x05\x12\x04\xad\x04\x02\x07\n\r\n\x05\x04\x1f\x02\0\x01\x12\x04\xad\x04\
    \x08\x0c\n\r\n\x05\x04\x1f\x02\0\x03\x12\x04\xad\x04\x0f\x10\n=\n\x04\
    \x04\x1f\x02\x01\x12\x04\xaf\x04\x02\x1b\x1a/\x20the\x20one\x20send\x20t\
    rx\x20(TBD:\x20or\x20token)\x20via\x20function\n\n\x0f\n\x05\x04\x1f\x02\
    \x01\x04\x12\x06\xaf\x04\x02\xad\x04\x11\n\r\n\x05\x04\x1f\x02\x01\x05\
    \x12\x04\xaf\x04\x02\x07\n\r\n\x05\x04\x1f\x02\x01\x01\x12\x04\xaf\x04\
    \x08\x16\n\r\n\x05\x04\x1f\x02\x01\x03\x12\x04\xaf\x04\x19\x1a\n@\n\x04\
    \x04\x1f\x02\x02\x12\x04\xb1\x04\x02\x1f\x1a2\x20the\x20one\x20recieve\
    \x20trx\x20(TBD:\x20or\x20token)\x20via\x20function\n\n\x0f\n\x05\x04\
    \x1f\x02\x02\x04\x12\x06\xb1\x04\x02\xaf\x04\x1b\n\r\n\x05\x04\x1f\x02\
    \x02\x05\x12\x04\xb1\x04\x02\x07\n\r\n\x05\x04\x1f\x02\x02\x01\x12\x04\
    \xb1\x04\x08\x1a\n\r\n\x05\x04\x1f\x02\x02\x03\x12\x04\xb1\x04\x1d\x1e\n\
    \x0e\n\x04\x04\x1f\x03\0\x12\x06\xb2\x04\x02\xb7\x04\x03\n\r\n\x05\x04\
    \x1f\x03\0\x01\x12\x04\xb2\x04\n\x17\n+\n\x06\x04\x1f\x03\0\x02\0\x12\
    \x04\xb4\x04\x04\x18\x1a\x1b\x20trx\x20(TBD:\x20or\x20token)\x20value\n\
    \n\x11\n\x07\x04\x1f\x03\0\x02\0\x04\x12\x06\xb4\x04\x04\xb2\x04\x19\n\
    \x0f\n\x07\x04\x1f\x03\0\x02\0\x05\x12\x04\xb4\x04\x04\t\n\x0f\n\x07\x04\
    \x1f\x03\0\x02\0\x01\x12\x04\xb4\x04\n\x13\n\x0f\n\x07\x04\x1f\x03\0\x02\
    \0\x03\x12\x04\xb4\x04\x16\x17\n5\n\x06\x04\x1f\x03\0\x02\x01\x12\x04\
    \xb6\x04\x04\x17\x1a%\x20TBD:\x20tokenName,\x20trx\x20should\x20be\x20em\
    pty\n\n\x11\n\x07\x04\x1f\x03\0\x02\x01\x04\x12\x06\xb6\x04\x04\xb4\x04\
    \x18\n\x0f\n\x07\x04\x1f\x03\0\x02\x01\x05\x12\x04\xb6\x04\x04\n\n\x0f\n\
    \x07\x04\x1f\x03\0\x02\x01\x01\x12\x04\xb6\x04\x0b\x12\n\x0f\n\x07\x04\
    \x1f\x03\0\x02\x01\x03\x12\x04\xb6\x04\x15\x16\n\x0c\n\x04\x04\x1f\x02\
    \x03\x12\x04\xb8\x04\x02+\n\r\n\x05\x04\x1f\x02\x03\x04\x12\x04\xb8\x04\
    \x02\n\n\r\n\x05\x04\x1f\x02\x03\x06\x12\x04\xb8\x04\x0b\x18\n\r\n\x05\
    \x04\x1f\x02\x03\x01\x12\x04\xb8\x04\x19&\n\r\n\x05\x04\x1f\x02\x03\x03\
    \x12\x04\xb8\x04)*\n\x0c\n\x04\x04\x1f\x02\x04\x12\x04\xb9\x04\x02\x11\n\
    \x0f\n\x05\x04\x1f\x02\x04\x04\x12\x06\xb9\x04\x02\xb8\x04+\n\r\n\x05\
    \x04\x1f\x02\x04\x05\x12\x04\xb9\x04\x02\x07\n\r\n\x05\x04\x1f\x02\x04\
    \x01\x12\x04\xb9\x04\x08\x0c\n\r\n\x05\x04\x1f\x02\x04\x03\x12\x04\xb9\
    \x04\x0f\x10\n\x0c\n\x04\x04\x1f\x02\x05\x12\x04\xba\x04\x02\x14\n\x0f\n\
    \x05\x04\x1f\x02\x05\x04\x12\x06\xba\x04\x02\xb9\x04\x11\n\r\n\x05\x04\
    \x1f\x02\x05\x05\x12\x04\xba\x04\x02\x06\n\r\n\x05\x04\x1f\x02\x05\x01\
    \x12\x04\xba\x04\x07\x0f\n\r\n\x05\x04\x1f\x02\x05\x03\x12\x04\xba\x04\
    \x12\x13\n\x0c\n\x02\x04\x20\x12\x06\xbd\x04\0\xc1\x04\x01\n\x0b\n\x03\
    \x04\x20\x01\x12\x04\xbd\x04\x08%\n\x0c\n\x04\x04\x20\x02\0\x12\x04\xbe\
    \x04\x02\x14\n\x0f\n\x05\x04\x20\x02\0\x04\x12\x06\xbe\x04\x02\xbd\x04'\
    \n\r\n\x05\x04\x20\x02\0\x05\x12\x04\xbe\x04\x02\x07\n\r\n\x05\x04\x20\
    \x02\0\x01\x12\x04\xbe\x04\x08\x0f\n\r\n\x05\x04\x20\x02\0\x03\x12\x04\
    \xbe\x04\x12\x13\n\x0c\n\x04\x04\x20\x02\x01\x12\x04\xbf\x04\x02\"\n\r\n\
    \x05\x04\x20\x02\x01\x04\x12\x04\xbf\x04\x02\n\n\r\n\x05\x04\x20\x02\x01\
    \x05\x12\x04\xbf\x04\x0b\x10\n\r\n\x05\x04\x20\x02\x01\x01\x12\x04\xbf\
    \x04\x11\x1d\n\r\n\x05\x04\x20\x02\x01\x03\x12\x04\xbf\x04\x20!\n\x0c\n\
    \x04\x04\x20\x02\x02\x12\x04\xc0\x04\x02\x20\n\r\n\x05\x04\x20\x02\x02\
    \x04\x12\x04\xc0\x04\x02\n\n\r\n\x05\x04\x20\x02\x02\x05\x12\x04\xc0\x04\
    \x0b\x10\n\r\n\x05\x04\x20\x02\x02\x01\x12\x04\xc0\x04\x11\x1b\n\r\n\x05\
    \x04\x20\x02\x02\x03\x12\x04\xc0\x04\x1e\x1f\n\x0c\n\x02\x04!\x12\x06\
    \xc3\x04\0\xa4\x05\x01\n\x0b\n\x03\x04!\x01\x12\x04\xc3\x04\x08\x10\n\
    \x0c\n\x04\x04!\x02\0\x12\x04\xc4\x04\x02\x19\n\x0f\n\x05\x04!\x02\0\x04\
    \x12\x06\xc4\x04\x02\xc3\x04\x12\n\r\n\x05\x04!\x02\0\x05\x12\x04\xc4\
    \x04\x02\x07\n\r\n\x05\x04!\x02\0\x01\x12\x04\xc4\x04\x08\x14\n\r\n\x05\
    \x04!\x02\0\x03\x12\x04\xc4\x04\x17\x18\n\x0c\n\x04\x04!\x02\x01\x12\x04\
    \xc5\x04\x02\x13\n\x0f\n\x05\x04!\x02\x01\x04\x12\x06\xc5\x04\x02\xc4\
    \x04\x19\n\r\n\x05\x04!\x02\x01\x05\x12\x04\xc5\x04\x02\x08\n\r\n\x05\
    \x04!\x02\x01\x01\x12\x04\xc5\x04\t\x0e\n\r\n\x05\x04!\x02\x01\x03\x12\
    \x04\xc5\x04\x11\x12\n\x0c\n\x04\x04!\x02\x02\x12\x04\xc6\x04\x02\x1b\n\
    \x0f\n\x05\x04!\x02\x02\x04\x12\x06\xc6\x04\x02\xc5\x04\x13\n\r\n\x05\
    \x04!\x02\x02\x05\x12\x04\xc6\x04\x02\x08\n\r\n\x05\x04!\x02\x02\x01\x12\
    \x04\xc6\x04\t\x16\n\r\n\x05\x04!\x02\x02\x03\x12\x04\xc6\x04\x19\x1a\n\
    \"\n\x04\x04!\x02\x03\x12\x04\xc8\x04\x02\x20\x1a\x14connect\x20informat\
    ion\n\n\x0f\n\x05\x04!\x02\x03\x04\x12\x06\xc8\x04\x02\xc6\x04\x1b\n\r\n\
    \x05\x04!\x02\x03\x05\x12\x04\xc8\x04\x02\x07\n\r\n\x05\x04!\x02\x03\x01\
    \x12\x04\xc8\x04\x08\x1b\n\r\n\x05\x04!\x02\x03\x03\x12\x04\xc8\x04\x1e\
    \x1f\n\x0c\n\x04\x04!\x02\x04\x12\x04\xc9\x04\x02\x1f\n\x0f\n\x05\x04!\
    \x02\x04\x04\x12\x06\xc9\x04\x02\xc8\x04\x20\n\r\n\x05\x04!\x02\x04\x05\
    \x12\x04\xc9\x04\x02\x07\n\r\n\x05\x04!\x02\x04\x01\x12\x04\xc9\x04\x08\
    \x1a\n\r\n\x05\x04!\x02\x04\x03\x12\x04\xc9\x04\x1d\x1e\n\x0c\n\x04\x04!\
    \x02\x05\x12\x04\xca\x04\x02\x20\n\x0f\n\x05\x04!\x02\x05\x04\x12\x06\
    \xca\x04\x02\xc9\x04\x1f\n\r\n\x05\x04!\x02\x05\x05\x12\x04\xca\x04\x02\
    \x07\n\r\n\x05\x04!\x02\x05\x01\x12\x04\xca\x04\x08\x1b\n\r\n\x05\x04!\
    \x02\x05\x03\x12\x04\xca\x04\x1e\x1f\n\x0c\n\x04\x04!\x02\x06\x12\x04\
    \xcb\x04\x02\x16\n\x0f\n\x05\x04!\x02\x06\x04\x12\x06\xcb\x04\x02\xca\
    \x04\x20\n\r\n\x05\x04!\x02\x06\x05\x12\x04\xcb\x04\x02\x07\n\r\n\x05\
    \x04!\x02\x06\x01\x12\x04\xcb\x04\x08\x11\n\r\n\x05\x04!\x02\x06\x03\x12\
    \x04\xcb\x04\x14\x15\n\x0c\n\x04\x04!\x02\x07\x12\x04\xcc\x04\x02%\n\r\n\
    \x05\x04!\x02\x07\x04\x12\x04\xcc\x04\x02\n\n\r\n\x05\x04!\x02\x07\x06\
    \x12\x04\xcc\x04\x0b\x13\n\r\n\x05\x04!\x02\x07\x01\x12\x04\xcc\x04\x14\
    \x20\n\r\n\x05\x04!\x02\x07\x03\x12\x04\xcc\x04#$\n\x0c\n\x04\x04!\x02\
    \x08\x12\x04\xcd\x04\x02$\n\x0f\n\x05\x04!\x02\x08\x04\x12\x06\xcd\x04\
    \x02\xcc\x04%\n\r\n\x05\x04!\x02\x08\x06\x12\x04\xcd\x04\x02\x10\n\r\n\
    \x05\x04!\x02\x08\x01\x12\x04\xcd\x04\x11\x1f\n\r\n\x05\x04!\x02\x08\x03\
    \x12\x04\xcd\x04\"#\n\x0c\n\x04\x04!\x02\t\x12\x04\xce\x04\x02\x1f\n\x0f\
    \n\x05\x04!\x02\t\x04\x12\x06\xce\x04\x02\xcd\x04$\n\r\n\x05\x04!\x02\t\
    \x06\x12\x04\xce\x04\x02\r\n\r\n\x05\x04!\x02\t\x01\x12\x04\xce\x04\x0e\
    \x19\n\r\n\x05\x04!\x02\t\x03\x12\x04\xce\x04\x1c\x1e\n\x0c\n\x04\x04!\
    \x02\n\x12\x04\xcf\x04\x02/\n\x0f\n\x05\x04!\x02\n\x04\x12\x06\xcf\x04\
    \x02\xce\x04\x1f\n\r\n\x05\x04!\x02\n\x06\x12\x04\xcf\x04\x02\x15\n\r\n\
    \x05\x04!\x02\n\x01\x12\x04\xcf\x04\x16)\n\r\n\x05\x04!\x02\n\x03\x12\
    \x04\xcf\x04,.\n\x0e\n\x04\x04!\x03\x01\x12\x06\xd1\x04\x02\xeb\x04\x03\
    \n\r\n\x05\x04!\x03\x01\x01\x12\x04\xd1\x04\n\x12\n\x0e\n\x06\x04!\x03\
    \x01\x02\0\x12\x04\xd2\x04\x04\x1d\n\x11\n\x07\x04!\x03\x01\x02\0\x04\
    \x12\x06\xd2\x04\x04\xd1\x04\x14\n\x0f\n\x07\x04!\x03\x01\x02\0\x05\x12\
    \x04\xd2\x04\x04\n\n\x0f\n\x07\x04!\x03\x01\x02\0\x01\x12\x04\xd2\x04\
    \x0b\x18\n\x0f\n\x07\x04!\x03\x01\x02\0\x03\x12\x04\xd2\x04\x1b\x1c\n\
    \x0e\n\x06\x04!\x03\x01\x02\x01\x12\x04\xd3\x04\x04\x18\n\x11\n\x07\x04!\
    \x03\x01\x02\x01\x04\x12\x06\xd3\x04\x04\xd2\x04\x1d\n\x0f\n\x07\x04!\
    \x03\x01\x02\x01\x05\x12\x04\xd3\x04\x04\t\n\x0f\n\x07\x04!\x03\x01\x02\
    \x01\x01\x12\x04\xd3\x04\n\x13\n\x0f\n\x07\x04!\x03\x01\x02\x01\x03\x12\
    \x04\xd3\x04\x16\x17\n\x0e\n\x06\x04!\x03\x01\x02\x02\x12\x04\xd4\x04\
    \x04\"\n\x11\n\x07\x04!\x03\x01\x02\x02\x04\x12\x06\xd4\x04\x04\xd3\x04\
    \x18\n\x0f\n\x07\x04!\x03\x01\x02\x02\x05\x12\x04\xd4\x04\x04\t\n\x0f\n\
    \x07\x04!\x03\x01\x02\x02\x01\x12\x04\xd4\x04\n\x1d\n\x0f\n\x07\x04!\x03\
    \x01\x02\x02\x03\x12\x04\xd4\x04\x20!\n\x0e\n\x06\x04!\x03\x01\x02\x03\
    \x12\x04\xd5\x04\x04\x16\n\x11\n\x07\x04!\x03\x01\x02\x03\x04\x12\x06\
    \xd5\x04\x04\xd4\x04\"\n\x0f\n\x07\x04!\x03\x01\x02\x03\x05\x12\x04\xd5\
    \x04\x04\x08\n\x0f\n\x07\x04!\x03\x01\x02\x03\x01\x12\x04\xd5\x04\t\x11\
    \n\x0f\n\x07\x04!\x03\x01\x02\x03\x03\x12\x04\xd5\x04\x14\x15\n\x0e\n\
    \x06\x04!\x03\x01\x02\x04\x12\x04\xd6\x04\x04&\n\x11\n\x07\x04!\x03\x01\
    \x02\x04\x04\x12\x06\xd6\x04\x04\xd5\x04\x16\n\x0f\n\x07\x04!\x03\x01\
    \x02\x04\x05\x12\x04\xd6\x04\x04\t\n\x0f\n\x07\x04!\x03\x01\x02\x04\x01\
    \x12\x04\xd6\x04\n!\n\x0f\n\x07\x04!\x03\x01\x02\x04\x03\x12\x04\xd6\x04\
    $%\n\x0e\n\x06\x04!\x03\x01\x02\x05\x12\x04\xd7\x04\x04\x1e\n\x11\n\x07\
    \x04!\x03\x01\x02\x05\x04\x12\x06\xd7\x04\x04\xd6\x04&\n\x0f\n\x07\x04!\
    \x03\x01\x02\x05\x05\x12\x04\xd7\x04\x04\x08\n\x0f\n\x07\x04!\x03\x01\
    \x02\x05\x01\x12\x04\xd7\x04\t\x19\n\x0f\n\x07\x04!\x03\x01\x02\x05\x03\
    \x12\x04\xd7\x04\x1c\x1d\n\x0e\n\x06\x04!\x03\x01\x02\x06\x12\x04\xd8\
    \x04\x04\x1c\n\x11\n\x07\x04!\x03\x01\x02\x06\x04\x12\x06\xd8\x04\x04\
    \xd7\x04\x1e\n\x0f\n\x07\x04!\x03\x01\x02\x06\x05\x12\x04\xd8\x04\x04\
    \x08\n\x0f\n\x07\x04!\x03\x01\x02\x06\x01\x12\x04\xd8\x04\t\x17\n\x0f\n\
    \x07\x04!\x03\x01\x02\x06\x03\x12\x04\xd8\x04\x1a\x1b\n\x0e\n\x06\x04!\
    \x03\x01\x02\x07\x12\x04\xd9\x04\x04\x14\n\x11\n\x07\x04!\x03\x01\x02\
    \x07\x04\x12\x06\xd9\x04\x04\xd8\x04\x1c\n\x0f\n\x07\x04!\x03\x01\x02\
    \x07\x05\x12\x04\xd9\x04\x04\n\n\x0f\n\x07\x04!\x03\x01\x02\x07\x01\x12\
    \x04\xd9\x04\x0b\x0f\n\x0f\n\x07\x04!\x03\x01\x02\x07\x03\x12\x04\xd9\
    \x04\x12\x13\n\x0e\n\x06\x04!\x03\x01\x02\x08\x12\x04\xda\x04\x04\x13\n\
    \x11\n\x07\x04!\x03\x01\x02\x08\x04\x12\x06\xda\x04\x04\xd9\x04\x14\n\
    \x0f\n\x07\x04!\x03\x01\x02\x08\x05\x12\x04\xda\x04\x04\t\n\x0f\n\x07\
    \x04!\x03\x01\x02\x08\x01\x12\x04\xda\x04\n\x0e\n\x0f\n\x07\x04!\x03\x01\
    \x02\x08\x03\x12\x04\xda\x04\x11\x12\n\x0e\n\x06\x04!\x03\x01\x02\t\x12\
    \x04\xdb\x04\x04\x17\n\x11\n\x07\x04!\x03\x01\x02\t\x04\x12\x06\xdb\x04\
    \x04\xda\x04\x13\n\x0f\n\x07\x04!\x03\x01\x02\t\x05\x12\x04\xdb\x04\x04\
    \n\n\x0f\n\x07\x04!\x03\x01\x02\t\x01\x12\x04\xdb\x04\x0b\x11\n\x0f\n\
    \x07\x04!\x03\x01\x02\t\x03\x12\x04\xdb\x04\x14\x16\n\x0e\n\x06\x04!\x03\
    \x01\x02\n\x12\x04\xdc\x04\x04\x1b\n\x11\n\x07\x04!\x03\x01\x02\n\x04\
    \x12\x06\xdc\x04\x04\xdb\x04\x17\n\x0f\n\x07\x04!\x03\x01\x02\n\x05\x12\
    \x04\xdc\x04\x04\t\n\x0f\n\x07\x04!\x03\x01\x02\n\x01\x12\x04\xdc\x04\n\
    \x15\n\x0f\n\x07\x04!\x03\x01\x02\n\x03\x12\x04\xdc\x04\x18\x1a\n\x0e\n\
    \x06\x04!\x03\x01\x02\x0b\x12\x04\xdd\x04\x04\x1b\n\x11\n\x07\x04!\x03\
    \x01\x02\x0b\x04\x12\x06\xdd\x04\x04\xdc\x04\x1b\n\x0f\n\x07\x04!\x03\
    \x01\x02\x0b\x05\x12\x04\xdd\x04\x04\n\n\x0f\n\x07\x04!\x03\x01\x02\x0b\
    \x01\x12\x04\xdd\x04\x0b\x15\n\x0f\n\x07\x04!\x03\x01\x02\x0b\x03\x12\
    \x04\xdd\x04\x18\x1a\n\x0e\n\x06\x04!\x03\x01\x02\x0c\x12\x04\xde\x04\
    \x04\x1f\n\x11\n\x07\x04!\x03\x01\x02\x0c\x04\x12\x06\xde\x04\x04\xdd\
    \x04\x1b\n\x0f\n\x07\x04!\x03\x01\x02\x0c\x05\x12\x04\xde\x04\x04\t\n\
    \x0f\n\x07\x04!\x03\x01\x02\x0c\x01\x12\x04\xde\x04\n\x19\n\x0f\n\x07\
    \x04!\x03\x01\x02\x0c\x03\x12\x04\xde\x04\x1c\x1e\n\x0e\n\x06\x04!\x03\
    \x01\x02\r\x12\x04\xdf\x04\x04&\n\x11\n\x07\x04!\x03\x01\x02\r\x04\x12\
    \x06\xdf\x04\x04\xde\x04\x1f\n\x0f\n\x07\x04!\x03\x01\x02\r\x05\x12\x04\
    \xdf\x04\x04\t\n\x0f\n\x07\x04!\x03\x01\x02\r\x01\x12\x04\xdf\x04\n\x20\
    \n\x0f\n\x07\x04!\x03\x01\x02\r\x03\x12\x04\xdf\x04#%\n\x0e\n\x06\x04!\
    \x03\x01\x02\x0e\x12\x04\xe0\x04\x04&\n\x11\n\x07\x04!\x03\x01\x02\x0e\
    \x04\x12\x06\xe0\x04\x04\xdf\x04&\n\x0f\n\x07\x04!\x03\x01\x02\x0e\x05\
    \x12\x04\xe0\x04\x04\t\n\x0f\n\x07\x04!\x03\x01\x02\x0e\x01\x12\x04\xe0\
    \x04\n\x20\n\x0f\n\x07\x04!\x03\x01\x02\x0e\x03\x12\x04\xe0\x04#%\n\x0e\
    \n\x06\x04!\x03\x01\x02\x0f\x12\x04\xe1\x04\x04\x1d\n\x11\n\x07\x04!\x03\
    \x01\x02\x0f\x04\x12\x06\xe1\x04\x04\xe0\x04&\n\x0f\n\x07\x04!\x03\x01\
    \x02\x0f\x05\x12\x04\xe1\x04\x04\t\n\x0f\n\x07\x04!\x03\x01\x02\x0f\x01\
    \x12\x04\xe1\x04\n\x17\n\x0f\n\x07\x04!\x03\x01\x02\x0f\x03\x12\x04\xe1\
    \x04\x1a\x1c\n\x0e\n\x06\x04!\x03\x01\x02\x10\x12\x04\xe2\x04\x04\x1f\n\
    \x11\n\x07\x04!\x03\x01\x02\x10\x04\x12\x06\xe2\x04\x04\xe1\x04\x1d\n\
    \x0f\n\x07\x04!\x03\x01\x02\x10\x05\x12\x04\xe2\x04\x04\t\n\x0f\n\x07\
    \x04!\x03\x01\x02\x10\x01\x12\x04\xe2\x04\n\x19\n\x0f\n\x07\x04!\x03\x01\
    \x02\x10\x03\x12\x04\xe2\x04\x1c\x1e\n\x0e\n\x06\x04!\x03\x01\x02\x11\
    \x12\x04\xe3\x04\x04$\n\x11\n\x07\x04!\x03\x01\x02\x11\x04\x12\x06\xe3\
    \x04\x04\xe2\x04\x1f\n\x0f\n\x07\x04!\x03\x01\x02\x11\x05\x12\x04\xe3\
    \x04\x04\n\n\x0f\n\x07\x04!\x03\x01\x02\x11\x01\x12\x04\xe3\x04\x0b\x1e\
    \n\x0f\n\x07\x04!\x03\x01\x02\x11\x03\x12\x04\xe3\x04!#\n\x0e\n\x06\x04!\
    \x03\x01\x02\x12\x12\x04\xe4\x04\x04\x17\n\x11\n\x07\x04!\x03\x01\x02\
    \x12\x04\x12\x06\xe4\x04\x04\xe3\x04$\n\x0f\n\x07\x04!\x03\x01\x02\x12\
    \x05\x12\x04\xe4\x04\x04\x08\n\x0f\n\x07\x04!\x03\x01\x02\x12\x01\x12\
    \x04\xe4\x04\t\x11\n\x0f\n\x07\x04!\x03\x01\x02\x12\x03\x12\x04\xe4\x04\
    \x14\x16\n\x0e\n\x06\x04!\x03\x01\x02\x13\x12\x04\xe5\x04\x04\x15\n\x11\
    \n\x07\x04!\x03\x01\x02\x13\x04\x12\x06\xe5\x04\x04\xe4\x04\x17\n\x0f\n\
    \x07\x04!\x03\x01\x02\x13\x05\x12\x04\xe5\x04\x04\t\n\x0f\n\x07\x04!\x03\
    \x01\x02\x13\x01\x12\x04\xe5\x04\n\x0f\n\x0f\n\x07\x04!\x03\x01\x02\x13\
    \x03\x12\x04\xe5\x04\x12\x14\n\x0e\n\x06\x04!\x03\x01\x02\x14\x12\x04\
    \xe6\x04\x04\x19\n\x11\n\x07\x04!\x03\x01\x02\x14\x04\x12\x06\xe6\x04\
    \x04\xe5\x04\x15\n\x0f\n\x07\x04!\x03\x01\x02\x14\x05\x12\x04\xe6\x04\
    \x04\t\n\x0f\n\x07\x04!\x03\x01\x02\x14\x01\x12\x04\xe6\x04\n\x13\n\x0f\
    \n\x07\x04!\x03\x01\x02\x14\x03\x12\x04\xe6\x04\x16\x18\n\x0e\n\x06\x04!\
    \x03\x01\x02\x15\x12\x04\xe7\x04\x04\x16\n\x11\n\x07\x04!\x03\x01\x02\
    \x15\x04\x12\x06\xe7\x04\x04\xe6\x04\x19\n\x0f\n\x07\x04!\x03\x01\x02\
    \x15\x05\x12\x04\xe7\x04\x04\t\n\x0f\n\x07\x04!\x03\x01\x02\x15\x01\x12\
    \x04\xe7\x04\n\x10\n\x0f\n\x07\x04!\x03\x01\x02\x15\x03\x12\x04\xe7\x04\
    \x13\x15\n\x0e\n\x06\x04!\x03\x01\x02\x16\x12\x04\xe8\x04\x04\x1f\n\x11\
    \n\x07\x04!\x03\x01\x02\x16\x04\x12\x06\xe8\x04\x04\xe7\x04\x16\n\x0f\n\
    \x07\x04!\x03\x01\x02\x16\x05\x12\x04\xe8\x04\x04\t\n\x0f\n\x07\x04!\x03\
    \x01\x02\x16\x01\x12\x04\xe8\x04\n\x19\n\x0f\n\x07\x04!\x03\x01\x02\x16\
    \x03\x12\x04\xe8\x04\x1c\x1e\n\x0e\n\x06\x04!\x03\x01\x02\x17\x12\x04\
    \xe9\x04\x04&\n\x11\n\x07\x04!\x03\x01\x02\x17\x04\x12\x06\xe9\x04\x04\
    \xe8\x04\x1f\n\x0f\n\x07\x04!\x03\x01\x02\x17\x05\x12\x04\xe9\x04\x04\n\
    \n\x0f\n\x07\x04!\x03\x01\x02\x17\x01\x12\x04\xe9\x04\x0b\x20\n\x0f\n\
    \x07\x04!\x03\x01\x02\x17\x03\x12\x04\xe9\x04#%\n\x0e\n\x06\x04!\x03\x01\
    \x02\x18\x12\x04\xea\x04\x04'\n\x11\n\x07\x04!\x03\x01\x02\x18\x04\x12\
    \x06\xea\x04\x04\xe9\x04&\n\x0f\n\x07\x04!\x03\x01\x02\x18\x05\x12\x04\
    \xea\x04\x04\n\n\x0f\n\x07\x04!\x03\x01\x02\x18\x01\x12\x04\xea\x04\x0b!\
    \n\x0f\n\x07\x04!\x03\x01\x02\x18\x03\x12\x04\xea\x04$&\n\x0e\n\x04\x04!\
    \x03\x02\x12\x06\xed\x04\x02\x81\x05\x03\n\r\n\x05\x04!\x03\x02\x01\x12\
    \x04\xed\x04\n\x18\n\x0e\n\x06\x04!\x03\x02\x02\0\x12\x04\xee\x04\x04\
    \x1b\n\x11\n\x07\x04!\x03\x02\x02\0\x04\x12\x06\xee\x04\x04\xed\x04\x1a\
    \n\x0f\n\x07\x04!\x03\x02\x02\0\x05\x12\x04\xee\x04\x04\n\n\x0f\n\x07\
    \x04!\x03\x02\x02\0\x01\x12\x04\xee\x04\x0b\x16\n\x0f\n\x07\x04!\x03\x02\
    \x02\0\x03\x12\x04\xee\x04\x19\x1a\n\x0e\n\x06\x04!\x03\x02\x02\x01\x12\
    \x04\xef\x04\x04\x1a\n\x11\n\x07\x04!\x03\x02\x02\x01\x04\x12\x06\xef\
    \x04\x04\xee\x04\x1b\n\x0f\n\x07\x04!\x03\x02\x02\x01\x05\x12\x04\xef\
    \x04\x04\n\n\x0f\n\x07\x04!\x03\x02\x02\x01\x01\x12\x04\xef\x04\x0b\x15\
    \n\x0f\n\x07\x04!\x03\x02\x02\x01\x03\x12\x04\xef\x04\x18\x19\n\x0e\n\
    \x06\x04!\x03\x02\x02\x02\x12\x04\xf0\x04\x04\x19\n\x11\n\x07\x04!\x03\
    \x02\x02\x02\x04\x12\x06\xf0\x04\x04\xef\x04\x1a\n\x0f\n\x07\x04!\x03\
    \x02\x02\x02\x05\x12\x04\xf0\x04\x04\t\n\x0f\n\x07\x04!\x03\x02\x02\x02\
    \x01\x12\x04\xf0\x04\n\x14\n\x0f\n\x07\x04!\x03\x02\x02\x02\x03\x12\x04\
    \xf0\x04\x17\x18\n\x0e\n\x06\x04!\x03\x02\x02\x03\x12\x04\xf1\x04\x04\
    \x1c\n\x11\n\x07\x04!\x03\x02\x02\x03\x04\x12\x06\xf1\x04\x04\xf0\x04\
    \x19\n\x0f\n\x07\x04!\x03\x02\x02\x03\x05\x12\x04\xf1\x04\x04\x08\n\x0f\
    \n\x07\x04!\x03\x02\x02\x03\x01\x12\x04\xf1\x04\t\x17\n\x0f\n\x07\x04!\
    \x03\x02\x02\x03\x03\x12\x04\xf1\x04\x1a\x1b\n\x0e\n\x06\x04!\x03\x02\
    \x02\x04\x12\x04\xf2\x04\x04\x1d\n\x11\n\x07\x04!\x03\x02\x02\x04\x04\
    \x12\x06\xf2\x04\x04\xf1\x04\x1c\n\x0f\n\x07\x04!\x03\x02\x02\x04\x05\
    \x12\x04\xf2\x04\x04\t\n\x0f\n\x07\x04!\x03\x02\x02\x04\x01\x12\x04\xf2\
    \x04\n\x18\n\x0f\n\x07\x04!\x03\x02\x02\x04\x03\x12\x04\xf2\x04\x1b\x1c\
    \n\x0e\n\x06\x04!\x03\x02\x02\x05\x12\x04\xf3\x04\x04\x1e\n\x11\n\x07\
    \x04!\x03\x02\x02\x05\x04\x12\x06\xf3\x04\x04\xf2\x04\x1d\n\x0f\n\x07\
    \x04!\x03\x02\x02\x05\x05\x12\x04\xf3\x04\x04\t\n\x0f\n\x07\x04!\x03\x02\
    \x02\x05\x01\x12\x04\xf3\x04\n\x19\n\x0f\n\x07\x04!\x03\x02\x02\x05\x03\
    \x12\x04\xf3\x04\x1c\x1d\n\x0e\n\x06\x04!\x03\x02\x02\x06\x12\x04\xf4\
    \x04\x04\x1b\n\x11\n\x07\x04!\x03\x02\x02\x06\x04\x12\x06\xf4\x04\x04\
    \xf3\x04\x1e\n\x0f\n\x07\x04!\x03\x02\x02\x06\x05\x12\x04\xf4\x04\x04\t\
    \n\x0f\n\x07\x04!\x03\x02\x02\x06\x01\x12\x04\xf4\x04\n\x16\n\x0f\n\x07\
    \x04!\x03\x02\x02\x06\x03\x12\x04\xf4\x04\x19\x1a\n\x0e\n\x06\x04!\x03\
    \x02\x02\x07\x12\x04\xf5\x04\x04\x1e\n\x11\n\x07\x04!\x03\x02\x02\x07\
    \x04\x12\x06\xf5\x04\x04\xf4\x04\x1b\n\x0f\n\x07\x04!\x03\x02\x02\x07\
    \x05\x12\x04\xf5\x04\x04\t\n\x0f\n\x07\x04!\x03\x02\x02\x07\x01\x12\x04\
    \xf5\x04\n\x19\n\x0f\n\x07\x04!\x03\x02\x02\x07\x03\x12\x04\xf5\x04\x1c\
    \x1d\n\x0e\n\x06\x04!\x03\x02\x02\x08\x12\x04\xf6\x04\x04$\n\x11\n\x07\
    \x04!\x03\x02\x02\x08\x04\x12\x06\xf6\x04\x04\xf5\x04\x1e\n\x0f\n\x07\
    \x04!\x03\x02\x02\x08\x05\x12\x04\xf6\x04\x04\t\n\x0f\n\x07\x04!\x03\x02\
    \x02\x08\x01\x12\x04\xf6\x04\n\x1f\n\x0f\n\x07\x04!\x03\x02\x02\x08\x03\
    \x12\x04\xf6\x04\"#\n\x0e\n\x06\x04!\x03\x02\x02\t\x12\x04\xf7\x04\x04\
    \x20\n\x11\n\x07\x04!\x03\x02\x02\t\x04\x12\x06\xf7\x04\x04\xf6\x04$\n\
    \x0f\n\x07\x04!\x03\x02\x02\t\x05\x12\x04\xf7\x04\x04\t\n\x0f\n\x07\x04!\
    \x03\x02\x02\t\x01\x12\x04\xf7\x04\n\x1a\n\x0f\n\x07\x04!\x03\x02\x02\t\
    \x03\x12\x04\xf7\x04\x1d\x1f\n\x0e\n\x06\x04!\x03\x02\x02\n\x12\x04\xf8\
    \x04\x04\x20\n\x11\n\x07\x04!\x03\x02\x02\n\x04\x12\x06\xf8\x04\x04\xf7\
    \x04\x20\n\x0f\n\x07\x04!\x03\x02\x02\n\x05\x12\x04\xf8\x04\x04\t\n\x0f\
    \n\x07\x04!\x03\x02\x02\n\x01\x12\x04\xf8\x04\n\x1a\n\x0f\n\x07\x04!\x03\
    \x02\x02\n\x03\x12\x04\xf8\x04\x1d\x1f\n\x0e\n\x06\x04!\x03\x02\x02\x0b\
    \x12\x04\xf9\x04\x04\x1e\n\x11\n\x07\x04!\x03\x02\x02\x0b\x04\x12\x06\
    \xf9\x04\x04\xf8\x04\x20\n\x0f\n\x07\x04!\x03\x02\x02\x0b\x05\x12\x04\
    \xf9\x04\x04\t\n\x0f\n\x07\x04!\x03\x02\x02\x0b\x01\x12\x04\xf9\x04\n\
    \x18\n\x0f\n\x07\x04!\x03\x02\x02\x0b\x03\x12\x04\xf9\x04\x1b\x1d\n\x0e\
    \n\x06\x04!\x03\x02\x02\x0c\x12\x04\xfa\x04\x04\x19\n\x11\n\x07\x04!\x03\
    \x02\x02\x0c\x04\x12\x06\xfa\x04\x04\xf9\x04\x1e\n\x0f\n\x07\x04!\x03\
    \x02\x02\x0c\x05\x12\x04\xfa\x04\x04\t\n\x0f\n\x07\x04!\x03\x02\x02\x0c\
    \x01\x12\x04\xfa\x04\n\x13\n\x0f\n\x07\x04!\x03\x02\x02\x0c\x03\x12\x04\
    \xfa\x04\x16\x18\n\x0e\n\x06\x04!\x03\x02\x02\r\x12\x04\xfb\x04\x04$\n\
    \x11\n\x07\x04!\x03\x02\x02\r\x04\x12\x06\xfb\x04\x04\xfa\x04\x19\n\x0f\
    \n\x07\x04!\x03\x02\x02\r\x05\x12\x04\xfb\x04\x04\t\n\x0f\n\x07\x04!\x03\
    \x02\x02\r\x01\x12\x04\xfb\x04\n\x1e\n\x0f\n\x07\x04!\x03\x02\x02\r\x03\
    \x12\x04\xfb\x04!#\n\x0e\n\x06\x04!\x03\x02\x02\x0e\x12\x04\xfc\x04\x04\
    \x1e\n\x11\n\x07\x04!\x03\x02\x02\x0e\x04\x12\x06\xfc\x04\x04\xfb\x04$\n\
    \x0f\n\x07\x04!\x03\x02\x02\x0e\x05\x12\x04\xfc\x04\x04\x08\n\x0f\n\x07\
    \x04!\x03\x02\x02\x0e\x01\x12\x04\xfc\x04\t\x18\n\x0f\n\x07\x04!\x03\x02\
    \x02\x0e\x03\x12\x04\xfc\x04\x1b\x1d\n\x0e\n\x06\x04!\x03\x02\x02\x0f\
    \x12\x04\xfd\x04\x04\x1d\n\x11\n\x07\x04!\x03\x02\x02\x0f\x04\x12\x06\
    \xfd\x04\x04\xfc\x04\x1e\n\x0f\n\x07\x04!\x03\x02\x02\x0f\x05\x12\x04\
    \xfd\x04\x04\n\n\x0f\n\x07\x04!\x03\x02\x02\x0f\x01\x12\x04\xfd\x04\x0b\
    \x17\n\x0f\n\x07\x04!\x03\x02\x02\x0f\x03\x12\x04\xfd\x04\x1a\x1c\n\x0e\
    \n\x06\x04!\x03\x02\x02\x10\x12\x04\xfe\x04\x04\x1d\n\x11\n\x07\x04!\x03\
    \x02\x02\x10\x04\x12\x06\xfe\x04\x04\xfd\x04\x1d\n\x0f\n\x07\x04!\x03\
    \x02\x02\x10\x05\x12\x04\xfe\x04\x04\n\n\x0f\n\x07\x04!\x03\x02\x02\x10\
    \x01\x12\x04\xfe\x04\x0b\x17\n\x0f\n\x07\x04!\x03\x02\x02\x10\x03\x12\
    \x04\xfe\x04\x1a\x1c\n\x0e\n\x06\x04!\x03\x02\x02\x11\x12\x04\xff\x04\
    \x04(\n\x11\n\x07\x04!\x03\x02\x02\x11\x04\x12\x06\xff\x04\x04\xfe\x04\
    \x1d\n\x0f\n\x07\x04!\x03\x02\x02\x11\x05\x12\x04\xff\x04\x04\t\n\x0f\n\
    \x07\x04!\x03\x02\x02\x11\x01\x12\x04\xff\x04\n\"\n\x0f\n\x07\x04!\x03\
    \x02\x02\x11\x03\x12\x04\xff\x04%'\n\x0e\n\x06\x04!\x03\x02\x02\x12\x12\
    \x04\x80\x05\x04#\n\x11\n\x07\x04!\x03\x02\x02\x12\x04\x12\x06\x80\x05\
    \x04\xff\x04(\n\x0f\n\x07\x04!\x03\x02\x02\x12\x05\x12\x04\x80\x05\x04\t\
    \n\x0f\n\x07\x04!\x03\x02\x02\x12\x01\x12\x04\x80\x05\n\x1d\n\x0f\n\x07\
    \x04!\x03\x02\x02\x12\x03\x12\x04\x80\x05\x20\"\n\x0e\n\x04\x04!\x03\x03\
    \x12\x06\x83\x05\x02\xa3\x05\x03\n\r\n\x05\x04!\x03\x03\x01\x12\x04\x83\
    \x05\n\x15\n\x0e\n\x06\x04!\x03\x03\x02\0\x12\x04\x84\x05\x04\x1a\n\x11\
    \n\x07\x04!\x03\x03\x02\0\x04\x12\x06\x84\x05\x04\x83\x05\x17\n\x0f\n\
    \x07\x04!\x03\x03\x02\0\x05\x12\x04\x84\x05\x04\t\n\x0f\n\x07\x04!\x03\
    \x03\x02\0\x01\x12\x04\x84\x05\n\x15\n\x0f\n\x07\x04!\x03\x03\x02\0\x03\
    \x12\x04\x84\x05\x18\x19\n\x0e\n\x06\x04!\x03\x03\x02\x01\x12\x04\x85\
    \x05\x04\"\n\x11\n\x07\x04!\x03\x03\x02\x01\x04\x12\x06\x85\x05\x04\x84\
    \x05\x1a\n\x0f\n\x07\x04!\x03\x03\x02\x01\x05\x12\x04\x85\x05\x04\t\n\
    \x0f\n\x07\x04!\x03\x03\x02\x01\x01\x12\x04\x85\x05\n\x1d\n\x0f\n\x07\
    \x04!\x03\x03\x02\x01\x03\x12\x04\x85\x05\x20!\n\x0e\n\x06\x04!\x03\x03\
    \x02\x02\x12\x04\x86\x05\x04\x17\n\x11\n\x07\x04!\x03\x03\x02\x02\x04\
    \x12\x06\x86\x05\x04\x85\x05\"\n\x0f\n\x07\x04!\x03\x03\x02\x02\x05\x12\
    \x04\x86\x05\x04\t\n\x0f\n\x07\x04!\x03\x03\x02\x02\x01\x12\x04\x86\x05\
    \n\x12\n\x0f\n\x07\x04!\x03\x03\x02\x02\x03\x12\x04\x86\x05\x15\x16\n\
    \x0e\n\x06\x04!\x03\x03\x02\x03\x12\x04\x87\x05\x04\x1a\n\x11\n\x07\x04!\
    \x03\x03\x02\x03\x04\x12\x06\x87\x05\x04\x86\x05\x17\n\x0f\n\x07\x04!\
    \x03\x03\x02\x03\x05\x12\x04\x87\x05\x04\t\n\x0f\n\x07\x04!\x03\x03\x02\
    \x03\x01\x12\x04\x87\x05\n\x15\n\x0f\n\x07\x04!\x03\x03\x02\x03\x03\x12\
    \x04\x87\x05\x18\x19\n\x0e\n\x06\x04!\x03\x03\x02\x04\x12\x04\x88\x05\
    \x04\x19\n\x11\n\x07\x04!\x03\x03\x02\x04\x04\x12\x06\x88\x05\x04\x87\
    \x05\x1a\n\x0f\n\x07\x04!\x03\x03\x02\x04\x05\x12\x04\x88\x05\x04\t\n\
    \x0f\n\x07\x04!\x03\x03\x02\x04\x01\x12\x04\x88\x05\n\x14\n\x0f\n\x07\
    \x04!\x03\x03\x02\x04\x03\x12\x04\x88\x05\x17\x18\n\x0e\n\x06\x04!\x03\
    \x03\x02\x05\x12\x04\x89\x05\x04\x17\n\x11\n\x07\x04!\x03\x03\x02\x05\
    \x04\x12\x06\x89\x05\x04\x88\x05\x19\n\x0f\n\x07\x04!\x03\x03\x02\x05\
    \x05\x12\x04\x89\x05\x04\n\n\x0f\n\x07\x04!\x03\x03\x02\x05\x01\x12\x04\
    \x89\x05\x0b\x12\n\x0f\n\x07\x04!\x03\x03\x02\x05\x03\x12\x04\x89\x05\
    \x15\x16\n\x0e\n\x06\x04!\x03\x03\x02\x06\x12\x04\x8a\x05\x04\x1b\n\x11\
    \n\x07\x04!\x03\x03\x02\x06\x04\x12\x06\x8a\x05\x04\x89\x05\x17\n\x0f\n\
    \x07\x04!\x03\x03\x02\x06\x05\x12\x04\x8a\x05\x04\n\n\x0f\n\x07\x04!\x03\
    \x03\x02\x06\x01\x12\x04\x8a\x05\x0b\x16\n\x0f\n\x07\x04!\x03\x03\x02\
    \x06\x03\x12\x04\x8a\x05\x19\x1a\n\x0e\n\x06\x04!\x03\x03\x02\x07\x12\
    \x04\x8b\x05\x04\x16\n\x11\n\x07\x04!\x03\x03\x02\x07\x04\x12\x06\x8b\
    \x05\x04\x8a\x05\x1b\n\x0f\n\x07\x04!\x03\x03\x02\x07\x05\x12\x04\x8b\
    \x05\x04\n\n\x0f\n\x07\x04!\x03\x03\x02\x07\x01\x12\x04\x8b\x05\x0b\x11\
    \n\x0f\n\x07\x04!\x03\x03\x02\x07\x03\x12\x04\x8b\x05\x14\x15\n\x0e\n\
    \x06\x04!\x03\x03\x02\x08\x12\x04\x8c\x05\x04\x1e\n\x11\n\x07\x04!\x03\
    \x03\x02\x08\x04\x12\x06\x8c\x05\x04\x8b\x05\x16\n\x0f\n\x07\x04!\x03\
    \x03\x02\x08\x05\x12\x04\x8c\x05\x04\t\n\x0f\n\x07\x04!\x03\x03\x02\x08\
    \x01\x12\x04\x8c\x05\n\x19\n\x0f\n\x07\x04!\x03\x03\x02\x08\x03\x12\x04\
    \x8c\x05\x1c\x1d\n\x0e\n\x06\x04!\x03\x03\x02\t\x12\x04\x8d\x05\x04\x1d\
    \n\x11\n\x07\x04!\x03\x03\x02\t\x04\x12\x06\x8d\x05\x04\x8c\x05\x1e\n\
    \x0f\n\x07\x04!\x03\x03\x02\t\x05\x12\x04\x8d\x05\x04\t\n\x0f\n\x07\x04!\
    \x03\x03\x02\t\x01\x12\x04\x8d\x05\n\x17\n\x0f\n\x07\x04!\x03\x03\x02\t\
    \x03\x12\x04\x8d\x05\x1a\x1c\n\x0e\n\x06\x04!\x03\x03\x02\n\x12\x04\x8e\
    \x05\x04\x1f\n\x11\n\x07\x04!\x03\x03\x02\n\x04\x12\x06\x8e\x05\x04\x8d\
    \x05\x1d\n\x0f\n\x07\x04!\x03\x03\x02\n\x05\x12\x04\x8e\x05\x04\n\n\x0f\
    \n\x07\x04!\x03\x03\x02\n\x01\x12\x04\x8e\x05\x0b\x19\n\x0f\n\x07\x04!\
    \x03\x03\x02\n\x03\x12\x04\x8e\x05\x1c\x1e\n\x0e\n\x06\x04!\x03\x03\x02\
    \x0b\x12\x04\x8f\x05\x044\n\x0f\n\x07\x04!\x03\x03\x02\x0b\x04\x12\x04\
    \x8f\x05\x04\x0c\n\x0f\n\x07\x04!\x03\x03\x02\x0b\x06\x12\x04\x8f\x05\r\
    \x1b\n\x0f\n\x07\x04!\x03\x03\x02\x0b\x01\x12\x04\x8f\x05\x1c.\n\x0f\n\
    \x07\x04!\x03\x03\x02\x0b\x03\x12\x04\x8f\x0513\n\x0e\n\x06\x04!\x03\x03\
    \x02\x0c\x12\x04\x90\x05\x04<\n\x0f\n\x07\x04!\x03\x03\x02\x0c\x04\x12\
    \x04\x90\x05\x04\x0c\n\x0f\n\x07\x04!\x03\x03\x02\x0c\x06\x12\x04\x90\
    \x05\r\x1f\n\x0f\n\x07\x04!\x03\x03\x02\x0c\x01\x12\x04\x90\x05\x206\n\
    \x0f\n\x07\x04!\x03\x03\x02\x0c\x03\x12\x04\x90\x059;\n\x10\n\x06\x04!\
    \x03\x03\x03\0\x12\x06\x92\x05\x04\x98\x05\x05\n\x0f\n\x07\x04!\x03\x03\
    \x03\0\x01\x12\x04\x92\x05\x0c\x1a\n\x10\n\x08\x04!\x03\x03\x03\0\x02\0\
    \x12\x04\x93\x05\x06\x16\n\x13\n\t\x04!\x03\x03\x03\0\x02\0\x04\x12\x06\
    \x93\x05\x06\x92\x05\x1c\n\x11\n\t\x04!\x03\x03\x03\0\x02\0\x05\x12\x04\
    \x93\x05\x06\x0c\n\x11\n\t\x04!\x03\x03\x03\0\x02\0\x01\x12\x04\x93\x05\
    \r\x11\n\x11\n\t\x04!\x03\x03\x03\0\x02\0\x03\x12\x04\x93\x05\x14\x15\n\
    \x10\n\x08\x04!\x03\x03\x03\0\x02\x01\x12\x04\x94\x05\x06\x19\n\x13\n\t\
    \x04!\x03\x03\x03\0\x02\x01\x04\x12\x06\x94\x05\x06\x93\x05\x16\n\x11\n\
    \t\x04!\x03\x03\x03\0\x02\x01\x05\x12\x04\x94\x05\x06\x0b\n\x11\n\t\x04!\
    \x03\x03\x03\0\x02\x01\x01\x12\x04\x94\x05\x0c\x14\n\x11\n\t\x04!\x03\
    \x03\x03\0\x02\x01\x03\x12\x04\x94\x05\x17\x18\n\x10\n\x08\x04!\x03\x03\
    \x03\0\x02\x02\x12\x04\x95\x05\x06\x18\n\x13\n\t\x04!\x03\x03\x03\0\x02\
    \x02\x04\x12\x06\x95\x05\x06\x94\x05\x19\n\x11\n\t\x04!\x03\x03\x03\0\
    \x02\x02\x05\x12\x04\x95\x05\x06\x0b\n\x11\n\t\x04!\x03\x03\x03\0\x02\
    \x02\x01\x12\x04\x95\x05\x0c\x13\n\x11\n\t\x04!\x03\x03\x03\0\x02\x02\
    \x03\x12\x04\x95\x05\x16\x17\n\x10\n\x08\x04!\x03\x03\x03\0\x02\x03\x12\
    \x04\x96\x05\x06\x18\n\x13\n\t\x04!\x03\x03\x03\0\x02\x03\x04\x12\x06\
    \x96\x05\x06\x95\x05\x18\n\x11\n\t\x04!\x03\x03\x03\0\x02\x03\x05\x12\
    \x04\x96\x05\x06\x0b\n\x11\n\t\x04!\x03\x03\x03\0\x02\x03\x01\x12\x04\
    \x96\x05\x0c\x13\n\x11\n\t\x04!\x03\x03\x03\0\x02\x03\x03\x12\x04\x96\
    \x05\x16\x17\n\x10\n\x08\x04!\x03\x03\x03\0\x02\x04\x12\x04\x97\x05\x06\
    \x19\n\x13\n\t\x04!\x03\x03\x03\0\x02\x04\x04\x12\x06\x97\x05\x06\x96\
    \x05\x18\n\x11\n\t\x04!\x03\x03\x03\0\x02\x04\x05\x12\x04\x97\x05\x06\
    \x0c\n\x11\n\t\x04!\x03\x03\x03\0\x02\x04\x01\x12\x04\x97\x05\r\x14\n\
    \x11\n\t\x04!\x03\x03\x03\0\x02\x04\x03\x12\x04\x97\x05\x17\x18\n\x10\n\
    \x06\x04!\x03\x03\x03\x01\x12\x06\x9a\x05\x04\xa2\x05\x05\n\x0f\n\x07\
    \x04!\x03\x03\x03\x01\x01\x12\x04\x9a\x05\x0c\x1e\n\x10\n\x08\x04!\x03\
    \x03\x03\x01\x02\0\x12\x04\x9b\x05\x06\x16\n\x13\n\t\x04!\x03\x03\x03\
    \x01\x02\0\x04\x12\x06\x9b\x05\x06\x9a\x05\x20\n\x11\n\t\x04!\x03\x03\
    \x03\x01\x02\0\x05\x12\x04\x9b\x05\x06\x0c\n\x11\n\t\x04!\x03\x03\x03\
    \x01\x02\0\x01\x12\x04\x9b\x05\r\x11\n\x11\n\t\x04!\x03\x03\x03\x01\x02\
    \0\x03\x12\x04\x9b\x05\x14\x15\n\x10\n\x08\x04!\x03\x03\x03\x01\x02\x01\
    \x12\x04\x9c\x05\x06\x1a\n\x13\n\t\x04!\x03\x03\x03\x01\x02\x01\x04\x12\
    \x06\x9c\x05\x06\x9b\x05\x16\n\x11\n\t\x04!\x03\x03\x03\x01\x02\x01\x05\
    \x12\x04\x9c\x05\x06\x0c\n\x11\n\t\x04!\x03\x03\x03\x01\x02\x01\x01\x12\
    \x04\x9c\x05\r\x15\n\x11\n\t\x04!\x03\x03\x03\x01\x02\x01\x03\x12\x04\
    \x9c\x05\x18\x19\n\x10\n\x08\x04!\x03\x03\x03\x01\x02\x02\x12\x04\x9d\
    \x05\x06\x1b\n\x13\n\t\x04!\x03\x03\x03\x01\x02\x02\x04\x12\x06\x9d\x05\
    \x06\x9c\x05\x1a\n\x11\n\t\x04!\x03\x03\x03\x01\x02\x02\x05\x12\x04\x9d\
    \x05\x06\x0c\n\x11\n\t\x04!\x03\x03\x03\x01\x02\x02\x01\x12\x04\x9d\x05\
    \r\x16\n\x11\n\t\x04!\x03\x03\x03\x01\x02\x02\x03\x12\x04\x9d\x05\x19\
    \x1a\n\x10\n\x08\x04!\x03\x03\x03\x01\x02\x03\x12\x04\x9e\x05\x06\x17\n\
    \x13\n\t\x04!\x03\x03\x03\x01\x02\x03\x04\x12\x06\x9e\x05\x06\x9d\x05\
    \x1b\n\x11\n\t\x04!\x03\x03\x03\x01\x02\x03\x05\x12\x04\x9e\x05\x06\x0c\
    \n\x11\n\t\x04!\x03\x03\x03\x01\x02\x03\x01\x12\x04\x9e\x05\r\x12\n\x11\
    \n\t\x04!\x03\x03\x03\x01\x02\x03\x03\x12\x04\x9e\x05\x15\x16\n\x10\n\
    \x08\x04!\x03\x03\x03\x01\x02\x04\x12\x04\x9f\x05\x06\x1a\n\x13\n\t\x04!\
    \x03\x03\x03\x01\x02\x04\x04\x12\x06\x9f\x05\x06\x9e\x05\x17\n\x11\n\t\
    \x04!\x03\x03\x03\x01\x02\x04\x05\x12\x04\x9f\x05\x06\x0b\n\x11\n\t\x04!\
    \x03\x03\x03\x01\x02\x04\x01\x12\x04\x9f\x05\x0c\x15\n\x11\n\t\x04!\x03\
    \x03\x03\x01\x02\x04\x03\x12\x04\x9f\x05\x18\x19\n\x10\n\x08\x04!\x03\
    \x03\x03\x01\x02\x05\x12\x04\xa0\x05\x06\x19\n\x13\n\t\x04!\x03\x03\x03\
    \x01\x02\x05\x04\x12\x06\xa0\x05\x06\x9f\x05\x1a\n\x11\n\t\x04!\x03\x03\
    \x03\x01\x02\x05\x05\x12\x04\xa0\x05\x06\x0b\n\x11\n\t\x04!\x03\x03\x03\
    \x01\x02\x05\x01\x12\x04\xa0\x05\x0c\x14\n\x11\n\t\x04!\x03\x03\x03\x01\
    \x02\x05\x03\x12\x04\xa0\x05\x17\x18\n\x10\n\x08\x04!\x03\x03\x03\x01\
    \x02\x06\x12\x04\xa1\x05\x06\x1c\n\x13\n\t\x04!\x03\x03\x03\x01\x02\x06\
    \x04\x12\x06\xa1\x05\x06\xa0\x05\x19\n\x11\n\t\x04!\x03\x03\x03\x01\x02\
    \x06\x05\x12\x04\xa1\x05\x06\x0c\n\x11\n\t\x04!\x03\x03\x03\x01\x02\x06\
    \x01\x12\x04\xa1\x05\r\x17\n\x11\n\t\x04!\x03\x03\x03\x01\x02\x06\x03\
    \x12\x04\xa1\x05\x1a\x1bb\x06proto3\
";

static mut file_descriptor_proto_lazy: ::protobuf::lazy::Lazy<::protobuf::descriptor::FileDescriptorProto> = ::protobuf::lazy::Lazy {
    lock: ::protobuf::lazy::ONCE_INIT,
    ptr: 0 as *const ::protobuf::descriptor::FileDescriptorProto,
};

fn parse_descriptor_proto() -> ::protobuf::descriptor::FileDescriptorProto {
    ::protobuf::parse_from_bytes(file_descriptor_proto_data).unwrap()
}

pub fn file_descriptor_proto() -> &'static ::protobuf::descriptor::FileDescriptorProto {
    unsafe {
        file_descriptor_proto_lazy.get(|| {
            parse_descriptor_proto()
        })
    }
}
